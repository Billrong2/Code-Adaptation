{
  "code": "public void resizeText(int width, int height) {\n        CharSequence text = getText();\n        if (text == null || text.length() == 0 || width <= 0 || height <= 0) {\n            return;\n        }\n\n        // Use the TextView's existing TextPaint directly\n        TextPaint textPaint = getPaint();\n        float oldTextSize = textPaint.getTextSize();\n\n        // Determine starting target size\n        float targetTextSize = mMaxTextSize > 0 ? Math.min(mTextSize, mMaxTextSize) : mTextSize;\n        if (targetTextSize <= 0) {\n            // Fall back to current paint size if unset\n            targetTextSize = oldTextSize;\n        }\n\n        // Measure text height and shrink until it fits or reaches minimum size\n        int textHeight = getTextHeight(text, textPaint, width, targetTextSize);\n        while (textHeight > height && targetTextSize > mMinTextSize) {\n            targetTextSize = Math.max(targetTextSize - 2f, mMinTextSize);\n            textHeight = getTextHeight(text, textPaint, width, targetTextSize);\n        }\n\n        // If still too large at minimum size, append ellipsis\n        if (mAddEllipsis && targetTextSize == mMinTextSize && textHeight > height) {\n            // Build StaticLayout with the same TextPaint and draw immediately\n            StaticLayout layout = new StaticLayout(text, textPaint, width, Alignment.ALIGN_NORMAL, mSpacingMult, mSpacingAdd, false);\n            layout.draw(sTextResizeCanvas);\n\n            // Compute last visible line directly and trim\n            int lastLine = layout.getLineForVertical(height) - 1;\n            int start = layout.getLineStart(lastLine);\n            int end = layout.getLineEnd(lastLine);\n\n            float lineWidth = layout.getLineWidth(lastLine);\n            float ellipsisWidth = textPaint.measureText(mEllipsis);\n\n            // Trim characters until ellipsis fits\n            while (width < lineWidth + ellipsisWidth && end > start) {\n                end--;\n                lineWidth = textPaint.measureText(text.subSequence(start, end).toString());\n            }\n\n            setText(text.subSequence(0, end).toString() + mEllipsis);\n        }\n\n        // Apply final text size directly on the TextPaint\n        textPaint.setTextSize(targetTextSize);\n\n        // Force default line spacing to invalidate layout\n        setLineSpacing(mSpacingAdd, mSpacingMult);\n\n        // Notify listener if registered\n        if (mTextResizeListener != null) {\n            mTextResizeListener.onTextResize(this, oldTextSize, targetTextSize);\n        }\n\n        mNeedsResize = false;\n    }",
  "explanation": "code_hardening: Removed the mTextSize == 0 early-return guard but kept basic null/empty text and dimension validation. Added a minimal fallback to the current TextPaint size if the computed target size is non-positive, and ensured the shared sTextResizeCanvas is used under the assumption it is initialized and safe as a static field.\nresolve_compilation_errors: Reused the existing getPaint() TextPaint instead of creating a copy, relied on the already-declared static Canvas sTextResizeCanvas, and avoided TypedValue-based APIs by calling TextPaint.setTextSize directly.\nexception_handling: none.\nlogic_customization: Eliminated the mTextSize == 0 guard, reused the TextViewâ€™s TextPaint for measuring and StaticLayout construction, immediately drew the StaticLayout to sTextResizeCanvas, removed ellipsis safety checks, directly computed the last visible line, always trimmed the last line to fit the ellipsis, and applied the final size via textPaint.setTextSize while retaining line-spacing invalidation.\nrefactoring: Removed unused paint-copy logic and safety-guard branches, simplified variable usage, and updated inline flow to reflect the new ellipsis and sizing behavior.\nmisc: Minor reordering and comments for clarity; no new custom API calls introduced beyond existing Android framework classes."
}