{
  "code": "void resizeText(int width, int height) {\n        // Do not resize if not needed or if dimensions/text are invalid\n        if (!mNeedsResize) {\n            return;\n        }\n        CharSequence text = getText();\n        if (text == null || text.length() == 0 || height <= 0 || width <= 0 || mTextSize <= 0) {\n            mNeedsResize = false;\n            return;\n        }\n\n        final float SIZE_DECREMENT_PX = 2f;\n\n        // Use the view's existing TextPaint directly\n        TextPaint textPaint = getPaint();\n\n        // Store the current text size\n        float oldTextSize = textPaint.getTextSize();\n\n        // Determine starting target size\n        float targetTextSize = mMaxTextSize > 0 ? Math.min(mTextSize, mMaxTextSize) : mTextSize;\n\n        // Measure initial height\n        int textHeight = getTextHeight(text, textPaint, width, targetTextSize);\n\n        // Reduce text size until it fits or reaches minimum\n        while (textHeight > height && targetTextSize > mMinTextSize) {\n            targetTextSize = Math.max(targetTextSize - SIZE_DECREMENT_PX, mMinTextSize);\n            textHeight = getTextHeight(text, textPaint, width, targetTextSize);\n        }\n\n        // Apply ellipsis if needed at minimum size\n        if (mAddEllipsis && targetTextSize == mMinTextSize && textHeight > height) {\n            // Ensure paint is at the target size for consistent measurement\n            textPaint.setTextSize(targetTextSize);\n            StaticLayout layout = new StaticLayout(text, textPaint, width,\n                    Alignment.ALIGN_NORMAL, mSpacingMult, mSpacingAdd, false);\n            if (layout.getLineCount() > 0) {\n                int lastLine = layout.getLineForVertical(height) - 1;\n                if (lastLine < 0) {\n                    setText(\"\");\n                } else {\n                    int start = layout.getLineStart(lastLine);\n                    int end = layout.getLineEnd(lastLine);\n                    float lineWidth = layout.getLineWidth(lastLine);\n                    float ellipsisWidth = textPaint.measureText(mEllipsis);\n                    // Trim characters until ellipsis fits\n                    while (end > start && width < lineWidth + ellipsisWidth) {\n                        end--;\n                        lineWidth = textPaint.measureText(text.subSequence(start, end).toString());\n                    }\n                    setText(text.subSequence(0, end) + mEllipsis);\n                }\n            }\n        }\n\n        // Apply the computed text size directly to the TextPaint\n        textPaint.setTextSize(targetTextSize);\n        // Enforce consistent line spacing\n        setLineSpacing(mSpacingAdd, mSpacingMult);\n\n        // Notify listener\n        if (mTextResizeListener != null) {\n            mTextResizeListener.onTextResize(this, oldTextSize, targetTextSize);\n        }\n\n        // Reset force resize flag\n        mNeedsResize = false;\n    }",
  "explanation": "code_hardening: Added an early guard using mNeedsResize to avoid repeated resize loops when called from onLayout, validated text and dimension inputs, and introduced a named SIZE_DECREMENT_PX constant instead of a magic value. Ensured TextPaint size is explicitly set before ellipsis measurement to keep state consistent.\nresolve_compilation_errors: Changed method visibility to package-private by removing the public modifier, aligned usage with existing class fields and methods, and avoided view-level setTextSize calls so no unit-based overloads are required. No additional invalidation was needed because onLayout drives resizing.\nexception_handling: none.\nlogic_customization: Applied the computed targetTextSize directly via textPaint.setTextSize instead of calling TextView.setTextSize with units, and removed creation of a copied TextPaint so all measurements and layouts use the view’s existing TextPaint. Ellipsis logic was adjusted to work with the same TextPaint instance at the target size.\nrefactoring: Simplified paint handling by consistently using the existing TextPaint, renamed the decrement to a constant for clarity, and kept logic contained within the method without introducing helpers.\nmisc: Updated inline comments to reflect that no TextPaint copy is created and that the TextPaint itself is updated rather than the view’s text size. No new custom API calls were introduced."}