{
  "code": "public TouchImageView(final android.content.Context context) {\n    super(context);\n    if (context == null) {\n        return;\n    }\n    this.context = context;\n\n    setClickable(true);\n\n    // Initialize matrix-related state defensively\n    if (matrix == null) {\n        matrix = new android.graphics.Matrix();\n    }\n    matrix.setTranslate(1f, 1f);\n    m = new float[9];\n    setImageMatrix(matrix);\n    setScaleType(android.widget.ImageView.ScaleType.MATRIX);\n\n    // Initialize gesture detectors once\n    mScaleDetector = new android.view.ScaleGestureDetector(context, new ScaleListener());\n    gdt = new android.view.GestureDetector(context, new GestureListener());\n\n    setOnTouchListener(new android.view.View.OnTouchListener() {\n        @Override\n        public boolean onTouch(android.view.View v, android.view.MotionEvent event) {\n            if (event == null) {\n                return false;\n            }\n\n            // Feed all events to detectors\n            mScaleDetector.onTouchEvent(event);\n            gdt.onTouchEvent(event);\n\n            matrix.getValues(m);\n            float x = m[android.graphics.Matrix.MTRANS_X];\n            float y = m[android.graphics.Matrix.MTRANS_Y];\n            android.graphics.PointF curr = new android.graphics.PointF(event.getX(), event.getY());\n\n            switch (event.getActionMasked()) {\n                case android.view.MotionEvent.ACTION_DOWN:\n                    last.set(curr.x, curr.y);\n                    start.set(curr.x, curr.y);\n                    mode = DRAG; // always enter DRAG on down\n                    break;\n\n                case android.view.MotionEvent.ACTION_MOVE:\n                    if (mode == DRAG) {\n                        float deltaX = curr.x - last.x;\n                        float deltaY = curr.y - last.y;\n                        float scaleWidth = Math.round(origWidth * saveScale);\n                        float scaleHeight = Math.round(origHeight * saveScale);\n\n                        if (scaleWidth < width) {\n                            deltaX = 0;\n                            if (y + deltaY > 0) {\n                                deltaY = -y;\n                            } else if (y + deltaY < -bottom) {\n                                deltaY = -(y + bottom);\n                            }\n                        } else if (scaleHeight < height) {\n                            deltaY = 0;\n                            if (x + deltaX > 0) {\n                                deltaX = -x;\n                            } else if (x + deltaX < -right) {\n                                deltaX = -(x + right);\n                            }\n                        } else {\n                            if (x + deltaX > 0) {\n                                deltaX = -x;\n                            } else if (x + deltaX < -right) {\n                                deltaX = -(x + right);\n                            }\n\n                            if (y + deltaY > 0) {\n                                deltaY = -y;\n                            } else if (y + deltaY < -bottom) {\n                                deltaY = -(y + bottom);\n                            }\n                        }\n                        matrix.postTranslate(deltaX, deltaY);\n                        last.set(curr.x, curr.y);\n                    }\n                    break;\n\n                case android.view.MotionEvent.ACTION_UP:\n                    mode = NONE;\n                    int xDiff = (int) Math.abs(curr.x - start.x);\n                    int yDiff = (int) Math.abs(curr.y - start.y);\n                    if (xDiff < CLICK && yDiff < CLICK) {\n                        performClick();\n                    }\n                    break;\n\n                case android.view.MotionEvent.ACTION_POINTER_UP:\n                    mode = NONE;\n                    break;\n            }\n\n            setImageMatrix(matrix);\n            invalidate();\n            return true;\n        }\n    });\n}",
  "explanation": "code_hardening: Added null checks for Context and MotionEvent, ensured matrix and arrays are initialized, and removed Toast side effects. Gesture detectors are created once and reused.\nresolve_compilation_errors: Converted the setup logic into a proper public constructor calling super(context); initialized ScaleGestureDetector and GestureDetector fields; removed creation of local GestureDetector instances and all FLING/SWIPE references.\nexception_handling: none.\nlogic_customization: Created a single persistent GestureDetector and forwarded all MotionEvents to it; removed manual swipe/fling detection and mode flags; always enter DRAG mode on ACTION_DOWN; preserved existing matrix translation and pinch-zoom behavior; performClick() is only invoked for small movements on ACTION_UP.\nrefactoring: Simplified onTouch flow by removing obsolete branches and flags, grouped initialization in the constructor, and clarified gesture responsibilities.\nmisc: Updated comments implicitly by behavior, reformatted code for readability, and removed redundant/debug lines; new custom API calls used: android.view.GestureDetector(android.content.Context, GestureDetector.SimpleOnGestureListener)."}