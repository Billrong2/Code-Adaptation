package com.trsst.server;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.util.Date;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import javax.xml.namespace.QName;

import org.apache.abdera.Abdera;
import org.apache.abdera.i18n.iri.IRI;
import org.apache.abdera.model.Category;
import org.apache.abdera.model.Element;
import org.apache.abdera.model.Entry;
import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.analysis.standard.StandardAnalyzer;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;
import org.apache.lucene.document.LongField;
import org.apache.lucene.document.StringField;
import org.apache.lucene.document.TextField;
import org.apache.lucene.index.AtomicReaderContext;
import org.apache.lucene.index.DirectoryReader;
import org.apache.lucene.index.IndexReader;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.index.IndexWriterConfig;
import org.apache.lucene.index.IndexWriterConfig.OpenMode;
import org.apache.lucene.index.Term;
import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
import org.apache.lucene.queryparser.flexible.standard.StandardQueryParser;
import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler;
import org.apache.lucene.queryparser.flexible.standard.parser.ParseException;
import org.apache.lucene.search.Collector;
import org.apache.lucene.search.Filter;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.NumericRangeFilter;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.ScoreDoc;
import org.apache.lucene.search.Scorer;
import org.apache.lucene.search.Sort;
import org.apache.lucene.search.SortField;
import org.apache.lucene.search.TopDocs;
import org.apache.lucene.store.Directory;
import org.apache.lucene.store.FSDirectory;
import org.apache.lucene.util.Version;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;
import org.w3c.tidy.Tidy;

import com.trsst.Common;
import com.trsst.client.Client;


public class LuceneStorage implements Storage {

    
    private Abdera abdera;

    
    private Storage cacheStorage;

    
    private Storage persistentStorage;

    

    private IndexWriter writer;
    private IndexReader reader;
    private Analyzer analyzer;

    
    public LuceneStorage() throws IOException {
        this(new FileStorage());
    }

    
    public LuceneStorage(Storage delegate) throws IOException {
        this(delegate, null);
    }

    
    public LuceneStorage(Storage cache, Storage persistent) throws IOException {
        cacheStorage = cache;
        persistentStorage = persistent;
        abdera = Abdera.getInstance();
        Directory dir = FSDirectory.open(new File(Common.getServerRoot(),
                "entry.idx"));
        analyzer = new StandardAnalyzer(Version.LUCENE_46);

        IndexWriterConfig iwc = new IndexWriterConfig(Version.LUCENE_46,
                analyzer);
        iwc.setOpenMode(OpenMode.CREATE_OR_APPEND);
        writer = new IndexWriter(dir, iwc);
        writer.commit();
        refreshReader();
    }

    private void refreshReader() throws IOException {
        reader = DirectoryReader.open(writer, true);
    }

    
    public String[] getFeedIds(int start, int length) {
        return persistentStorage.getFeedIds(start, length);
    }

    private boolean isManaged(String feedId) {
        String[] feedIds = getFeedIds(0, 100);
        for (String id : feedIds) {
            if (id.equals(feedId)) {
                return true;
            }
        }
        return false;
    }

    private Storage getStorage(String feedId) {
        if (persistentStorage == null) {
            return cacheStorage;
        }
        if (isManaged(feedId)) {
            return persistentStorage;
        }
        return cacheStorage;
    }

    
    public String[] getCategories(int start, int length) {
        
        
        return new String[0];
    }

    public int getEntryCount(Date after, Date before, String query,
            String[] mentions, String[] tags, String verb) {
        return getEntryCountForFeedId(null, after, before, query, mentions,
                tags, verb);
    }

    public int getEntryCountForFeedId(String feedId, Date after, Date before,
            String search, String[] mentions, String[] tags, String verb) {
        try {
            Filter filter = buildRangeFilter(after, before);
            Query query = buildTextQuery(feedId, search, mentions, tags, verb);
            CountCollector collector = new CountCollector();
            new IndexSearcher(reader).search(query, filter, collector);
            return collector.getCount();
        } catch (IOException e) {
            log.error("Unexpected error getting entry count for feed: "
                    + feedId, e);
        } catch (QueryNodeException e) {
            log.error("Unexpected error executing count query for feed: "
                    + feedId, e);
        }
        return -1;
    }

    public String[] getEntryIds(int start, int length, Date after, Date before,
            String query, String[] mentions, String[] tags, String verb) {
        return _getEntryIdsForFeedId(null, start, length, after, before, query,
                mentions, tags, verb);
    }

    public long[] getEntryIdsForFeedId(String feedId, int start, int length,
            Date after, Date before, String query, String[] mentions,
            String[] tags, String verb) {
        String[] ids = _getEntryIdsForFeedId(feedId, start, length, after,
                before, query, mentions, tags, verb);
        long[] result = null;
        if (ids != null) {
            result = new long[ids.length];
            int i = 0;
            int offset = feedId.length() + 1; 
            for (String id : ids) {
                result[i++] = Long.parseLong(id.substring(offset), 16);
            }
        }
        return result;
    }

    private String[] _getEntryIdsForFeedId(String feedId, int start,
            int length, Date after, Date before, String search,
            String[] mentions, String[] tags, String verb) {
        try {
            Filter filter = buildRangeFilter(after, before);
            Query query = buildTextQuery(feedId, search, mentions, tags, verb);
            TopDocs hits = new IndexSearcher(reader).search(query, filter,
                    start + length, new Sort(new SortField("updated",
                            SortField.Type.LONG, true)));
            String[] result = new String[Math.min(length, hits.totalHits)];
            int i = 0;
            String id;
            int replace;
            Set<String> fields = new HashSet<String>();
            fields.add("entry"); 
            for (ScoreDoc e : hits.scoreDocs) {
                id = new IndexSearcher(reader).doc(e.doc).get("entry");
                replace = id.lastIndexOf('-');
                if (replace != -1) {
                    id = id.substring(0, replace) + ':'
                            + id.substring(replace + 1);
                }
                result[i++] = id;
            }
            return result;
        } catch (IOException e) {
            log.error("Unexpected error getting query for feed: " + feedId, e);
        } catch (QueryNodeException e) {
            log.error("Unexpected error executing query for feed: " + feedId, e);
        }
        return null;
    }

    private Filter buildRangeFilter(Date after, Date before) {
        if (after == null && before == null) {
            return null;
        }

        long afterTime;
        if (after != null) {
            afterTime = after.getTime();
        } else {
            
            afterTime = Long.MIN_VALUE;
        }
        long beforeTime;
        if (before != null) {
            beforeTime = before.getTime();
        } else {
            
            beforeTime = Long.MAX_VALUE;
        }
        return NumericRangeFilter.newLongRange("updated", afterTime,
                beforeTime, false, false);
    }

    private Query buildTextQuery(String feedId, String search,
            String[] mentions, String[] tags, String verb)
            throws QueryNodeException {
        if (search == null) {
            search = "";
        }
        
        
        if (verb != null) {
            search = search + " verb:" + verb;
        }
        if (tags != null) {
            for (String tag : tags) {
                tag = tag.trim();
                if (tag.startsWith(Common.FEED_URN_PREFIX)) {
                    tag = tag.substring(Common.FEED_URN_PREFIX.length());
                }
                if (tag.startsWith(Common.ENTRY_URN_PREFIX)) {
                    tag = tag.substring(Common.ENTRY_URN_PREFIX.length());
                }
                search = search + " tag:\"" + tag.toLowerCase() + "\"";
            }
        }
        if (mentions != null) {
            for (String mention : mentions) {
                mention = mention.trim();
                if (mention.startsWith(Common.ACCOUNT_URN_PREFIX)) {
                    int index = mention.indexOf(Common.ACCOUNT_URN_FEED_PREFIX);
                    if (index != -1) {
                        
                        String id = mention.substring(index
                                + Common.ACCOUNT_URN_FEED_PREFIX.length());
                        search = search + " tag:\"" + id + "\"";
                        
                        mention = mention.substring(0, index);
                    }
                    mention = mention.substring(Common.ACCOUNT_URN_PREFIX
                            .length());
                }
                if (mention.startsWith(Common.FEED_URN_PREFIX)) {
                    mention = mention
                            .substring(Common.FEED_URN_PREFIX.length());
                }
                if (mention.startsWith(Common.ENTRY_URN_PREFIX)) {
                    mention = mention.substring(Common.ENTRY_URN_PREFIX
                            .length());
                }
                
                search = search + " tag:\"" + mention + "\"";
            }
        }
        if (feedId != null) {
            search = "feed:\"" + feedId + "\"" + search;
        }
        if (search.trim().length() == 0) {
            log.trace("No search parameters: " + search);
            search = "*"; 
        }
        StandardQueryParser parser = new StandardQueryParser();
        parser.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
        try {
            return parser.parse(search, "text");
        } catch (ParseException se) {
            log.error("Could not parse query: " + search);
            throw se;
        }
    }

    
    public String readFeed(String feedId) throws FileNotFoundException,
            IOException {
        return getStorage(feedId).readFeed(feedId);
    }

    
    public void updateFeed(String feedId, Date lastUpdated, String content)
            throws IOException {
        try {
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            getStorage(feedId).updateFeed(feedId, lastUpdated, content);
            
            

        } catch (Throwable t) {
            log.error(
                    "Error from update feed: " + feedId + " : " + lastUpdated,
                    t);
            throw new IOException("Could not parse input for: " + feedId
                    + " : " + t.getMessage());
        }
    }

    
    public String readEntry(String feedId, long entryId)
            throws FileNotFoundException, IOException {
        return getStorage(feedId).readEntry(feedId, entryId);
    }

    
    public void updateEntry(String feedId, long entryId, Date publishDate,
            String content) throws IOException {
        try {
            Entry entry = (Entry) abdera.getParser()
                    .parse(new StringReader(content)).getRoot();

            
            
            Set<String> tags = new HashSet<String>();

            
            String verb = null; 
            Element verbElement = entry.getExtension(new QName(
                    "http://activitystrea.ms/spec/1.0/", "verb", "activity"));
            if (verbElement != null) {
                if (verbElement.getText() != null) {
                    verb = verbElement.getText().trim().toLowerCase();
                    while (verb.length() > 0
                            && (verb.charAt(0) == '#' || verb.charAt(0) == '@')) {
                        
                        verb = verb.substring(1);
                    }
                }
            }
            if (verb == null || verb.length() == 0) {
                verb = "post"; 
            }
            tags.add(verb);

            
            List<Category> categories = entry.getCategories();
            if (categories != null) {
                for (Category e : categories) {
                    IRI scheme = e.getScheme();
                    if (scheme != null
                            && (Common.TAG_URN.equals(scheme.toString()) || Common.TAG_URN_LEGACY
                                    .equals(scheme.toString()))) {
                        if (e.getTerm() != null) {
                            tags.add('#' + e.getTerm().trim().toLowerCase());
                        }
                    } else if (scheme != null
                            && (Common.MENTION_URN.equals(scheme.toString()) || Common.MENTION_URN_LEGACY
                                    .equals(scheme.toString()))) {
                        String mention = e.getTerm();
                        if (mention != null) {
                            mention = mention.trim();
                            if (mention.startsWith(Common.ACCOUNT_URN_PREFIX)) {
                                int index = mention
                                        .indexOf(Common.ACCOUNT_URN_FEED_PREFIX);
                                if (index != -1) {
                                    
                                    String id = mention.substring(index
                                            + Common.ACCOUNT_URN_FEED_PREFIX
                                                    .length());
                                    tags.add('@' + id);
                                    
                                    mention = mention.substring(0, index);
                                }
                                mention = mention
                                        .substring(Common.ACCOUNT_URN_PREFIX
                                                .length());
                            }
                            if (mention.startsWith(Common.FEED_URN_PREFIX)) {
                                mention = mention
                                        .substring(Common.FEED_URN_PREFIX
                                                .length());
                            }
                            if (mention.startsWith(Common.ENTRY_URN_PREFIX)) {
                                mention = mention
                                        .substring(Common.ENTRY_URN_PREFIX
                                                .length());
                            }
                            tags.add('@' + mention);
                        }
                    }
                }
            }

            
            List<String> converted = new LinkedList<String>();
            for (String tag : tags) {
                converted.add(tag);
            }

            
            Document document = new Document();
            StringBuffer text = new StringBuffer();
            document.add(new StringField("entry", getEntryKeyString(feedId,
                    entryId), Field.Store.YES));
            text.append(entryId).append(' ');
            document.add(new StringField("feed", feedId, Field.Store.NO));
            text.append(feedId).append(' ');
            document.add(new StringField("verb", verb, Field.Store.NO));
            text.append(verb).append(' ');
            document.add(new LongField("updated", entryId, Field.Store.NO));
            text.append(verb).append(' ');

            if (entry.getTitle() != null) {
                String title = entry.getTitle().toLowerCase();
                document.add(new TextField("title", title, Field.Store.NO));
                text.append(title).append(' ');
            }
            if (entry.getSummary() != null) {
                String summary = extractTextFromHtml(entry.getSummary())
                        .toLowerCase();
                
                document.add(new TextField("summary", summary, Field.Store.NO));
                text.append(summary).append(' ');
            }
            tags.remove(verb); 
            for (String tag : tags) {
                tag = tag.substring(1); 
                document.add(new StringField("tag", tag, Field.Store.NO));
                text.append(tag).append(' ');
            }
            document.add(new TextField("text", text.toString(), Field.Store.NO));

            
            getStorage(feedId).updateEntry(feedId, entryId, publishDate,
                    content);
            writer.updateDocument(
                    new Term("entry", getEntryKeyString(feedId, entryId)),
                    document);
            writer.commit();
            refreshReader();
        } catch (Throwable t) {
            log.error("Error from update entry: " + feedId + " : " + entryId, t);
            throw new IOException("Could not parse input for: "
                    + getEntryKeyString(feedId, entryId) + " : "
                    + t.getMessage());
        }
    }

    
    private String extractTextFromHtml(String html) {
        Tidy tidy = new Tidy();
        tidy.setQuiet(true);
        tidy.setShowWarnings(false);
        org.w3c.dom.Document root = tidy.parseDOM(new StringReader(html), null);
        return getText(root.getDocumentElement());
    }

        // TODO


    
    public void deleteEntry(String feedId, long entryId)
            throws FileNotFoundException, IOException {
        try {
            writer.deleteDocuments(new Term("entry", getEntryKeyString(feedId,
                    entryId)));
            writer.commit();
            refreshReader();
        } catch (Throwable t) {
            log.error("Unexpected error from delete entry: " + feedId + " : "
                    + entryId, t);
            throw new IOException("Unexpected error while deleting: "
                    + getEntryKeyString(feedId, entryId) + " : "
                    + t.getMessage());
        }
        getStorage(feedId).deleteEntry(feedId, entryId);
    }

    private static final String getEntryKeyString(String feedId, long entityId) {
        return feedId + '-' + Long.toHexString(entityId);
    }

    
    public String readFeedEntryResourceType(String feedId, long entryId,
            String resourceId) throws FileNotFoundException, IOException {
        return getStorage(feedId).readFeedEntryResourceType(feedId, entryId,
                resourceId);
    }

    
    public InputStream readFeedEntryResource(String feedId, long entryId,
            String resourceId) throws FileNotFoundException, IOException {
        return getStorage(feedId).readFeedEntryResource(feedId, entryId,
                resourceId);
    }

    
    public void updateFeedEntryResource(String feedId, long entryId,
            String resourceId, String mimeType, Date publishDate, byte[] data)
            throws IOException {
        getStorage(feedId).updateFeedEntryResource(feedId, entryId, resourceId,
                mimeType, publishDate, data);
    }

    
    public void deleteFeedEntryResource(String feedId, long entryId,
            String resourceId) throws IOException {
        getStorage(feedId).deleteFeedEntryResource(feedId, entryId, resourceId);
    }

    private final static org.slf4j.Logger log = org.slf4j.LoggerFactory
            .getLogger(Client.class);

    private static class CountCollector extends Collector {
        int count;

        @Override
        public void setScorer(Scorer scorer) throws IOException {
            
        }

        @Override
        public void collect(int doc) throws IOException {
            count++;
        }

        @Override
        public void setNextReader(AtomicReaderContext context)
                throws IOException {
            
        }

        @Override
        public boolean acceptsDocsOutOfOrder() {
            return true;
        }

        public int getCount() {
            return count;
        }

    }

}
