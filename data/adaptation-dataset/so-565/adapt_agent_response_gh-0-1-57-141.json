{
  "code": "static void toGenericSignature(final StringBuilder sb, final Type type)\n{\n    // Reference: StackOverflow discussion on converting java.lang.reflect.Type to a JVM generic signature\n    if (type instanceof GenericArrayType)\n    {\n        sb.append('[');\n        toGenericSignature(sb, ((GenericArrayType) type).getGenericComponentType());\n    }\n    else if (type instanceof ParameterizedType)\n    {\n        final ParameterizedType pt = (ParameterizedType) type;\n        sb.append('L');\n        sb.append(((Class) pt.getRawType()).getName().replace('.', '/'));\n        sb.append('<');\n        for (Type p : pt.getActualTypeArguments())\n        {\n            toGenericSignature(sb, p);\n        }\n        sb.append(\">;\");\n    }\n    else if (type instanceof Class)\n    {\n        final Class clazz = (Class) type;\n        if (!clazz.isPrimitive() && !clazz.isArray())\n        {\n            sb.append('L');\n            sb.append(clazz.getName().replace('.', '/'));\n            sb.append(';');\n        }\n        else\n        {\n            sb.append(clazz.getName().replace('.', '/'));\n        }\n    }\n    else if (type instanceof WildcardType)\n    {\n        final WildcardType wc = (WildcardType) type;\n        final Type[] lowerBounds = wc.getLowerBounds();\n        final Type[] upperBounds = wc.getUpperBounds();\n        final boolean hasLower = lowerBounds != null && lowerBounds.length > 0;\n        final boolean hasUpper = upperBounds != null && upperBounds.length > 0;\n\n        if (hasUpper && hasLower && Object.class.equals(lowerBounds[0]) && Object.class.equals(upperBounds[0]))\n        {\n            sb.append('*');\n        }\n        else if (hasLower)\n        {\n            sb.append('-');\n            for (Type b : lowerBounds)\n            {\n                toGenericSignature(sb, b);\n            }\n        }\n        else if (hasUpper)\n        {\n            if (upperBounds.length == 1 && Object.class.equals(upperBounds[0]))\n            {\n                sb.append('*');\n            }\n            else\n            {\n                sb.append('+');\n                for (Type b : upperBounds)\n                {\n                    toGenericSignature(sb, b);\n                }\n            }\n        }\n        else\n        {\n            sb.append('*');\n        }\n    }\n    else if (type instanceof TypeVariable)\n    {\n        // Alternative (not used here) would be to emit the type variable directly: \"T\" + name + \";\".\n        // Current behavior intentionally substitutes the type variable with its first bound.\n        toGenericSignature(sb, ((TypeVariable) type).getBounds()[0]);\n    }\n    else\n    {\n        throw new IllegalArgumentException(\"Invalid type: \" + type);\n    }\n}",
  "explanation": "code_hardening: none\nresolve_compilation_errors: none\nexception_handling: none\nlogic_customization: none; the logic is identical to the original snippet, including substituting a TypeVariable with its first bound\nrefactoring: none; only minor whitespace and bracing consistency adjustments were applied\nmisc: added a reference comment indicating the StackOverflow origin and clarified the TypeVariable comment to mention the alternative Tname; approach while keeping existing behavior"
}