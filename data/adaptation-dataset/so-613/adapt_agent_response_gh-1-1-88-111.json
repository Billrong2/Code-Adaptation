{
  "code": "@Override\nprotected void onLayout(boolean changed, int l, int t, int r, int b) {\n  // Contract: children have already been measured and row breaks computed in onMeasure.\n  final List<RowMeasurement> rows = currentRows;\n  if (rows == null || rows.isEmpty()) {\n    return;\n  }\n\n  final List<View> children = getLayoutChildren();\n  if (children == null || children.isEmpty()) {\n    return;\n  }\n\n  final int paddingLeft = getPaddingLeft();\n  final int paddingRight = getPaddingRight();\n  final int paddingTop = getPaddingTop();\n\n  final int measuredWidth = getMeasuredWidth();\n  final int rightBoundary = Math.max(paddingLeft, measuredWidth - paddingRight);\n\n  final boolean isRtl = android.os.Build.VERSION.SDK_INT >= 17\n      && getLayoutDirection() == View.LAYOUT_DIRECTION_RTL;\n\n  int x = isRtl ? rightBoundary : paddingLeft;\n  int y = paddingTop;\n\n  int rowIndex = 0;\n  RowMeasurement currentRow = rows.get(rowIndex);\n  int childIndex = 0;\n\n  while (childIndex < children.size() && rowIndex < rows.size()) {\n    final View child = children.get(childIndex);\n    if (child == null) {\n      childIndex++;\n      continue;\n    }\n\n    final int childWidth = child.getMeasuredWidth();\n    final int childHeight = child.getMeasuredHeight();\n\n    // Check if the child fits in the current row; if not, wrap to next row.\n    final boolean exceeds;\n    if (isRtl) {\n      final int nextX = x - (x == rightBoundary ? childWidth : (horizontalSpacing + childWidth));\n      exceeds = nextX < paddingLeft;\n    } else {\n      final int nextX = x + (x == paddingLeft ? childWidth : (horizontalSpacing + childWidth));\n      exceeds = nextX > rightBoundary;\n    }\n\n    if (exceeds && rowIndex < rows.size() - 1) {\n      // Move to next row.\n      y += currentRow.getHeight() + verticalSpacing;\n      rowIndex++;\n      currentRow = rows.get(rowIndex);\n      x = isRtl ? rightBoundary : paddingLeft;\n      continue;\n    }\n\n    // Vertically center the child within the row.\n    final int childTop = y + Math.max(0, (currentRow.getHeight() - childHeight) / 2);\n\n    if (isRtl) {\n      final int childRight = (x == rightBoundary) ? x : x - horizontalSpacing;\n      final int childLeft = childRight - childWidth;\n      child.layout(childLeft, childTop, childRight, childTop + childHeight);\n      x = childLeft;\n    } else {\n      final int childLeft = (x == paddingLeft) ? x : x + horizontalSpacing;\n      final int childRight = childLeft + childWidth;\n      child.layout(childLeft, childTop, childRight, childTop + childHeight);\n      x = childRight;\n    }\n\n    childIndex++;\n  }\n}",
  "explanation": "code_hardening: Added null/empty guards for currentRows and getLayoutChildren(), guarded rightBoundary against negative values, and skipped null child views during layout.\nresolve_compilation_errors: Used the existing onLayout override signature, relied only on fields and methods present in the class (currentRows, horizontalSpacing, verticalSpacing, getLayoutChildren, padding accessors), and referenced View.LAYOUT_DIRECTION_RTL via fully qualified SDK checks without new imports.\nexception_handling: none.\nlogic_customization: Implemented layout (not measurement) using precomputed currentRows; initialized x/y from padding; defined the wrap boundary as measured width minus right padding; wrapped to the next row when the next child would exceed the boundary; vertically centered children within each row using RowMeasurement height; applied horizontalSpacing and verticalSpacing; and added basic RTL support.\nrefactoring: Renamed layout-specific locals for clarity (rightBoundary, rowIndex, childIndex), extracted padding values into finals, and kept row iteration explicit and readable within the method.\nmisc: Added brief comments documenting the onMeasure/onLayout contract and formatted code to match Android style. No new custom API calls were introduced."
}