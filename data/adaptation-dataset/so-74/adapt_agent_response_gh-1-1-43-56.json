{
  "code": "@Override\npublic Map<String, List<String>> get(final URI uri, final Map<String, List<String>> requestHeaders) throws IOException {\n    if (uri == null) {\n        throw new IOException(\"URI must not be null\");\n    }\n    final String url = uri.toString();\n    String cookie = null;\n    try {\n        cookie = webkitCookieManager.getCookie(url);\n    } catch (RuntimeException e) {\n        // propagate as IOException to match CookieHandler contract\n        throw new IOException(\"Failed to get cookies for URI: \" + url, e);\n    }\n    if (cookie == null || cookie.length() == 0) {\n        return java.util.Collections.emptyMap();\n    }\n    final Map<String, List<String>> headers = new HashMap<String, List<String>>(1);\n    headers.put(\"Cookie\", Arrays.asList(cookie));\n    return headers;\n}",
  "explanation": "code_hardening: Validated that the URI is non-null and explicitly throw IOException; safely return an immutable empty map when no cookies exist; guarded against null/empty cookie strings.\nresolve_compilation_errors: Changed the method signature to override CookieHandler.get(...) returning Map<String, List<String>>; ignored the requestHeaders parameter; used existing project types (HashMap, Arrays) and fully qualified Collections where needed.\nexception_handling: Converted potential runtime exceptions from CookieManager access into IOException to align with the declared throws and handler expectations.\nlogic_customization: Replaced response-header scanning and setCookie calls with querying android.webkit.CookieManager.getCookie(String) for the URI and returning it under the \"Cookie\" request header when present; ignored incoming request headers.\nrefactoring: Simplified control flow, removed obsolete response-handling logic, and used clearer variable naming aligned with request-cookie supplying behavior.\nmisc: Added @Override annotation consistency and minimal comments; new custom API used: android.webkit.CookieManager#getCookie(String)."}