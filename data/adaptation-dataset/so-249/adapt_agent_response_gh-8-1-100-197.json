{
  "code": "private void runScript(final Connection connection, final Reader reader) throws IOException, SQLException {\n    final String COMMENT_PREFIX = \"--\";\n    LineNumberReader lineReader = null;\n    Statement stmt = null;\n    ResultSet rs = null;\n    boolean hadError = false;\n    try {\n        if (reader == null) {\n            return;\n        }\n        lineReader = (reader instanceof LineNumberReader)\n                ? (LineNumberReader) reader\n                : new LineNumberReader(reader);\n        final String delimiter = getDelimiter();\n        final StringBuilder command = new StringBuilder();\n        String line;\n        while ((line = lineReader.readLine()) != null) {\n            final String trimmed = line.trim();\n            if (trimmed.length() == 0 || trimmed.startsWith(COMMENT_PREFIX)) {\n                continue;\n            }\n            boolean endOfCommand = false;\n            String workLine = line;\n            if (fullLineDelimiter) {\n                if (trimmed.equals(delimiter)) {\n                    endOfCommand = true;\n                }\n            } else {\n                if (trimmed.endsWith(delimiter)) {\n                    endOfCommand = true;\n                    workLine = line.substring(0, line.lastIndexOf(delimiter));\n                }\n            }\n            if (!endOfCommand) {\n                command.append(workLine).append('\\n');\n                continue;\n            }\n            command.append(workLine);\n            final String sql = command.toString().trim();\n            command.setLength(0);\n            if (sql.length() == 0) {\n                continue;\n            }\n            try {\n                println(sql);\n                stmt = connection.createStatement();\n                final boolean hasResultSet = stmt.execute(sql);\n                if (hasResultSet) {\n                    rs = stmt.getResultSet();\n                    if (rs != null) {\n                        final ResultSetMetaData md = rs.getMetaData();\n                        final int cols = md.getColumnCount();\n                        for (int i = 1; i <= cols; i++) {\n                            print(md.getColumnLabel(i));\n                            if (i < cols) {\n                                print(\"\\t\");\n                            }\n                        }\n                        println(\"\");\n                        while (rs.next()) {\n                            for (int i = 1; i <= cols; i++) {\n                                print(rs.getString(i));\n                                if (i < cols) {\n                                    print(\"\\t\");\n                                }\n                            }\n                            println(\"\");\n                        }\n                    }\n                }\n                if (autoCommit && !connection.getAutoCommit()) {\n                    connection.commit();\n                }\n            } catch (SQLException e) {\n                hadError = true;\n                printlnError(\"Error executing: \" + sql);\n                if (stopOnError) {\n                    throw e;\n                }\n            } finally {\n                if (rs != null) {\n                    try { rs.close(); } catch (Exception ignore) { }\n                    rs = null;\n                }\n                if (stmt != null) {\n                    try { stmt.close(); } catch (Exception ignore) { }\n                    stmt = null;\n                }\n                Thread.yield();\n            }\n        }\n        if (!autoCommit) {\n            connection.commit();\n        }\n    } finally {\n        if (!autoCommit) {\n            try { connection.rollback(); } catch (Exception ignore) { }\n        }\n        flush();\n    }\n}",
  "explanation": "code_hardening: Buffered the Reader with LineNumberReader, added null checks, ensured Statement and ResultSet are closed in finally while ignoring close exceptions, flushed writers in finally, added final modifiers, and yielded the thread between statement executions.\nresolve_compilation_errors: Changed the signature to private void runScript(Connection, Reader), removed recursive calls and auto-commit state management, declared required locals (LineNumberReader, StringBuilder, Statement, ResultSet), and used existing helpers getDelimiter, print/println/printlnError, and flush.\nexception_handling: Removed generic exception wrapping, explicitly allowed IOException and SQLException to propagate, implemented stopOnError behavior to either rethrow SQLException or log and continue, and ensured rollback attempts occur in finally.\nlogic_customization: Implemented full SQL script execution by reading line-by-line, skipping '--' comments, supporting full-line vs end-of-line delimiters, executing each statement via JDBC Statement, printing commands and ResultSet column labels and rows, handling commit-after-each vs commit-at-end based on autoCommit and connection state, and avoiding restoration of original auto-commit.\nrefactoring: Renamed the method to reflect the new API with explicit Connection parameter, simplified control flow, replaced magic strings with a local constant, and structured execution/cleanup clearly within the function.\nmisc: Updated behavior via inline comments/logging consistent with existing helpers; no new custom API calls were introduced."
}