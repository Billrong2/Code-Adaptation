{
  "code": "    /**\n     * Decode an NV21 (YUV420) byte array into an RGBA int array (ARGB_8888).\n     * <p>\n     * This is a pure utility method without any rendering side effects.\n     * The conversion logic preserves the original StackOverflow algorithm and\n     * returns one packed int per pixel with alpha set to 0xff.\n     *\n     * @param nv21Data the input image data in NV21 format\n     * @param width    image width in pixels (must be > 0)\n     * @param height   image height in pixels (must be > 0)\n     * @return an int array of length width*height containing RGBA pixels\n     * @throws IllegalArgumentException if input data or dimensions are invalid\n     */\n    private int[] decodeYuvToRgb(final byte[] nv21Data, final int width, final int height) {\n        if (nv21Data == null) {\n            throw new IllegalArgumentException(\"nv21Data must not be null\");\n        }\n        if (width <= 0 || height <= 0) {\n            throw new IllegalArgumentException(\"width and height must be > 0\");\n        }\n\n        final int frameSize = width * height;\n        // NV21 requires width*height Y bytes + width*height/2 interleaved VU bytes\n        final int requiredLength = frameSize + (frameSize / 2);\n        if (nv21Data.length < requiredLength) {\n            throw new IllegalArgumentException(\"nv21Data is too small for the given width/height\");\n        }\n\n        final int[] rgba = new int[frameSize];\n\n        for (int i = 0; i < height; i++) {\n            final int yRowOffset = i * width;\n            final int uvRowOffset = frameSize + (i >> 1) * width;\n            for (int j = 0; j < width; j++) {\n                final int yIndex = yRowOffset + j;\n                final int uvIndex = uvRowOffset + (j & ~1);\n\n                // Defensive clamping of indices\n                final int safeYIndex = yIndex < nv21Data.length ? yIndex : (nv21Data.length - 1);\n                final int safeUvIndex = uvIndex + 1 < nv21Data.length ? uvIndex : (nv21Data.length - 2);\n\n                int y = nv21Data[safeYIndex] & 0xFF;\n                int u = nv21Data[safeUvIndex] & 0xFF;\n                int v = nv21Data[safeUvIndex + 1] & 0xFF;\n\n                y = y < 16 ? 16 : y;\n\n                int r = Math.round(1.164f * (y - 16) + 1.596f * (v - 128));\n                int g = Math.round(1.164f * (y - 16) - 0.813f * (v - 128) - 0.391f * (u - 128));\n                int b = Math.round(1.164f * (y - 16) + 2.018f * (u - 128));\n\n                r = r < 0 ? 0 : (r > 255 ? 255 : r);\n                g = g < 0 ? 0 : (g > 255 ? 255 : g);\n                b = b < 0 ? 0 : (b > 255 ? 255 : b);\n\n                // Preserve original channel packing and alpha\n                rgba[yIndex] = 0xff000000 | (b << 16) | (g << 8) | r;\n            }\n        }\n\n        return rgba;\n    }",
  "explanation": "code_hardening: Added null checks, width/height validation, NV21 length verification, final parameters/locals where applicable, and defensive index clamping to avoid out-of-bounds access.\nresolve_compilation_errors: Removed all Android UI and camera dependencies by implementing a standalone private helper returning int[]; kept the method name decodeYuvToRgb to match existing callers in the class.\nexception_handling: No try/catch blocks were added; the method fails fast with IllegalArgumentException for invalid inputs, as documented.\nlogic_customization: Preserved the NV21 to RGBA conversion algorithm and pixel packing exactly, returning the computed int[] instead of performing any rendering or bitmap operations.\nrefactoring: Renamed the byte-array parameter to nv21Data for clarity, added concise method-level documentation, and structured the loop with clearer offsets while keeping logic intact.\nmisc: Reformatted code for readability and removed obsolete rendering-related concerns; no new custom API calls were introduced (none)."
}