{
  "code": "public static String reshape_browser(String Str) {\n        if (Str == null || Str.length() == 0) {\n            return Str;\n        }\n\n        String Temp = \" \" + Str + \" \";\n        char pre, at, post;\n        StringBuilder reshapedString = new StringBuilder(Str.length());\n        int i = 0;\n        int len = Str.length();\n\n        char post_post;\n        char pre_pre = ' ';\n        boolean pre_can_connect = false;\n\n        while (i < len) {\n            pre = Temp.charAt(i);\n            at = Temp.charAt(i + 1);\n            post = Temp.charAt(i + 2);\n\n            // Special-case Arabic comma U+060C\n            if (at == '\\u060C') {\n                reshapedString.append(',');\n                pre_can_connect = false;\n                i++;\n                continue;\n            }\n\n            int which_case = getCase(at);\n            int what_case_post = getCase(post);\n            int what_case_pre = getCase(pre);\n            int what_case_post_post;\n\n            int pre_step = pre_can_connect ? 1 : 0;\n\n            if (what_case_pre == TASHKEEL) {\n                pre = pre_pre;\n                what_case_pre = getCase(pre);\n            }\n            if ((what_case_pre & LEFT_CHAR_MASK) == LEFT_CHAR_MASK) {\n                pre_step = 1;\n            }\n\n            switch (which_case & 0x000F) {\n\n                case NOTUSED_CHAR:\n                case NOTARABIC_CHAR:\n                    reshapedString.append(at);\n                    pre_can_connect = false;\n                    i++;\n                    continue;\n\n                case NORIGHT_NOLEFT_CHAR:\n                    reshapedString.append(getShape(at, 0));\n                    pre_can_connect = false;\n                    i++;\n                    continue;\n\n                case TATWEEL_CHAR:\n                    reshapedString.append(getShape(at, 0));\n                    pre_can_connect = false;\n                    i++;\n                    continue;\n\n                case RIGHT_LEFT_CHAR_LAM:\n                    // lam + alef ligature\n                    if ((what_case_post & 0x000F) == RIGHT_NOLEFT_CHAR_ALEF) {\n                        reshapedString.append(getShape(post, pre_step + 2));\n                        pre_can_connect = false;\n                        i += 2;\n                        continue;\n                    } else if (what_case_post == TASHKEEL) {\n                        // look ahead safely to next non-diacritic\n                        if (i + 3 < Temp.length()) {\n                            post_post = Temp.charAt(i + 3);\n                            what_case_post_post = getCase(post_post);\n                            if ((what_case_post_post & RIGHT_NOLEFT_CHAR_MASK) == RIGHT_NOLEFT_CHAR_MASK) {\n                                reshapedString.append(getShape(at, 2 + pre_step));\n                                pre_can_connect = true;\n                            } else {\n                                reshapedString.append(getShape(at, pre_step));\n                                pre_can_connect = false;\n                            }\n                        } else {\n                            reshapedString.append(getShape(at, pre_step));\n                            pre_can_connect = false;\n                        }\n                        i++;\n                        continue;\n                    } else if ((what_case_post & RIGHT_NOLEFT_CHAR_MASK) == RIGHT_NOLEFT_CHAR_MASK) {\n                        reshapedString.append(getShape(at, 2 + pre_step));\n                        pre_can_connect = true;\n                        i++;\n                        continue;\n                    } else {\n                        reshapedString.append(getShape(at, pre_step));\n                        pre_can_connect = false;\n                        i++;\n                        continue;\n                    }\n\n                case RIGHT_LEFT_CHAR:\n                    if ((what_case_post & RIGHT_NOLEFT_CHAR_MASK) == RIGHT_NOLEFT_CHAR_MASK) {\n                        reshapedString.append(getShape(at, 2 + pre_step));\n                        pre_can_connect = true;\n                        i++;\n                        continue;\n                    } else if (what_case_post == TASHKEEL) {\n                        if (i + 3 < Temp.length()) {\n                            post_post = Temp.charAt(i + 3);\n                            what_case_post_post = getCase(post_post);\n                            if ((what_case_post_post & RIGHT_NOLEFT_CHAR_MASK) == RIGHT_NOLEFT_CHAR_MASK) {\n                                reshapedString.append(getShape(at, 2 + pre_step));\n                                pre_can_connect = true;\n                            } else {\n                                reshapedString.append(getShape(at, pre_step));\n                                pre_can_connect = false;\n                            }\n                        } else {\n                            reshapedString.append(getShape(at, pre_step));\n                            pre_can_connect = false;\n                        }\n                        i++;\n                        continue;\n                    } else {\n                        reshapedString.append(getShape(at, pre_step));\n                        pre_can_connect = false;\n                        i++;\n                        continue;\n                    }\n\n                case RIGHT_NOLEFT_CHAR_ALEF:\n                case RIGHT_NOLEFT_CHAR:\n                    reshapedString.append(getShape(at, pre_step));\n                    pre_can_connect = false;\n                    i++;\n                    continue;\n\n                case TASHKEEL:\n                case TANWEEN:\n                    reshapedString.append(getShape(at, 0));\n                    pre_pre = pre;\n                    // connectivity unchanged\n                    i++;\n                    continue;\n\n                default:\n                    reshapedString.append(getShape(at, 0));\n                    pre_can_connect = false;\n                    i++;\n            }\n        }\n\n        return reshapedString.toString();\n    }",
  "explanation": "code_hardening: Added null/empty input checks, initialized and explicitly reset the pre_can_connect state in all early-continue branches, and added bounds checks around lookahead accesses (i+3) in lam and right-left tashkeel handling to avoid index errors.\nresolve_compilation_errors: Renamed the API to reshape_browser, declared and initialized the new boolean pre_can_connect state, and reused existing connectivity masks and helpers (getCase, getShape) without introducing undefined symbols.\nexception_handling: none.\nlogic_customization: Implemented special-case handling for the Arabic comma (U+060C) to emit an ASCII comma, reset connectivity, and skip shaping. Introduced and integrated pre_can_connect into shaping decisions instead of relying solely on pre_step, resetting it on non-Arabic/unused characters, NORIGHT_NOLEFT_CHAR, TATWEEL_CHAR, and after lamâ€“alef ligature consumption, and setting it when right-joining logic applies. Separated NORIGHT_NOLEFT_CHAR and TATWEEL_CHAR so tatweel explicitly clears connectivity. Adjusted lam + tashkeel lookahead to inspect the correct subsequent index safely and update connectivity accordingly while preserving shaping outcomes.\nrefactoring: Renamed the method to reflect the new API, clarified connectivity intent via the pre_can_connect variable, and minimized magic behavior changes by keeping existing shape selection logic intact.\nmisc: none."
}