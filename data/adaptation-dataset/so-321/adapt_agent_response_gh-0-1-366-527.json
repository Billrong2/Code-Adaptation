{
  "code": "public static String reshape_reverse(String Str) {\n        if (Str == null || Str.length() == 0) {\n            return \"\";\n        }\n\n        // Pad with three trailing spaces to allow i+3 lookups in reverse context\n        String Temp = \" \" + Str + \"   \";\n        StringBuilder reshapedString = new StringBuilder();\n        int len = Str.length();\n        int i = 0;\n\n        while (i < len) {\n            // Reverse neighbor interpretation:\n            // post = Temp[i], at = Temp[i+1], pre = Temp[i+2]\n            char post = (i < Temp.length()) ? Temp.charAt(i) : ' ';\n            char at = (i + 1 < Temp.length()) ? Temp.charAt(i + 1) : ' ';\n            char pre = (i + 2 < Temp.length()) ? Temp.charAt(i + 2) : ' ';\n\n            int which_case = getCase(at);\n            int what_case_pre = getCase(pre);\n            int what_case_post = getCase(post);\n\n            // Compute pre_step based on reversed pre\n            int pre_step = 0;\n            if ((what_case_pre & LEFT_CHAR_MASK) == LEFT_CHAR_MASK) {\n                pre_step = 1;\n            }\n\n            switch (which_case & 0x000F) {\n\n                case NOTUSED_CHAR:\n                case NOTARABIC_CHAR:\n                    reshapedString.append(at);\n                    i++;\n                    continue;\n\n                case NORIGHT_NOLEFT_CHAR:\n                case TATWEEL_CHAR:\n                    reshapedString.append(getShape(at, 0));\n                    i++;\n                    continue;\n\n                case RIGHT_LEFT_CHAR:\n                case RIGHT_LEFT_CHAR_LAM:\n                    // Lam is treated as a general RIGHT_LEFT_CHAR here\n                    if ((what_case_post & RIGHT_NOLEFT_CHAR_MASK) == RIGHT_NOLEFT_CHAR_MASK) {\n                        reshapedString.append(getShape(at, 2 + pre_step));\n                        i++;\n                        continue;\n                    } else if (what_case_post == TANWEEN) {\n                        reshapedString.append(getShape(at, pre_step));\n                        i++;\n                        continue;\n                    } else if (what_case_post == TASHKEEL) {\n                        // Look further backward safely\n                        char post_post = (i - 1 >= 0) ? Temp.charAt(i - 1) : ' ';\n                        int what_case_post_post = getCase(post_post);\n                        if ((what_case_post_post & RIGHT_NOLEFT_CHAR_MASK) == RIGHT_NOLEFT_CHAR_MASK) {\n                            reshapedString.append(getShape(at, 2 + pre_step));\n                            i++;\n                            continue;\n                        } else {\n                            reshapedString.append(getShape(at, pre_step));\n                            i++;\n                            continue;\n                        }\n                    } else {\n                        reshapedString.append(getShape(at, pre_step));\n                        i++;\n                        continue;\n                    }\n\n                case RIGHT_NOLEFT_CHAR_ALEF:\n                    // Lam–Alef ligature detection moved here:\n                    // current is Alef, preceding (pre) is Lam\n                    if ((what_case_pre & 0x000F) == RIGHT_LEFT_CHAR_LAM) {\n                        reshapedString.append(getShape(at, pre_step + 2));\n                        i += 2;\n                        continue;\n                    } else {\n                        reshapedString.append(getShape(at, pre_step));\n                        i++;\n                        continue;\n                    }\n\n                case RIGHT_NOLEFT_CHAR:\n                    reshapedString.append(getShape(at, pre_step));\n                    i++;\n                    continue;\n\n                case TASHKEEL:\n                    reshapedString.append(getShape(at, 0));\n                    i++;\n                    continue;\n\n                case TANWEEN:\n                    reshapedString.append(getShape(at, 0));\n                    i++;\n                    continue;\n\n                default:\n                    reshapedString.append(getShape(at, 0));\n                    i++;\n            }\n        }\n\n        return reshapedString.toString();\n    }",
  "explanation": "code_hardening: Added null/empty input guards, padded the working string with three trailing spaces, and wrapped all Temp.charAt(...) accesses with bounds checks to avoid IndexOutOfBoundsException after reversing neighbor logic.\nresolve_compilation_errors: Renamed the method to reshape_reverse, removed the obsolete pre_pre state, and ensured constants such as RIGHT_LEFT_CHAR_LAM are still referenced consistently while sharing logic with RIGHT_LEFT_CHAR.\nexception_handling: none.\nlogic_customization: Reversed neighbor interpretation so at is Temp[i+1], pre is Temp[i+2], and post is Temp[i]. Updated pre_step computation accordingly. Changed TASHKEEL handling to rely on forward context via padding rather than saved state. Moved Lam–Alef ligature detection into the Alef case (RIGHT_NOLEFT_CHAR_ALEF) and advanced the index by 2 when shaping the ligature. Treated RIGHT_LEFT_CHAR_LAM the same as RIGHT_LEFT_CHAR for general joining logic.\nrefactoring: Simplified control flow by removing pre_pre and unifying Lam handling, and added comments clarifying reversed pre/post semantics.\nmisc: Reformatted and commented the method to reflect reverse shaping behavior; no new custom API calls were introduced."
}