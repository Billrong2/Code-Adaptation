{
  "code": "public static <K extends Comparable<? super K>, V> Map<K, V> sortByKey(final Map<K, V> mapToSort) {\n\tif (mapToSort == null || mapToSort.isEmpty()) {\n\t\treturn new LinkedHashMap<K, V>();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tfinal Map.Entry<K, V>[] entries = mapToSort.entrySet().toArray(new Map.Entry[mapToSort.size()]);\n\n\tArrays.sort(entries, new Comparator<Map.Entry<K, V>>() {\n\t\t@Override\n\t\tpublic int compare(final Map.Entry<K, V> e1, final Map.Entry<K, V> e2) {\n\t\t\treturn e1.getKey().compareTo(e2.getKey());\n\t\t}\n\t});\n\n\tfinal Map<K, V> sortedMap = new LinkedHashMap<K, V>(entries.length);\n\tfor (Map.Entry<K, V> entry : entries) {\n\t\tsortedMap.put(entry.getKey(), entry.getValue());\n\t}\n\n\treturn sortedMap;\n}",
  "explanation": "code_hardening: Added a null and empty check for the input map and return an empty LinkedHashMap to avoid NullPointerExceptions; marked parameters and locals as final where appropriate.\nresolve_compilation_errors: Updated generics to K extends Comparable<? super K> and removed any Comparable constraint from V; aligned the method name to sortByKey as used by callers; used Arrays.sort with an explicit Comparator to match available imports.\nexception_handling: None; natural key ordering does not introduce checked exceptions.\nlogic_customization: Changed sorting from values to keys using natural ascending order; copied map entries into an array and applied Arrays.sort with a key-based comparator; preserved iteration order by collecting results into a LinkedHashMap.\nrefactoring: Renamed the method to sortByKey and adjusted the parameter name to reflect key-based sorting; simplified the comparator to directly compare keys.\nmisc: Minor formatting and a suppression for the generic array creation warning to keep the method self-contained; no new custom API calls introduced."
}