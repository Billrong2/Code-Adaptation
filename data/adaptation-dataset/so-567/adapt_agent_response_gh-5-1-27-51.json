{
  "code": "/**\n * Sorts a map according to its keys in natural ascending order.\n * The returned map preserves the sorted iteration order.\n *\n * @param <K> the key type, must be comparable\n * @param <V> the value type\n * @param map the map to sort by key\n * @return a new {@link LinkedHashMap} sorted by keys, or an empty map if input is null\n */\npublic static <K extends Comparable<? super K>, V> Map<K, V> sortByKey(final Map<K, V> map) {\n\tif (map == null) {\n\t\treturn new LinkedHashMap<K, V>();\n\t}\n\n\tfinal Map.Entry<K, V>[] entries = map.entrySet().toArray(new Map.Entry[map.size()]);\n\n\tArrays.sort(entries, new Comparator<Map.Entry<K, V>>() {\n\t\t@Override\n\t\tpublic int compare(final Map.Entry<K, V> e1, final Map.Entry<K, V> e2) {\n\t\t\treturn e1.getKey().compareTo(e2.getKey());\n\t\t}\n\t});\n\n\tfinal Map<K, V> sortedMap = new LinkedHashMap<K, V>(entries.length);\n\tfor (final Map.Entry<K, V> entry : entries) {\n\t\tsortedMap.put(entry.getKey(), entry.getValue());\n\t}\n\n\treturn sortedMap;\n}",
  "explanation": "code_hardening: Added a null check for the input map and return an empty LinkedHashMap when null; marked local variables as final to prevent reassignment.\nresolve_compilation_errors: Renamed the method to sortByKey, updated the parameter name to map, and changed the generic signature to K extends Comparable<? super K> with no Comparable constraint on V; used existing java.util.Arrays, Comparator, Map, and LinkedHashMap types to compile within the current file context.\nexception_handling: none.\nlogic_customization: Switched sorting from values to keys by comparing entry.getKey() using natural order; replaced List + Collections.sort with Map.Entry[] + Arrays.sort; rebuilt a LinkedHashMap to preserve the sorted iteration order.\nrefactoring: Updated method name, parameter name, and Javadoc to clearly reflect key-based sorting semantics.\nmisc: none."
}