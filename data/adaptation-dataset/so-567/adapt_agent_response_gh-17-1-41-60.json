{
  "code": "public static <K, V extends Comparable<? super V>> Map<K, V>\n\tsortByDescendingValue(Map<K, V> map)\n\t{\n\t\t// Sort a map according to values in descending order\n\t\tList<Map.Entry<K, V>> entries = new LinkedList<Map.Entry<K, V>>(map.entrySet());\n\t\tCollections.sort(entries, new Comparator<Map.Entry<K, V>>()\n\t\t{\n\t\t\tpublic int compare(Map.Entry<K, V> e1, Map.Entry<K, V> e2)\n\t\t\t{\n\t\t\t\t// reverse order: higher values come first\n\t\t\t\treturn e2.getValue().compareTo(e1.getValue());\n\t\t\t}\n\t\t});\n\n\t\tMap<K, V> sortedByValueDesc = new LinkedHashMap<K, V>();\n\t\tfor (Map.Entry<K, V> entry : entries)\n\t\t{\n\t\t\tsortedByValueDesc.put(entry.getKey(), entry.getValue());\n\t\t}\n\t\treturn sortedByValueDesc;\n\t}",
  "explanation": "code_hardening: none\nresolve_compilation_errors: none\nexception_handling: none\nlogic_customization: reversed the Comparator logic to compare values in descending order by swapping the comparison operands (e2.getValue().compareTo(e1.getValue())).\nrefactoring: renamed the method to sortByDescendingValue to reflect behavior; built the entry list directly from map.entrySet() using a LinkedList; renamed local variables (entries, sortedByValueDesc, e1/e2) for clarity while preserving behavior; retained LinkedHashMap as the return type to maintain sorted iteration order.\nmisc: updated the in-method comment to document descending sort semantics; no new custom API calls were introduced."
}