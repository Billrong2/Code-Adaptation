{
  "code": "private void stripUnderlines(final TextView textView) {\n        // Replace URLSpan with URLSpanNoUnderline to remove default underline styling\n        if (textView == null) {\n            return;\n        }\n        final CharSequence text = textView.getText();\n        if (text == null || !(text instanceof Spannable)) {\n            // Safe fallback: nothing to do if the text is not spannable\n            return;\n        }\n\n        final Spannable spannable = (Spannable) text;\n        final URLSpan[] spans = spannable.getSpans(0, spannable.length(), URLSpan.class);\n        for (URLSpan oldSpan : spans) {\n            final int start = spannable.getSpanStart(oldSpan);\n            final int end = spannable.getSpanEnd(oldSpan);\n            spannable.removeSpan(oldSpan);\n            final URLSpan newSpan = new URLSpanNoUnderline(oldSpan.getURL());\n            spannable.setSpan(newSpan, start, end, 0);\n        }\n        textView.setText(spannable);\n    }",
  "explanation": "code_hardening: Added null checks for the TextView and its text, verified that the text is an instance of Spannable before operating, and marked the parameter as final.\nresolve_compilation_errors: Reused existing project classes (android.text.Spannable and android.text.style.URLSpan) and the already-defined inner class URLSpanNoUnderline; no new imports or symbols were required.\nexception_handling: none.\nlogic_customization: Changed the implementation to reuse the TextViewâ€™s existing Spannable by casting instead of creating a new SpannableString, while keeping the span removal and replacement logic identical so callers (addAddress, addTelephone, addWebsite) behave consistently.\nrefactoring: Simplified variable naming (oldSpan/newSpan) for clarity and avoided reassigning span variables.\nmisc: Added a brief comment explaining why URLSpans are replaced and applied minor formatting improvements; no additional functional changes. (New custom API calls: none.)"
}