{
"code":"@Override\npublic Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {\n    // Reset renderer state to avoid stale visuals\n    if (checkBox != null) {\n        checkBox.setVisible(false);\n        checkBox.setEnabled(false);\n        checkBox.setSelected(false);\n        checkBox.setOpaque(false);\n        checkBox.setText(\"\");\n    }\n    if (altLabel != null) {\n        altLabel.setText(\"\");\n        altLabel.setVisible(true);\n        altLabel.setEnabled(true);\n    }\n\n    if (value == null || !(value instanceof DefaultMutableTreeNode)) {\n        return this;\n    }\n\n    DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;\n    Object userObject = node.getUserObject();\n    String text = userObject != null ? userObject.toString() : \"\";\n    altLabel.setText(text);\n\n    // Apply Look & Feel–aware colors based on selection state\n    java.awt.Color fg = selected ? UIManager.getColor(\"Tree.selectionForeground\") : UIManager.getColor(\"Tree.textForeground\");\n    java.awt.Color bg = selected ? UIManager.getColor(\"Tree.selectionBackground\") : UIManager.getColor(\"Tree.textBackground\");\n    if (fg != null) {\n        altLabel.setForeground(fg);\n    }\n    if (bg != null) {\n        altLabel.setBackground(bg);\n    }\n\n    // Lookup checking state directly from the map\n    TreePath tp = new TreePath(node.getPath());\n    CheckedNode cn = nodesCheckingState != null ? nodesCheckingState.get(tp) : null;\n    if (cn == null) {\n        // Node without checkbox support\n        return this;\n    }\n\n    // Per-node checkbox visibility and enablement\n    if (cn.isCheckBoxEnabled) {\n        checkBox.setVisible(true);\n        checkBox.setEnabled(true);\n        checkBox.setSelected(cn.isSelected);\n        // Partial-selection visual: use opaque to indicate mixed state\n        checkBox.setOpaque(cn.isSelected && cn.hasChildren && !cn.allChildrenSelected);\n    } else {\n        checkBox.setVisible(false);\n        checkBox.setEnabled(false);\n    }\n\n    return this;\n}",
"explanation":"code_hardening: Added null/type checks for value, user object, nodesCheckingState, and renderer subcomponents; fully reset checkbox and label state on each call; safely handle missing CheckedNode by hiding the checkbox and returning early.\nresolve_compilation_errors: Removed dependency on undefined getCheckedNode and replaced it with direct lookup in nodesCheckingState; stopped setting text on JCheckBox and used the existing JLabel (altLabel) for text; relied on existing CheckedNode fields and Swing classes with fully qualified types where needed.\nexception_handling: none.\nlogic_customization: Moved text rendering to a separate JLabel with empty text for null user objects; applied Look & Feel–aware foreground/background colors based on selection; controlled checkbox visibility/enabled state per node via isCheckBoxEnabled; when enabled, set selected state and partial-selection visual using opaque; supported nodes without checkboxes by hiding/disable checkbox and rendering label consistently.\nrefactoring: Clarified logic by separating state reset, text/label rendering, color application, and checkbox state handling into clear blocks; avoided mixed responsibilities on the checkbox.\nmisc: Minor formatting and adherence to Swing renderer best practices (stateless rendering, L&F colors). New custom API calls absent from the SO snippet: javax.swing.UIManager.getColor(String)."}