{
  "code": "private static void verify(final PublicKey key, final byte[] signature, final byte[] data)\n        throws IOException, GeneralSecurityException\n{\n    if (key == null) {\n        throw new IllegalArgumentException(\"key must not be null\");\n    }\n    if (signature == null || signature.length == 0) {\n        throw new IllegalArgumentException(\"signature must not be null or empty\");\n    }\n    if (data == null) {\n        throw new IllegalArgumentException(\"data must not be null\");\n    }\n\n    final Signature sig = Signature.getInstance(\"SHA1withRSA\");\n    sig.initVerify(key);\n\n    try (ByteArrayOutputStream collector = new ByteArrayOutputStream(data.length);\n         OutputStream checker = new SignatureOutputStream(collector, sig))\n    {\n        checker.write(data);\n    }\n\n    if (sig.verify(signature)) {\n        System.err.println(\"Signature okay\");\n    }\n    else {\n        System.err.println(\"Signature falsed!\");\n    }\n}",
  "explanation": "code_hardening: Added null/empty validation for key, signature, and data; marked parameters and locals as final; used try-with-resources to ensure streams are closed.\nresolve_compilation_errors: Used existing de.fencing_game.paul.examples.SignatureOutputStream and fully relied on java.security.Signature and java.io streams already present; no new helpers introduced.\nexception_handling: Preserved the original throws IOException and GeneralSecurityException contract; wrapped no additional exceptions beyond existing behavior.\nlogic_customization: Kept the original verification logic and algorithm (\"SHA1withRSA\") and continued to stream data through SignatureOutputStream without altering semantics.\nrefactoring: Renamed local variables to clearer names (collector, checker retained but formatted); improved spacing and brace placement while keeping structure intact.\nmisc: Updated formatting to match surrounding code style and retained System.err.println output to avoid behavioral changes; no new custom API calls introduced."
}