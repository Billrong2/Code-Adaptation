
package org.scijava.script;

import java.lang.reflect.Method;

import javax.script.Bindings;
import javax.script.Compilable;
import javax.script.CompiledScript;
import javax.script.ScriptContext;
import javax.script.ScriptEngine;
import javax.script.ScriptException;

import org.scijava.log.LogService;
import org.scijava.plugin.Parameter;
import org.scijava.prefs.PrefService;


public class DefaultScriptInterpreter implements ScriptInterpreter {

	private final ScriptLanguage language;
	private final ScriptEngine engine;
	private final History history;

	@Parameter(required = false)
	private PrefService prefs;

	@Parameter(required = false)
	private LogService log;

	private final StringBuilder buffer;
	private int pendingLineCount;
	private boolean expectingMoreInput;

	
	@Deprecated
	@SuppressWarnings("unused")
	public DefaultScriptInterpreter(final PrefService prefs,
		final ScriptService scriptService, final ScriptLanguage language)
	{
		this(language);
	}

	
	public DefaultScriptInterpreter(final ScriptLanguage language) {
		this(language, null);
	}

	
	public DefaultScriptInterpreter(final ScriptLanguage language,
		final ScriptEngine engine)
	{
		language.getContext().inject(this);
		this.language = language;
		this.engine = engine == null ? language.getScriptEngine() : engine;
		history = prefs == null ? null :
			new History(prefs, this.engine.getClass().getName());
		readHistory();
		buffer = new StringBuilder();
		reset();
	}

	

	@Override
	public synchronized void readHistory() {
		if (history == null) return;
		history.read();
	}

	@Override
	public synchronized void writeHistory() {
		if (history == null) return;
		history.write();
	}

	@Override
	public synchronized String walkHistory(final String currentCommand,
		final boolean forward)
	{
		if (history == null) return currentCommand;
		history.replace(currentCommand);
		return forward ? history.next() : history.previous();
	}

	@Override
	public Object eval(final String command) throws ScriptException {
		addToHistory(command);
		return engine.eval(command);
	}

	
	@Override
	public Object interpret(final String line) throws ScriptException {
		if (line.isEmpty()) {
			if (!shouldEvaluatePendingInput(true)) return MORE_INPUT_PENDING;
		}

		if (pendingLineCount > 0) buffer.append("\n");
		pendingLineCount++;
		buffer.append(line);
		final String command = buffer.toString();

		if (!(engine instanceof Compilable)) {
			
			
			try {
				return eval(command);
			}
			finally {
				reset();
			}
		}

		final CompiledScript cs = tryCompiling(command, 
			getPendingLineCount(), line.length());

		if (cs == null) {
			
			
			return MORE_INPUT_PENDING;
		}
		if (!shouldEvaluatePendingInput(line.isEmpty())) {
			
			return MORE_INPUT_PENDING;
		}
		
		try {
			addToHistory(command);
			return cs.eval();
		}
		finally {
			reset();
		}
	}

	@Override
	public void reset() {
		buffer.setLength(0);
		pendingLineCount = 0;
		expectingMoreInput = false;
	}

	@Override
	public ScriptLanguage getLanguage() {
		return language;
	}

	@Override
	public ScriptEngine getEngine() {
		return engine;
	}

	@Override
	public Bindings getBindings() {
		return engine.getBindings(ScriptContext.ENGINE_SCOPE);
	}

	@Override
	public boolean isReady() {
		return buffer.length() == 0;
	}

	@Override
	public boolean isExpectingMoreInput() {
		return expectingMoreInput;
	}

	

	private void addToHistory(final String command) {
		if (history != null) history.add(command);
	}

	
	private int getPendingLineCount() {
		return pendingLineCount;
	}

	
	private boolean shouldEvaluatePendingInput(final boolean lineIsEmpty) {
		if (isExpectingMoreInput()) return false;
		return getPendingLineCount() == 1 || lineIsEmpty;
	}

	// TODO


	private boolean isLastCharacter(final Integer col, final Integer line,
		final int lineCount, final int lastLineLength)
	{
		if (col == null || line == null) return false;
		final int colNo = col.intValue(), lineNo = line.intValue();
		return lineNo == lineCount && colNo == lastLineLength ||
			lineNo == lineCount + 1 && colNo == 0;
	}

	private Integer columnNumber(final ScriptException se) {
		if (se.getColumnNumber() >= 0) return se.getColumnNumber();
		return callMethod(se.getCause(), "columnNumber", Integer.class);
	}

	private Integer lineNumber(final ScriptException se) {
		if (se.getLineNumber() >= 0) return se.getLineNumber();
		return callMethod(se.getCause(), "lineNumber", Integer.class);
	}

	private static Method getMethod(final Object object,
		final String methodName)
	{
		try {
			return object.getClass().getMethod(methodName);
		}
		catch (final NoSuchMethodException e) {
			
			return null;
		}
	}

	private static <T> T callMethod(final Object object, final String methodName,
		final Class<T> cl)
	{
		try {
			final Method m = getMethod(object, methodName);
			if (m != null) {
				final Object result = m.invoke(object);
				return cl.cast(result);
			}
		}
		catch (final Exception e) {
			e.printStackTrace();
		}
		return null;
	}

}
