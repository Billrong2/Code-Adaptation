{
  "code": "public UnicodeInputStream(final InputStream inputStream, final boolean skipBom) throws NullPointerException, IOException {\n\t\tif (inputStream == null) {\n\t\t\tthrow new NullPointerException(\"invalid input stream: null is not allowed\");\n\t\t}\n\n\t\tfinal int MAX_BOM_LENGTH = 4;\n\t\tthis.in = new PushbackInputStream(inputStream, MAX_BOM_LENGTH);\n\n\t\tfinal byte[] probe = new byte[MAX_BOM_LENGTH];\n\t\tfinal int read = in.read(probe);\n\n\t\tif (read == -1) {\n\t\t\tthis.bom = BOM.NONE;\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (read) {\n\t\t\tcase 4:\n\t\t\t\tif ((probe[0] == (byte) 0xFF) && (probe[1] == (byte) 0xFE) && (probe[2] == (byte) 0x00)\n\t\t\t\t\t\t&& (probe[3] == (byte) 0x00)) {\n\t\t\t\t\tthis.bom = BOM.UTF_32_LE;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if ((probe[0] == (byte) 0x00) && (probe[1] == (byte) 0x00)\n\t\t\t\t\t\t&& (probe[2] == (byte) 0xFE) && (probe[3] == (byte) 0xFF)) {\n\t\t\t\t\tthis.bom = BOM.UTF_32_BE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 3:\n\t\t\t\tif ((probe[0] == (byte) 0xEF) && (probe[1] == (byte) 0xBB) && (probe[2] == (byte) 0xBF)) {\n\t\t\t\t\tthis.bom = BOM.UTF_8;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 2:\n\t\t\t\tif ((probe[0] == (byte) 0xFF) && (probe[1] == (byte) 0xFE)) {\n\t\t\t\t\tthis.bom = BOM.UTF_16_LE;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if ((probe[0] == (byte) 0xFE) && (probe[1] == (byte) 0xFF)) {\n\t\t\t\t\tthis.bom = BOM.UTF_16_BE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthis.bom = BOM.NONE;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (read > 0) {\n\t\t\tin.unread(probe, 0, read);\n\t\t}\n\n\t\tif (skipBom && this.bom != BOM.NONE) {\n\t\t\tfinal int toSkip = this.bom.bytes.length;\n\t\t\tlong skipped = 0;\n\t\t\twhile (skipped < toSkip) {\n\t\t\t\tfinal long s = in.skip(toSkip - skipped);\n\t\t\t\tif (s <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tskipped += s;\n\t\t\t}\n\t\t}\n\t}",
  "explanation": "code_hardening: Added null validation for the input stream, handled the case where the initial read returns -1 (empty stream), ensured the PushbackInputStream buffer size matches the maximum BOM length, and marked parameters and locals as final where applicable.\nresolve_compilation_errors: Implemented the missing constructor with signature (InputStream, boolean), initialized the existing fields 'in' and 'bom', renamed the temporary byte buffer to 'probe' to avoid shadowing the field 'bom', and used an in-method constant for maximum BOM length.\nexception_handling: Preserved existing NullPointerException and IOException behavior; ensured unread and skip logic is guarded to avoid unchecked exceptions or infinite loops.\nlogic_customization: Added the skipBom parameter; after BOM detection and pushback, advanced the stream by the detected BOM length when skipBom is true, while preserving the original BOM detection switch logic unchanged.\nrefactoring: Replaced the magic number 4 with a named constant, improved variable naming for clarity, and aligned the constructor with the renamed class UnicodeInputStream.\nmisc: Updated behavior to match documented default skipping semantics; no new custom API calls were introduced."
}