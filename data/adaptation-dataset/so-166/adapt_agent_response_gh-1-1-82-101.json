{
  "code": "public static <K, V extends java.lang.Comparable<? super V>> java.util.Map<K, V> sortByValue(final java.util.Map<K, V> map, final boolean reverse) {\n    if (map == null) {\n        throw new java.lang.NullPointerException(\"Input map must not be null\");\n    }\n\n    // Copy entries to a list for sorting\n    final java.util.List<java.util.Map.Entry<K, V>> entries =\n            new java.util.LinkedList<java.util.Map.Entry<K, V>>(map.entrySet());\n\n    // Validate values and sort with configurable order\n    java.util.Collections.sort(entries, new java.util.Comparator<java.util.Map.Entry<K, V>>() {\n        @Override\n        public int compare(java.util.Map.Entry<K, V> e1, java.util.Map.Entry<K, V> e2) {\n            if (e1.getValue() == null || e2.getValue() == null) {\n                throw new java.lang.IllegalArgumentException(\"Map values must not be null\");\n            }\n            int cmp = e1.getValue().compareTo(e2.getValue());\n            return reverse ? -cmp : cmp;\n        }\n    });\n\n    // Preserve sorted iteration order\n    final java.util.Map<K, V> result = new java.util.LinkedHashMap<K, V>(entries.size());\n    for (java.util.Map.Entry<K, V> entry : entries) {\n        result.put(entry.getKey(), entry.getValue());\n    }\n    return result;\n}",
  "explanation": "code_hardening: Added a null check for the input map and explicit validation that map values are non-null, failing fast with clear exceptions. Method parameters are final and a defensive size is used when creating the result map.\nresolve_compilation_errors: Introduced a new method signature sortByValue(Map<K,V>, boolean) using fully qualified java.util and java.lang types so it compiles without relying on imports. This aligns with the projectâ€™s existing MapUtils-style static utilities.\nexception_handling: No try/catch blocks were added per the plan; instead, invalid inputs are reported via NullPointerException and IllegalArgumentException.\nlogic_customization: Implemented comparator logic that conditionally inverts the comparison when reverse == true to produce descending order, while keeping ascending order as the default when reverse == false. Ensured the returned map is a LinkedHashMap to preserve the sorted iteration order and that all entries are retained.\nrefactoring: Clarified local variable names (entries, result) and structured the comparator inline for readability, avoiding magic behavior and making the reverse flag explicit.\nmisc: Added brief inline comments describing each major step. No new custom API calls beyond standard JDK classes were introduced (none)."
}