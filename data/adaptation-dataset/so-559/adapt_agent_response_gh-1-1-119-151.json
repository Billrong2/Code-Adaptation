{
"code":"protected String[] GetProtocolList() {\n    final String[] preferredProtocols = { \"TLSv1\", \"TLSv1.1\", \"TLSv1.2\", \"TLSv1.3\" };\n    String[] availableProtocols = null;\n\n    SSLSocket socket = null;\n    try {\n        SSLSocketFactory factory = m_ctx.getSocketFactory();\n        socket = (SSLSocket) factory.createSocket();\n\n        availableProtocols = socket.getSupportedProtocols();\n        if (availableProtocols != null) {\n            Arrays.sort(availableProtocols);\n        }\n    } catch (Exception e) {\n        // Fallback to a minimal, widely supported protocol set\n        return new String[]{ \"TLSv1\" };\n    } finally {\n        if (socket != null) {\n            try {\n                socket.close();\n            } catch (IOException ignore) {\n                // Ignore close failures so they do not mask earlier exceptions\n            }\n        }\n    }\n\n    if (availableProtocols == null) {\n        return new String[]{ \"TLSv1\" };\n    }\n\n    List<String> enabledProtocols = new ArrayList<String>();\n    for (int i = 0; i < preferredProtocols.length; i++) {\n        int idx = Arrays.binarySearch(availableProtocols, preferredProtocols[i]);\n        if (idx >= 0) {\n            enabledProtocols.add(preferredProtocols[i]);\n        }\n    }\n\n    return enabledProtocols.toArray(new String[0]);\n}",
"explanation":"code_hardening: Wrapped socket.close() in its own try/catch inside finally to ensure cleanup does not propagate or mask earlier failures, added null-safety for availableProtocols before sorting and searching, and marked key locals as final where appropriate.\nresolve_compilation_errors: Ensured all referenced types are already available in the surrounding file context and handled IOException from close internally so the method signature remains unchanged; no new imports were required.\nexception_handling: Kept the existing broad try/catch for primary socket creation logic with a safe fallback return, while isolating close-related IOException handling so it cannot override primary exceptions.\nlogic_customization: Preserved the original protocol selection logic and semantics (using getSupportedProtocols and preferred protocol ordering) with no behavioral changes beyond robustness.\nrefactoring: Renamed the temporary list variable to enabledProtocols for clarity and slightly restructured control flow for readability without changing outcomes.\nmisc: Adjusted formatting and added brief comments to document fallback behavior and the intent of ignoring close failures; no new custom API calls were introduced."}