{
  "code": "public static Document readXML(final InputStream is) throws IOException, SAXException, ParserConfigurationException {\n    if (is == null) {\n        throw new IllegalArgumentException(\"InputStream must not be null\");\n    }\n\n    final Document doc;\n    final SAXParser parser;\n\n    final SAXParserFactory factory = SAXParserFactory.newInstance();\n    // Secure XML processing to mitigate XXE\n    factory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);\n    try {\n        factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n    } catch (SAXException e) {\n        // Feature may not be supported by all parsers; rethrow to keep behavior explicit\n        throw e;\n    }\n    parser = factory.newSAXParser();\n\n    final DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);\n    final DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n    doc = docBuilder.newDocument();\n\n    final Stack<Element> elementStack = new Stack<Element>();\n    final StringBuilder textBuffer = new StringBuilder();\n\n    final DefaultHandler handler = new DefaultHandler() {\n        private Locator myLocator;\n\n        @Override\n        public void setDocumentLocator(final Locator locator) {\n            this.myLocator = locator; // Save locator for line number tracking\n        }\n\n        @Override\n        public void startElement(final String uri, final String localName, final String qName, final Attributes attributes)\n                throws SAXException {\n            addTextIfNeeded();\n            final Element el = doc.createElement(qName);\n            for (int i = 0; i < attributes.getLength(); i++) {\n                el.setAttribute(attributes.getQName(i), attributes.getValue(i));\n            }\n            if (this.myLocator != null) {\n                el.setUserData(LINE_NUMBER_KEY_NAME, String.valueOf(this.myLocator.getLineNumber()), null);\n            }\n            elementStack.push(el);\n        }\n\n        @Override\n        public void endElement(final String uri, final String localName, final String qName) throws SAXException {\n            addTextIfNeeded();\n            final Element closedEl = elementStack.pop();\n            if (elementStack.isEmpty()) {\n                doc.appendChild(closedEl);\n            } else {\n                final Element parentEl = elementStack.peek();\n                parentEl.appendChild(closedEl);\n            }\n        }\n\n        @Override\n        public void characters(final char[] ch, final int start, final int length) throws SAXException {\n            textBuffer.append(ch, start, length);\n        }\n\n        // Outputs text accumulated under the current node\n        private void addTextIfNeeded() {\n            if (textBuffer.length() > 0 && !elementStack.isEmpty()) {\n                final Element el = elementStack.peek();\n                final Node textNode = doc.createTextNode(textBuffer.toString());\n                el.appendChild(textNode);\n                textBuffer.setLength(0);\n            }\n        }\n    };\n\n    // Parsing does not take ownership of the InputStream; caller is responsible for closing it\n    parser.parse(is, handler);\n\n    return doc;\n}",
  "explanation": "code_hardening: Added a null check for the InputStream, guarded locator usage with a null check before accessing line numbers, ensured text nodes are only added when an element exists, enabled secure XML processing features on both SAXParserFactory and DocumentBuilderFactory, and made local variables (including the SAXParser) final where appropriate. Documented InputStream ownership via an inline comment rather than closing it implicitly.\nresolve_compilation_errors: Preserved and used the existing LINE_NUMBER_KEY_NAME constant from the target class, relied on already-imported DOM/SAX types, and used fully qualified javax.xml.XMLConstants where needed to avoid import assumptions. Generics remain compatible with Stack<Element> as used in the codebase.\nexception_handling: Propagated ParserConfigurationException directly in the method signature instead of wrapping it, allowed SAXException/IOException to propagate, and explicitly rethrew unsupported secure-feature exceptions to keep failure modes visible.\nlogic_customization: Kept element creation based on qName to match original behavior and project expectations; no trimming or whitespace logic changes were introduced to avoid functional differences. No new custom APIs beyond secure parser features were introduced.\nrefactoring: Renamed the DefaultHandler field from locator to myLocator and updated all references, simplified StringBuilder clearing with setLength(0), and kept the overall structure readable without altering behavior.\nmisc: Performed minor comment and formatting cleanup to align with project style and clarified security and resource-management decisions in comments. No additional logging was added."
}