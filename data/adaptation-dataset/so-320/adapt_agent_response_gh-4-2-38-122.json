{
  "code": "public static Document readXML(final InputStream is) throws IOException, SAXException\n{\n    final Document doc;\n    SAXParser parser;\n\n    try {\n        final SAXParserFactory factory = SAXParserFactory.newInstance();\n        parser = factory.newSAXParser();\n\n        final DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n        final DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n        doc = docBuilder.newDocument();\n    } catch (final ParserConfigurationException e) {\n        throw new RuntimeException(\"Can't create SAX parser / DOM builder.\", e);\n    }\n\n    final Stack<Element> elementStack = new Stack<Element>();\n    final StringBuilder textBuffer = new StringBuilder();\n\n    final DefaultHandler handler = new DefaultHandler() {\n        private Locator locator;\n\n        @Override\n        public void setDocumentLocator(final Locator locator)\n        {\n            // Save the locator, so that it can be used later for line tracking\n            // when traversing nodes.\n            this.locator = locator;\n        }\n\n        @Override\n        public void startElement(final String uri, final String localName, final String qName,\n                final Attributes attributes) throws SAXException\n        {\n            addTextIfNeeded();\n\n            final Element el = doc.createElement(qName);\n            for (int i = 0; i < attributes.getLength(); i++) {\n                el.setAttribute(attributes.getQName(i), attributes.getValue(i));\n            }\n\n            el.setUserData(LINE_NUMBER_KEY_NAME,\n                    String.valueOf(this.locator.getLineNumber()), null);\n            elementStack.push(el);\n        }\n\n        @Override\n        public void endElement(final String uri, final String localName, final String qName)\n        {\n            addTextIfNeeded();\n\n            final Element closedEl = elementStack.pop();\n            if (elementStack.isEmpty()) {\n                // Root element\n                doc.appendChild(closedEl);\n            } else {\n                final Element parentEl = elementStack.peek();\n                parentEl.appendChild(closedEl);\n            }\n        }\n\n        @Override\n        public void characters(final char[] ch, final int start, final int length)\n                throws SAXException\n        {\n            textBuffer.append(ch, start, length);\n        }\n\n        // Outputs text accumulated under the current node\n        private void addTextIfNeeded()\n        {\n            if (textBuffer.length() > 0) {\n                final Element el = elementStack.peek();\n                final Node textNode = doc.createTextNode(textBuffer.toString());\n                el.appendChild(textNode);\n                textBuffer.delete(0, textBuffer.length());\n            }\n        }\n    };\n\n    parser.parse(is, handler);\n\n    return doc;\n}",
  "explanation": "code_hardening: No behavioral changes were introduced. The InputStream is used exactly as in the original snippet, and lifecycle ownership remains with the caller, matching the existing logic.\nresolve_compilation_errors: The function is adapted to the existing PositionalXMLReader context, relying on already-present imports and the existing LINE_NUMBER_KEY_NAME constant. No additional declarations were required.\nexception_handling: The original exception-handling behavior is preserved. ParserConfigurationException is wrapped in a RuntimeException, and the method continues to declare throws IOException and SAXException without modification.\nlogic_customization: none.\nrefactoring: No refactoring or renaming was performed. Only brace placement, indentation, and line wrapping were adjusted to match the project's formatting style.\nmisc: Comments were rewrapped and aligned with the surrounding code style for readability, without changing meaning or execution flow. No new APIs were introduced."
}