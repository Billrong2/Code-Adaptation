{
  "code": "private static void createFakeSms(final android.content.Context context, final String sender, final String body) {\n    // Adapted from Stack Overflow answer on constructing fake SMS PDUs (see original SO thread).\n    // Cosmetic updates, added validation, and clearer structure; core logic unchanged.\n\n    if (context == null || sender == null || body == null) {\n        return; // hardening: avoid NPEs\n    }\n\n    // basic validation to avoid malformed PDUs\n    if (sender.length() == 0 || sender.length() > 20) {\n        return;\n    }\n\n    byte[] pdu = null;\n\n    final byte ENCODING_7BIT = 0x00;\n    final byte SMS_DELIVER = 0x04;\n\n    final byte[] serviceCenterBytes = android.telephony.PhoneNumberUtils\n            .networkPortionToCalledPartyBCD(\"0000000000\");\n    final byte[] senderBytes = android.telephony.PhoneNumberUtils\n            .networkPortionToCalledPartyBCD(sender);\n\n    final int serviceCenterLength = serviceCenterBytes.length;\n\n    final byte[] dateBytes = new byte[7];\n    final java.util.Calendar calendar = new java.util.GregorianCalendar();\n\n    dateBytes[0] = reverseByte((byte) (calendar.get(java.util.Calendar.YEAR)));\n    dateBytes[1] = reverseByte((byte) (calendar.get(java.util.Calendar.MONTH) + 1));\n    dateBytes[2] = reverseByte((byte) (calendar.get(java.util.Calendar.DAY_OF_MONTH)));\n    dateBytes[3] = reverseByte((byte) (calendar.get(java.util.Calendar.HOUR_OF_DAY)));\n    dateBytes[4] = reverseByte((byte) (calendar.get(java.util.Calendar.MINUTE)));\n    dateBytes[5] = reverseByte((byte) (calendar.get(java.util.Calendar.SECOND)));\n    dateBytes[6] = reverseByte((byte) ((calendar.get(java.util.Calendar.ZONE_OFFSET)\n            + calendar.get(java.util.Calendar.DST_OFFSET)) / (60 * 1000 * 15)));\n\n    try (java.io.ByteArrayOutputStream byteStream = new java.io.ByteArrayOutputStream()) {\n        byteStream.write(serviceCenterLength);\n        byteStream.write(serviceCenterBytes);\n        byteStream.write(SMS_DELIVER);\n        byteStream.write((byte) sender.length());\n        byteStream.write(senderBytes);\n        byteStream.write(0x00);\n        byteStream.write(ENCODING_7BIT); // default 7-bit encoding\n        byteStream.write(dateBytes);\n\n        try {\n            // Reflection into internal Android API as per original SO solution\n            final String reflectedClassName = \"com.android.internal.telephony.GsmAlphabet\";\n            final java.lang.Class<?> gsmAlphabetClass = java.lang.Class.forName(reflectedClassName);\n            final java.lang.reflect.Method stringToGsm7BitPacked = gsmAlphabetClass.getMethod(\n                    \"stringToGsm7BitPacked\", new java.lang.Class<?>[]{String.class});\n            stringToGsm7BitPacked.setAccessible(true);\n\n            final byte[] bodyBytes = (byte[]) stringToGsm7BitPacked.invoke(null, body);\n            byteStream.write(bodyBytes);\n        } catch (java.lang.ClassNotFoundException\n                | java.lang.NoSuchMethodException\n                | java.lang.IllegalAccessException\n                | java.lang.reflect.InvocationTargetException reflectionException) {\n            android.util.Log.w(\"SMSSpoof\", \"Reflection failed while encoding SMS body\", reflectionException);\n            return;\n        }\n\n        pdu = byteStream.toByteArray();\n    } catch (java.io.IOException ioException) {\n        android.util.Log.w(\"SMSSpoof\", \"I/O error while building SMS PDU\", ioException);\n        return;\n    }\n\n    final android.content.Intent intent = new android.content.Intent();\n    intent.setClassName(\"com.android.mms\",\n            \"com.android.mms.transaction.SmsReceiverService\");\n    intent.setAction(\"android.provider.Telephony.SMS_RECEIVED\");\n    intent.putExtra(\"pdus\", new java.lang.Object[]{pdu});\n    intent.putExtra(\"format\", \"3gpp\");\n\n    context.startService(intent);\n}",
  "explanation": "code_hardening: Added null checks for context, sender, and body; validated sender length; used try-with-resources for ByteArrayOutputStream; marked parameters as final; added early returns to prevent malformed PDUs.\nresolve_compilation_errors: Ensured use of fully qualified class names (e.g., android.content.Context, android.util.Log, java.lang.reflect.Method) so the function compiles without relying on additional imports; reused existing reverseByte method.\nexception_handling: Replaced empty catch blocks with explicit catches for reflection-related exceptions and IOExceptions, logging warnings via android.util.Log and returning safely.\nlogic_customization: Preserved original intent, action, extras, constants, and PDU construction logic exactly; only reviewed and named hard-coded constants without changing their values or behavior; confirmed timezone offset calculation remains unchanged.\nrefactoring: Renamed ambiguous locals (e.g., bo -> byteStream, lsmcs -> serviceCenterLength); extracted magic numbers into named constants; improved readability while keeping logic identical.\nmisc: Applied consistent brace/whitespace formatting; added explanatory comments citing the original Stack Overflow source and clarifying complex sections (PDU construction and reflection usage). New custom API calls: android.util.Log.w(String, String, Throwable) for logging."
}