{
  "code": "private Bitmap generateBitmap(String componentName, Bitmap defaultBitmap) {\n        if(defaultBitmap == null)\n            return null;\n\n        if(mBackImages == null || mBackImages.isEmpty())\n            return defaultBitmap;\n\n        Bitmap backBitmap = null;\n        try {\n            long seed = generateSeed(componentName != null ? componentName : \"\");\n            Random random = new Random(seed);\n            backBitmap = mBackImages.get(Math.abs(random.nextInt()) % mBackImages.size());\n        } catch (RuntimeException e) {\n            return defaultBitmap;\n        }\n\n        if(backBitmap == null || backBitmap.getWidth() <= 0 || backBitmap.getHeight() <= 0)\n            return defaultBitmap;\n\n        Bitmap result;\n        try {\n            result = Bitmap.createBitmap(backBitmap.getWidth(), backBitmap.getHeight(), Bitmap.Config.ARGB_8888);\n        } catch (Throwable t) {\n            return defaultBitmap;\n        }\n\n        Canvas canvas = new Canvas(result);\n        Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.FILTER_BITMAP_FLAG);\n\n        // Draw back image\n        canvas.drawBitmap(backBitmap, 0, 0, paint);\n\n        // Scale and center default bitmap\n        int scaledWidth = (int) (defaultBitmap.getWidth() * mFactor);\n        int scaledHeight = (int) (defaultBitmap.getHeight() * mFactor);\n        if(scaledWidth <= 0 || scaledHeight <= 0)\n            return defaultBitmap;\n\n        Bitmap scaledBitmap;\n        try {\n            scaledBitmap = Bitmap.createScaledBitmap(defaultBitmap, scaledWidth, scaledHeight, true);\n        } catch (Throwable t) {\n            return defaultBitmap;\n        }\n\n        float left = (backBitmap.getWidth() - scaledWidth) / 2f;\n        float top = (backBitmap.getHeight() - scaledHeight) / 2f;\n\n        int saveCount = canvas.saveLayer(0, 0, backBitmap.getWidth(), backBitmap.getHeight(), null);\n        canvas.drawBitmap(scaledBitmap, left, top, paint);\n\n        // Apply masking\n        if(mMaskImage != null) {\n            paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT));\n            canvas.drawBitmap(mMaskImage, 0, 0, paint);\n        } else {\n            paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));\n            canvas.drawBitmap(backBitmap, 0, 0, paint);\n        }\n\n        paint.setXfermode(null);\n        canvas.restoreToCount(saveCount);\n\n        // Draw front overlay if present\n        if(mFrontImage != null)\n            canvas.drawBitmap(mFrontImage, 0, 0, null);\n\n        return result;\n    }",
  "explanation": "code_hardening: Added null and bounds checks for input bitmap, back images list, chosen back bitmap, and dimensions; guarded against invalid scaling factors; reset Paint Xfermode after masking to avoid side effects.\nresolve_compilation_errors: Used existing project fields (mBackImages, mMaskImage, mFrontImage, mFactor) and Android graphics classes already imported; relied on existing generateSeed(String) helper.\nexception_handling: Wrapped bitmap selection, creation, and scaling in defensive try/catch blocks (catching RuntimeException/Throwable) to safely fall back to the default bitmap on failures.\nlogic_customization: Implemented deterministic Random selection of a back image using a seed derived from the component name; created a result bitmap at back image size; scaled and centered the default bitmap by mFactor; applied masking with DST_OUT when a mask image exists or DST_IN using the back image otherwise; drew the front overlay last if present.\nrefactoring: Used clear local variable names (backBitmap, scaledBitmap, canvas, paint) and structured the composition pipeline logically within a single helper method.\nmisc: Added minimal inline comments to describe each stage of themed icon generation; no new custom API calls beyond existing Android graphics APIs."
}