{
  "code": "/**\n * Extract date from free-form text using several common date patterns.\n * <p>\n * This method is static and does not rely on instance state.\n * Parsing logic and regular expressions are preserved from the original implementation.\n * </p>\n *\n * @param text the input text to scan for a date\n * @return Date object if a date is found; otherwise {@code null}\n * @throws ParseException if date parsing fails\n * @see <a href=\"https://stackoverflow.com/\">Reference implementation discussion</a>\n * TODO: consider extending locale support and AM/PM handling in a future revision.\n */\n@SuppressWarnings(\"unused\")\npublic static Date extractDate(String text) throws ParseException {\n    Date date = null;\n    boolean dateFound = false;\n\n    String year = null;\n    String month = null;\n    String monthName = null;\n    String day = null;\n    String hour = null;\n    String minute = null;\n    String second = null;\n    String ampm = null;\n\n    String regexDelimiter = \"[-:\\\\/.,]\";\n    String regexDay = \"((?:[0-2]?\\\\d{1})|(?:[3][01]{1}))\";\n    String regexMonth = \"(?:([0]?[1-9]|[1][012])|(Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Sept|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?))\";\n    String regexYear = \"((?:[1]{1}\\\\d{1}\\\\d{1}\\\\d{1})|(?:[2]{1}\\\\d{3}))\";\n    String regexHourMinuteSecond = \"(?:(?:\\\\s)((?:[0-1][0-9])|(?:[2][0-3])|(?:[0-9])):([0-5][0-9])(?::([0-5][0-9]))?(?:\\\\s?(am|AM|pm|PM))?)?\";\n    String regexEndswith = \"(?![\\\\d])\";\n\n    // DD/MM/YYYY\n    String regexDateEuropean =\n        regexDay + regexDelimiter + regexMonth + regexDelimiter + regexYear + regexHourMinuteSecond + regexEndswith;\n\n    // MM/DD/YYYY\n    String regexDateAmerican =\n        regexMonth + regexDelimiter + regexDay + regexDelimiter + regexYear + regexHourMinuteSecond + regexEndswith;\n\n    // YYYY/MM/DD\n    String regexDateTechnical =\n        regexYear + regexDelimiter + regexMonth + regexDelimiter + regexDay + regexHourMinuteSecond + regexEndswith;\n\n    // see if there are any matches\n    Matcher m = checkDatePattern(regexDateEuropean, text);\n    if (m.find()) {\n        day = m.group(1);\n        month = m.group(2);\n        monthName = m.group(3);\n        year = m.group(4);\n        hour = m.group(5);\n        minute = m.group(6);\n        second = m.group(7);\n        ampm = m.group(8);\n        dateFound = true;\n    }\n\n    if (!dateFound) {\n        m = checkDatePattern(regexDateAmerican, text);\n        if (m.find()) {\n            month = m.group(1);\n            monthName = m.group(2);\n            day = m.group(3);\n            year = m.group(4);\n            hour = m.group(5);\n            minute = m.group(6);\n            second = m.group(7);\n            ampm = m.group(8);\n            dateFound = true;\n        }\n    }\n\n    if (!dateFound) {\n        m = checkDatePattern(regexDateTechnical, text);\n        if (m.find()) {\n            year = m.group(1);\n            month = m.group(2);\n            monthName = m.group(3);\n            day = m.group(3);\n            hour = m.group(5);\n            minute = m.group(6);\n            second = m.group(7);\n            ampm = m.group(8);\n            dateFound = true;\n        }\n    }\n\n    // construct date object if date was found\n    if (dateFound) {\n        String dateFormatPattern = \"\";\n        String dayPattern = \"\";\n        String dateString = \"\";\n\n        if (day != null) {\n            dayPattern = \"d\" + (day.length() == 2 ? \"d\" : \"\");\n        }\n\n        if (day != null && month != null && year != null) {\n            dateFormatPattern = \"yyyy MM \" + dayPattern;\n            dateString = year + \" \" + month + \" \" + day;\n        } else if (monthName != null) {\n            if (monthName.length() == 3) dateFormatPattern = \"yyyy MMM \" + dayPattern;\n            else dateFormatPattern = \"yyyy MMMM \" + dayPattern;\n            dateString = year + \" \" + monthName + \" \" + day;\n        }\n\n        if (hour != null && minute != null) {\n            // TODO: am/pm handling is currently ignored\n            dateFormatPattern += \" hh:mm\";\n            dateString += \" \" + hour + \":\" + minute;\n            if (second != null) {\n                dateFormatPattern += \":ss\";\n                dateString += \":\" + second;\n            }\n        }\n\n        if (!dateFormatPattern.equals(\"\") && !dateString.equals(\"\")) {\n            // TODO: support different locales\n            SimpleDateFormat dateFormat = new SimpleDateFormat(dateFormatPattern.trim(), Locale.US);\n            date = dateFormat.parse(dateString.trim());\n        }\n    }\n\n    return date;\n}",
  "explanation": "code_hardening: none\nresolve_compilation_errors: Updated extractDate to be static and ensured compatibility with the existing static checkDatePattern method; no import changes were required.\nexception_handling: none; the method retains the original throws ParseException signature and behavior.\nlogic_customization: Converted extractDate from an instance method to a static method while preserving all parsing logic, regular expressions, and control flow unchanged.\nrefactoring: Added @SuppressWarnings(\"unused\") at the method level to suppress compiler warnings for the intentionally unused ampm variable; variable names and structure were otherwise left intact.\nmisc: Updated Javadoc to reflect static usage, added a reference link placeholder, and refined TODO comments without affecting runtime behavior. No new custom API calls were introduced."
}