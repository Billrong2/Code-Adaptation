{
  "code": "public void resizeText(int width, int height) {\n    CharSequence text = getText();\n    // Do not resize if there is no space or no text\n    if (text == null || text.length() == 0 || width <= 0 || height <= 0) {\n        return;\n    }\n\n    // Account for padding\n    int availableWidth = width - getPaddingLeft() - getPaddingRight();\n    int availableHeight = height - getPaddingTop() - getPaddingBottom();\n    if (availableWidth <= 0 || availableHeight <= 0) {\n        return;\n    }\n\n    TextPaint textPaint = getPaint();\n    float oldTextSize = textPaint.getTextSize();\n\n    // Starting size: min(current text size, max text size if defined)\n    float startSize = mTextSize;\n    if (mMaxTextSize > 0 && mMaxTextSize < startSize) {\n        startSize = mMaxTextSize;\n    }\n\n    float targetTextSize = startSize;\n    int textHeight = Integer.MAX_VALUE;\n\n    // Linear decrement loop, step of 2px, guarded by min text size\n    while (targetTextSize > mMinTextSize) {\n        textHeight = getTextHeight(text, textPaint, availableWidth, targetTextSize);\n        if (textHeight <= availableHeight) {\n            break;\n        }\n        float nextSize = targetTextSize - 2f;\n        if (nextSize < mMinTextSize) {\n            targetTextSize = mMinTextSize;\n            break;\n        }\n        targetTextSize = nextSize;\n    }\n\n    // Re-check at minimum size\n    textHeight = getTextHeight(text, textPaint, availableWidth, targetTextSize);\n\n    // If at minimum size and still doesn't fit, append ellipsis\n    if (mAddEllipsis && targetTextSize == mMinTextSize && textHeight > availableHeight) {\n        // Use existing TextPaint and shared canvas\n        textPaint.setTextSize(targetTextSize);\n        sTextResizeCanvas.drawColor(0, android.graphics.PorterDuff.Mode.CLEAR);\n        StaticLayout layout = new StaticLayout(text, textPaint, availableWidth, Alignment.ALIGN_NORMAL, mSpacingMult, mSpacingAdd, false);\n        layout.draw(sTextResizeCanvas);\n\n        // Determine last visible line and always trim it\n        int lastLine = layout.getLineForVertical(availableHeight) - 1;\n        int start = layout.getLineStart(lastLine);\n        int end = layout.getLineEnd(lastLine);\n        float lineWidth = layout.getLineWidth(lastLine);\n        float ellipsisWidth = textPaint.measureText(mEllipsis);\n\n        // Trim characters until ellipsis fits\n        while (availableWidth < lineWidth + ellipsisWidth && end > start) {\n            end--;\n            lineWidth = textPaint.measureText(text.subSequence(start, end).toString());\n        }\n\n        setText(text.subSequence(0, end) + mEllipsis);\n    }\n\n    // Apply final text size directly to the paint and enforce line spacing\n    textPaint.setTextSize(targetTextSize);\n    setLineSpacing(mSpacingAdd, mSpacingMult);\n\n    // Notify listener\n    if (mTextResizeListener != null) {\n        mTextResizeListener.onTextResize(this, oldTextSize, targetTextSize);\n    }\n\n    // Reset resize flag\n    mNeedsResize = false;\n}",
  "explanation": "code_hardening: Kept null/empty text and width/height guards after removing the mTextSize==0 early return, added padding-aware width/height checks, and ensured the linear decrement loop is bounded by mMinTextSize to avoid infinite looping. The shared canvas is cleared before drawing.\nresolve_compilation_errors: Used existing project types (android.text.StaticLayout, android.text.TextPaint, android.graphics.Canvas, android.text.Layout.Alignment) and applied text size via TextPaint.setTextSize to avoid unit overload issues. Removed all bisection/watchdog-related locals.\nexception_handling: none.\nlogic_customization: Replaced binary search with a linear decrement loop starting from min(mTextSize, mMaxTextSize if >0) and decrementing by 2 until the text fits or mMinTextSize is reached. Removed watchdog/bounds logic. Updated ellipsis handling to always trim the last visible line using the existing TextPaint, a StaticLayout, and the shared canvas, measuring widths consistently with the same paint. Applied the final size by setting it directly on TextPaint and then calling setLineSpacing.\nrefactoring: Simplified control flow by removing obsolete variables and nested checks tied to bisection and special-case ellipsis handling; updated comments to reflect linear resizing behavior.\nmisc: Minor formatting and comments aligned with existing style; no new custom API calls were introduced."
}