{
  "code": "/**\n     * Fixes a known transition memory leak on Lollipop and above by removing this Activity's\n     * decor view from {@link android.transition.TransitionManager}'s internal running transitions.\n     * <p>\n     * This uses reflection to access internal framework state and should be called when an\n     * Activity is finishing to avoid leaking its view hierarchy.\n     * </p>\n     *\n     * @param activity the Activity whose decor view should be cleared from running transitions\n     */\n    public static void fixTransitionLeak(@NonNull Activity activity) {\n        if (activity == null) return;\n        if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.LOLLIPOP) {\n            return;\n        }\n        final Class<?> transitionManagerClass = android.transition.TransitionManager.class;\n        try {\n            final java.lang.reflect.Field runningTransitionsField = transitionManagerClass.getDeclaredField(\"sRunningTransitions\");\n            runningTransitionsField.setAccessible(true);\n            @SuppressWarnings(\"unchecked\")\n            final ThreadLocal<java.lang.ref.WeakReference<android.util.ArrayMap<android.view.ViewGroup, java.util.ArrayList<android.transition.Transition>>>> runningTransitions =\n                    (ThreadLocal<java.lang.ref.WeakReference<android.util.ArrayMap<android.view.ViewGroup, java.util.ArrayList<android.transition.Transition>>>>)\n                            runningTransitionsField.get(transitionManagerClass);\n            if (runningTransitions == null || runningTransitions.get() == null || runningTransitions.get().get() == null) {\n                return;\n            }\n            final android.util.ArrayMap<android.view.ViewGroup, java.util.ArrayList<android.transition.Transition>> map = runningTransitions.get().get();\n            final android.view.View decorView = activity.getWindow().getDecorView();\n            if (decorView instanceof android.view.ViewGroup && map.containsKey(decorView)) {\n                map.remove(decorView);\n            }\n        } catch (NoSuchFieldException | IllegalAccessException | SecurityException ignored) {\n            // Intentionally swallow reflection-related exceptions to avoid noisy logs\n        }\n    }",
  "explanation": "code_hardening: Added a defensive null-check for the Activity despite @NonNull, guarded API level usage, validated ThreadLocal/WeakReference contents, ensured the decor view is a ViewGroup before map access, and marked locals as final where applicable.\nresolve_compilation_errors: Renamed and exposed the method as public static fixTransitionLeak, used Build.VERSION_CODES.LOLLIPOP instead of a numeric SDK value, applied @NonNull to the parameter, and relied on fully qualified names where helpful to avoid import ambiguity. No new custom APIs were introduced.\nexception_handling: Consolidated reflection-related exceptions (NoSuchFieldException, IllegalAccessException, SecurityException) into a single multi-catch and intentionally swallowed them without printing stack traces.\nlogic_customization: Preserved the core logic of clearing the Activity's decor view from TransitionManager's running transitions while keeping the API-level guard functionally identical.\nrefactoring: Renamed the method for clarity, added comprehensive Javadoc explaining the transition leak and intent, and performed minor variable naming and structure cleanup within the function.\nmisc: Applied minor formatting cleanup and added a brief comment in the catch block to document the intentional swallowing of exceptions. No new custom API calls were used."
}