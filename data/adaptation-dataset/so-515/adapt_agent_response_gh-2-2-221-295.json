{
  "code": "public void resizeText(int availableWidth, int availableHeight) {\n    CharSequence text = getText();\n    if (text == null || text.length() == 0 || availableWidth <= 0 || availableHeight <= 0) {\n        return;\n    }\n\n    // Capture old size for resize reporting\n    float oldTextSize = mTextSize;\n\n    // Determine starting target size, clamped by min/max\n    float targetSize = mTextSize > 0 ? mTextSize : getTextSize();\n    if (mMaxTextSize > 0) {\n        targetSize = Math.min(targetSize, mMaxTextSize);\n    }\n    targetSize = Math.max(targetSize, mMinTextSize);\n\n    // Use a cloned TextPaint consistently for measuring and layout\n    TextPaint basePaint = getPaint();\n    TextPaint measurePaint = new TextPaint(basePaint);\n\n    int textHeight = getTextHeight(text, measurePaint, availableWidth, targetSize);\n\n    // Always shrink text until it fits or we hit the minimum size\n    // Use a safe termination condition\n    while (textHeight > availableHeight && targetSize > mMinTextSize) {\n        targetSize = Math.max(targetSize - 1f, mMinTextSize);\n        textHeight = getTextHeight(text, measurePaint, availableWidth, targetSize);\n    }\n\n    mTextSize = targetSize;\n\n    // If we reached the minimum size and still don't fit, append an ellipsis\n    if (mAddEllipsis && mTextSize == mMinTextSize && textHeight > availableHeight) {\n        TextPaint layoutPaint = new TextPaint(basePaint);\n        layoutPaint.setTextSize(mTextSize);\n        StaticLayout layout = new StaticLayout(text, layoutPaint, availableWidth, Alignment.ALIGN_NORMAL, mSpacingMult, mSpacingAdd, false);\n        if (layout.getLineCount() > 0) {\n            int lastLine = layout.getLineForVertical(availableHeight) - 1;\n            if (lastLine < 0) {\n                setText(\"\");\n            } else {\n                int start = layout.getLineStart(lastLine);\n                int end = layout.getLineEnd(lastLine);\n                float lineWidth = layout.getLineWidth(lastLine);\n                float ellipseWidth = layoutPaint.measureText(mEllipsis);\n                while (availableWidth < lineWidth + ellipseWidth && end > start) {\n                    end--;\n                    lineWidth = layoutPaint.measureText(text.subSequence(start, end).toString());\n                }\n                setText(text.subSequence(0, end) + mEllipsis);\n            }\n        }\n    }\n\n    // Apply final text size and line spacing\n    super.setTextSize(TypedValue.COMPLEX_UNIT_PX, mTextSize);\n    super.setLineSpacing(mSpacingAdd, mSpacingMult);\n\n    // Notify listener if size changed\n    if (mTextResizeListener != null && oldTextSize != mTextSize) {\n        mTextResizeListener.onTextResize(this, oldTextSize, mTextSize);\n    }\n\n    // Clear resize-needed flag\n    mNeedsResize = false;\n}",
  "explanation": "code_hardening: Added guards for null/empty text and non-positive width/height, clamped the starting target size between mMinTextSize and mMaxTextSize, ensured the resize loop only shrinks and always terminates at the minimum size, and used cloned TextPaint instances consistently for measurement and layout.\nresolve_compilation_errors: Updated the method signature to accept explicit width and height parameters, removed any reliance on widthLimit/heightLimit fields, and used existing project fields and methods (getTextHeight, setTextSize, setLineSpacing, OnTextResizeListener) with fully qualified constants where needed.\nexception_handling: none.\nlogic_customization: Removed all logic that grows text size and the post-loop back-off adjustment, initialized sizing from a clamped target size, always shrank text until it fit within the provided dimensions, and updated ellipsis trimming to rely solely on the passed width/height while building StaticLayout with a cloned TextPaint.\nrefactoring: Renamed parameters and locals for clarity (availableWidth, availableHeight, targetSize), simplified the resize loop to a single shrink-only path, and removed any dependence on obsolete increase/decrease behavior.\nmisc: Preserved resize reporting by capturing the old text size, applying the final text size and line spacing, invoking the resize listener if present, and clearing the mNeedsResize flag; comments were updated to reflect the simplified shrink-only behavior. (No new custom API calls were introduced.)"
}