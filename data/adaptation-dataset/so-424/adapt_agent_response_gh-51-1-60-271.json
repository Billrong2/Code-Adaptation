{
  "code": "public static Bitmap fastBlurPreserveAlpha(Bitmap src, int outWidth, int outHeight, int radius) {\n    if (src == null || src.isRecycled()) {\n        return null;\n    }\n    if (outWidth <= 0 || outHeight <= 0 || radius < 1) {\n        return src;\n    }\n\n    Bitmap.Config config = src.getConfig();\n    if (config == null) {\n        config = Bitmap.Config.ARGB_8888;\n    }\n\n    Bitmap scaled;\n    try {\n        scaled = Bitmap.createScaledBitmap(src, outWidth, outHeight, false);\n    } catch (OutOfMemoryError e) {\n        Log.e(\"BitmapUtil\", \"OOM while scaling bitmap\", e);\n        return src;\n    }\n\n    Bitmap bitmap;\n    try {\n        bitmap = scaled.copy(config, true);\n    } catch (OutOfMemoryError e) {\n        Log.e(\"BitmapUtil\", \"OOM while copying bitmap\", e);\n        return src;\n    }\n\n    int w = bitmap.getWidth();\n    int h = bitmap.getHeight();\n    long whLong = (long) w * (long) h;\n    if (whLong > Integer.MAX_VALUE) {\n        return src;\n    }\n    int wh = (int) whLong;\n\n    int[] pix = new int[wh];\n    bitmap.getPixels(pix, 0, w, 0, 0, w, h);\n\n    int wm = w - 1;\n    int hm = h - 1;\n    int div = radius + radius + 1;\n\n    int[] r = new int[wh];\n    int[] g = new int[wh];\n    int[] b = new int[wh];\n\n    int rsum, gsum, bsum, x, y, i, p, yp, yi, yw;\n    int[] vmin = new int[Math.max(w, h)];\n\n    int divsum = (div + 1) >> 1;\n    divsum *= divsum;\n    int[] dv = new int[256 * divsum];\n    for (i = 0; i < dv.length; i++) {\n        dv[i] = (i / divsum);\n    }\n\n    yw = yi = 0;\n\n    int[][] stack = new int[div][3];\n    int stackpointer;\n    int stackstart;\n    int[] sir;\n    int rbs;\n    int r1 = radius + 1;\n    int routsum, goutsum, boutsum;\n    int rinsum, ginsum, binsum;\n\n    for (y = 0; y < h; y++) {\n        rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;\n        for (i = -radius; i <= radius; i++) {\n            p = pix[yi + Math.min(wm, Math.max(i, 0))];\n            sir = stack[i + radius];\n            sir[0] = (p >> 16) & 0xFF;\n            sir[1] = (p >> 8) & 0xFF;\n            sir[2] = p & 0xFF;\n            rbs = r1 - Math.abs(i);\n            rsum += sir[0] * rbs;\n            gsum += sir[1] * rbs;\n            bsum += sir[2] * rbs;\n            if (i > 0) {\n                rinsum += sir[0];\n                ginsum += sir[1];\n                binsum += sir[2];\n            } else {\n                routsum += sir[0];\n                goutsum += sir[1];\n                boutsum += sir[2];\n            }\n        }\n        stackpointer = radius;\n\n        for (x = 0; x < w; x++) {\n            r[yi] = dv[rsum];\n            g[yi] = dv[gsum];\n            b[yi] = dv[bsum];\n\n            rsum -= routsum;\n            gsum -= goutsum;\n            bsum -= boutsum;\n\n            stackstart = stackpointer - radius + div;\n            sir = stack[stackstart % div];\n\n            routsum -= sir[0];\n            goutsum -= sir[1];\n            boutsum -= sir[2];\n\n            if (y == 0) {\n                vmin[x] = Math.min(x + r1, wm);\n            }\n            p = pix[yw + vmin[x]];\n\n            sir[0] = (p >> 16) & 0xFF;\n            sir[1] = (p >> 8) & 0xFF;\n            sir[2] = p & 0xFF;\n\n            rinsum += sir[0];\n            ginsum += sir[1];\n            binsum += sir[2];\n\n            rsum += rinsum;\n            gsum += ginsum;\n            bsum += binsum;\n\n            stackpointer = (stackpointer + 1) % div;\n            sir = stack[stackpointer];\n\n            routsum += sir[0];\n            goutsum += sir[1];\n            boutsum += sir[2];\n\n            rinsum -= sir[0];\n            ginsum -= sir[1];\n            binsum -= sir[2];\n\n            yi++;\n        }\n        yw += w;\n    }\n\n    for (x = 0; x < w; x++) {\n        rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;\n        yp = -radius * w;\n        for (i = -radius; i <= radius; i++) {\n            yi = Math.max(0, yp) + x;\n            sir = stack[i + radius];\n            sir[0] = r[yi];\n            sir[1] = g[yi];\n            sir[2] = b[yi];\n            rbs = r1 - Math.abs(i);\n            rsum += r[yi] * rbs;\n            gsum += g[yi] * rbs;\n            bsum += b[yi] * rbs;\n            if (i > 0) {\n                rinsum += sir[0];\n                ginsum += sir[1];\n                binsum += sir[2];\n            } else {\n                routsum += sir[0];\n                goutsum += sir[1];\n                boutsum += sir[2];\n            }\n            if (i < hm) {\n                yp += w;\n            }\n        }\n        yi = x;\n        stackpointer = radius;\n        for (y = 0; y < h; y++) {\n            int alpha = pix[yi] & 0xFF000000;\n            pix[yi] = alpha | (dv[rsum] << 16) | (dv[gsum] << 8) | dv[bsum];\n\n            rsum -= routsum;\n            gsum -= goutsum;\n            bsum -= boutsum;\n\n            stackstart = stackpointer - radius + div;\n            sir = stack[stackstart % div];\n\n            routsum -= sir[0];\n            goutsum -= sir[1];\n            boutsum -= sir[2];\n\n            if (x == 0) {\n                vmin[y] = Math.min(y + r1, hm) * w;\n            }\n            p = x + vmin[y];\n\n            sir[0] = r[p];\n            sir[1] = g[p];\n            sir[2] = b[p];\n\n            rinsum += sir[0];\n            ginsum += sir[1];\n            binsum += sir[2];\n\n            rsum += rinsum;\n            gsum += ginsum;\n            bsum += binsum;\n\n            stackpointer = (stackpointer + 1) % div;\n            sir = stack[stackpointer];\n\n            routsum += sir[0];\n            goutsum += sir[1];\n            boutsum += sir[2];\n\n            rinsum -= sir[0];\n            ginsum -= sir[1];\n            binsum -= sir[2];\n\n            yi += w;\n        }\n    }\n\n    bitmap.setPixels(pix, 0, w, 0, 0, w, h);\n    return bitmap;\n}",
  "explanation": "code_hardening: Added null and recycled bitmap checks, validated output dimensions and radius, guarded against integer overflow when allocating pixel buffers, and defaulted Bitmap.Config to ARGB_8888 when null.\nresolve_compilation_errors: Updated the API to use explicit output width and height instead of a scale factor, removed all alpha-related arrays and accumulators, and ensured only RGB buffers and a 3-component stack are used.\nexception_handling: Wrapped bitmap scaling and copying in try/catch blocks for OutOfMemoryError and fail gracefully by returning the source bitmap.\nlogic_customization: Scaled the source bitmap to the requested dimensions before blurring, removed alpha blurring entirely, recomputed dv and accumulators for RGB only, and preserved the original alpha channel when writing blurred pixels back.\nrefactoring: Renamed the method to fastBlurPreserveAlpha for clarity, simplified the stack structure to three components, improved variable naming where modified, and removed magic alpha handling logic.\nmisc: Updated inline comments implicitly through code structure, reduced logging to error-only using com.iwillow.android.lib.log.Log, and reformatted code for consistency. New custom API calls used: none."
}