{
  "code": "/**\n     * Calculates the great-circle distance between two geographic coordinates using the haversine formula.\n     * <p>\n     * All latitude/longitude values are expected in decimal degrees. The returned distance is expressed\n     * in meters.\n     * </p>\n     *\n     * @param lat1 the latitude of the first point in degrees (range: -90 to 90)\n     * @param lon1 the longitude of the first point in degrees (range: -180 to 180)\n     * @param lat2 the latitude of the second point in degrees (range: -90 to 90)\n     * @param lon2 the longitude of the second point in degrees (range: -180 to 180)\n     * @return the distance between the two points in meters, or {@link Double#NaN} if any input is invalid\n     */\n    private static double distFrom(final double lat1, final double lon1, final double lat2, final double lon2)\n    {\n        // validate input ranges\n        if (lat1 < -90.0 || lat1 > 90.0 || lat2 < -90.0 || lat2 > 90.0\n                || lon1 < -180.0 || lon1 > 180.0 || lon2 < -180.0 || lon2 > 180.0)\n            return Double.NaN;\n\n        // earth radius in meters\n        final double earthRadiusMeters = 6_371_000d;\n\n        // compute deltas in radians\n        final double dLat = Math.toRadians(lat2 - lat1);\n        final double dLon = Math.toRadians(lon2 - lon1);\n\n        // convert latitudes to radians only where needed\n        final double lat1Rad = Math.toRadians(lat1);\n        final double lat2Rad = Math.toRadians(lat2);\n\n        // haversine formula with intermediate variables for clarity\n        final double sinHalfDLat = Math.sin(dLat / 2d);\n        final double sinHalfDLon = Math.sin(dLon / 2d);\n\n        final double a = sinHalfDLat * sinHalfDLat\n                + Math.cos(lat1Rad) * Math.cos(lat2Rad) * sinHalfDLon * sinHalfDLon;\n        final double c = 2d * Math.atan2(Math.sqrt(a), Math.sqrt(1d - a));\n\n        return earthRadiusMeters * c;\n    }",
  "explanation": "code_hardening: Added validation for latitude and longitude ranges and defined a safe behavior by returning Double.NaN for invalid inputs; marked the method as private static and parameters as final; introduced a local constant for the Earth radius in meters to avoid external dependencies.\nresolve_compilation_errors: Removed reliance on an undefined EARTH_RADIUS by inlining a local constant (6,371,000 meters) and ensured the method name distFrom matches the existing call site in OpenTestResource.\nexception_handling: none.\nlogic_customization: Switched the distance unit to meters, computed latitude/longitude deltas using Math.toRadians(lat2 - lat1) and Math.toRadians(lon2 - lon1), converted latitudes to radians only for cosine usage, and preserved the haversine semantics while restructuring calculations.\nrefactoring: Renamed the method from HaverSineDistance to distFrom, restricted its visibility to private static, introduced intermediate variables for sin(dLat/2) and sin(dLon/2) to improve readability, and added comprehensive JavaDoc describing purpose, parameters, and return units.\nmisc: Reformatted the code for clarity and consistency with the surrounding style and added concise inline comments reflecting the new units and structure."
}