{
  "code": "public static <K,V extends Comparable<? super V>> SortedSet<Map.Entry<K,V>> entriesSortedByValues(Map<K,V> map, final boolean ascending)\n{\n\tif (map == null) throw new NullPointerException(\"map\");\n\t\n\tSortedSet<Map.Entry<K,V>> sortedEntries = new TreeSet<Map.Entry<K,V>>(\n\t\tnew Comparator<Map.Entry<K,V>>()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic int compare(Map.Entry<K,V> e1, Map.Entry<K,V> e2)\n\t\t\t{\n\t\t\t\tV v1 = e1.getValue();\n\t\t\t\tV v2 = e2.getValue();\n\t\t\t\t\n\t\t\t\tint res;\n\t\t\t\tif (ascending)\n\t\t\t\t{\n\t\t\t\t\tres = v1.compareTo(v2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tres = v2.compareTo(v1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Special fix to preserve items with equal values\n\t\t\t\treturn res != 0 ? res : 1;\n\t\t\t}\n\t\t}\n\t);\n\t\n\tsortedEntries.addAll(map.entrySet());\n\treturn sortedEntries;\n}",
  "explanation": "code_hardening: Added a null check for the input map to fail fast with a clear NullPointerException; marked the ascending parameter as final to ensure safe capture inside the anonymous Comparator.\nresolve_compilation_errors: Introduced the new overload with the boolean parameter and ensured the anonymous Comparator correctly captures and uses it without scope issues.\nexception_handling: none.\nlogic_customization: Implemented conditional comparison so values are compared in natural order when ascending is true and in reverse order when false, while preserving the non-zero tie-break behavior when values are equal.\nrefactoring: Updated method visibility to public static and kept variable naming clear and consistent with surrounding utility methods.\nmisc: none.\n(For any new custom API calls used that were absent from the SO snippet, name and justify them in the relevant section with FQNs/signatures if visible; write 'none' if not applicable.)"
}