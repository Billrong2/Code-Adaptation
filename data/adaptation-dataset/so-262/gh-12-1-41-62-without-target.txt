
package com.rusticisoftware.tincan.internal;

import java.io.*;
import java.util.*;
import lombok.Data;
import org.eclipse.jetty.util.IO;


@Data
public class MultipartParser {
    private byte[] boundary;
    private byte[] finalBoundary;
    private byte[] content;
    private byte[] responseContent;
    private HashMap<String, String> headers = new HashMap<String, String>();
    private ArrayList<byte[]> sections = new ArrayList<byte[]>();
    private final byte[] CONTENT_DELIMITER = ("\r\n\r\n").getBytes();

    public MultipartParser(byte[] responseContent, String boundary) throws IOException {
        this.responseContent = responseContent;
        this.boundary = ("--" + boundary).getBytes();
        this.finalBoundary = ("--" + boundary + "--").getBytes();
        splitIntoParts();
    }

        // TODO


    
    private int[] computeFailure(byte[] pattern) {
        int[] failure = new int[pattern.length];

        int j = 0;
        for (int i = 1; i < pattern.length; i++) {
            while (j > 0 && pattern[j] != pattern[i]) {
                j = failure[j - 1];
            }
            if (pattern[j] == pattern[i]) {
                j++;
            }
            failure[i] = j;
        }

        return failure;
    }

    private void splitIntoParts() {
        byte[] beforeFinalBoundary = Arrays.copyOfRange(responseContent, 0, indexOf(responseContent, finalBoundary));

        int index;
        while ((index = indexOf(beforeFinalBoundary, boundary)) >= 0) {
            sections.add(Arrays.copyOfRange(beforeFinalBoundary, 0, index));
            beforeFinalBoundary = Arrays.copyOfRange(beforeFinalBoundary, index + this.boundary.length, beforeFinalBoundary.length);
        }
        while (beforeFinalBoundary[beforeFinalBoundary.length - 1] == (byte) '\n' || beforeFinalBoundary[beforeFinalBoundary.length - 1] == (byte) '\r') {
            beforeFinalBoundary = Arrays.copyOfRange(beforeFinalBoundary, 0, beforeFinalBoundary.length - 1);
        }
        sections.add(beforeFinalBoundary);
    }

    private ArrayList<byte[]> splitDelimited(byte[] original, byte[] delimiter) {
        ArrayList<byte[]> parts = new ArrayList<byte[]>();

        int index;
        while ((index = indexOf(original, delimiter)) >= 0) {
            parts.add(Arrays.copyOfRange(original, 0, index));
            original = Arrays.copyOfRange(original, index + delimiter.length, original.length);
        }
        while (original[original.length - 1] == (byte) '\n' || original[original.length - 1] == (byte) '\r') {
            original = Arrays.copyOfRange(original, 0, original.length - 1);
        }
        parts.add(original);

        return parts;
    }

    public void parsePart(int i) throws IOException {
        ArrayList<byte[]> sectionParts = splitDelimited(sections.get(i), CONTENT_DELIMITER);
        Scanner scanner = new Scanner(new String(sectionParts.get(0)));

        String line = scanner.nextLine();

        
        if (line.trim().length() > 0) {
            if (line.contains(":")) {
                String[] parts = line.split(":");
                headers.put(parts[0].trim(), parts[1].trim());
            }
        }

        
        while (scanner.hasNextLine() && (line = scanner.nextLine()).trim().length() > 0) {
            if (line.contains(":")) {
                String[] parts = line.split(":");

                if (! parts[1].equals(null)) {
                    headers.put(parts[0].trim(), parts[1].trim());
                }
                else {
                    if ((line = scanner.nextLine()).charAt(0) == '\t') {
                        headers.put(parts[0].trim(), line.trim());
                    }
                }
            }
        }

        if (headers.get("Content-Type").contains("application/json")) {
            scanner = new Scanner(new String(sectionParts.get(1)));

            
            String contentString = "";
            while (scanner.hasNextLine() && !(line = scanner.nextLine()).equals(boundary)) {
                contentString += line;
            }
            content = contentString.getBytes();
        }
        else {
            content = sectionParts.get(1);
        }
    }
}