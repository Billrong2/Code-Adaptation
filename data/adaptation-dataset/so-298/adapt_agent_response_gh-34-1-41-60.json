{
  "code": "public static <K, V extends Comparable<? super V>> Map<K, V> \n\tsortByDescendingValue( Map<K, V> map )\n\t{\n\t\tList<Map.Entry<K, V>> list =\n\t\t\t\tnew LinkedList<Map.Entry<K, V>>( map.entrySet() );\n\t\tCollections.sort( list, new Comparator<Map.Entry<K, V>>()\n\t\t\t\t{\n\t\t\tpublic int compare( Map.Entry<K, V> o1, Map.Entry<K, V> o2 )\n\t\t\t{\n\t\t\t\treturn (o2.getValue()).compareTo( o1.getValue() );\n\t\t\t}\n\t\t\t\t} );\n\n\t\tMap<K, V> result = new LinkedHashMap<K, V>();\n\t\tfor (Map.Entry<K, V> entry : list)\n\t\t{\n\t\t\tresult.put( entry.getKey(), entry.getValue() );\n\t\t}\n\t\treturn result;\n\t}",
  "explanation": "code_hardening: none\nresolve_compilation_errors: none\nexception_handling: none\nlogic_customization: Reversed the comparator logic so values are compared in descending order by swapping the comparison operands, ensuring higher values are ordered before lower values while still relying on Comparable<? super V>.\nrefactoring: Renamed the method from sortByAscendingValue to sortByDescendingValue to clearly reflect the new descending sort behavior; preserved generics, parameters, return type, and internal list-to-map structure.\nmisc: none"
}