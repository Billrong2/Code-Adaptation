{
  "code": "public static <K, V extends Comparable<? super V>> Map<K, V> sortByValue(final Map<K, V> map, final boolean reverse) {\n        // Defensive handling of null input\n        if (map == null || map.isEmpty()) {\n            return new LinkedHashMap<K, V>();\n        }\n\n        final List<Map.Entry<K, V>> list = new LinkedList<Map.Entry<K, V>>(map.entrySet());\n\n        Collections.sort(list, new Comparator<Map.Entry<K, V>>() {\n            @Override\n            public int compare(final Map.Entry<K, V> o1, final Map.Entry<K, V> o2) {\n                final V v1 = (o1 != null) ? o1.getValue() : null;\n                final V v2 = (o2 != null) ? o2.getValue() : null;\n\n                // Handle potential null values defensively\n                int cmp;\n                if (v1 == v2) {\n                    cmp = 0;\n                } else if (v1 == null) {\n                    cmp = -1;\n                } else if (v2 == null) {\n                    cmp = 1;\n                } else {\n                    cmp = v1.compareTo(v2);\n                }\n\n                // Invert comparison for descending order when requested\n                return reverse ? -cmp : cmp;\n            }\n        });\n\n        final Map<K, V> result = new LinkedHashMap<K, V>();\n        for (Map.Entry<K, V> entry : list) {\n            result.put(entry.getKey(), entry.getValue());\n        }\n        return result;\n    }",
  "explanation": "code_hardening: Added a null/empty check for the input map to avoid NullPointerException and added defensive handling for null entries and null values inside the comparator; marked parameters and key locals as final.\nresolve_compilation_errors: Implemented the overloaded sortByValue(Map, boolean) method that existing callers (keysOfHighestValues) already reference, preserving generics and visibility consistent with the class.\nexception_handling: none.\nlogic_customization: Extended the comparator to conditionally invert the comparison result when reverse is true to support descending order, while preserving the original ascending behavior when false; kept the list conversion and LinkedHashMap reconstruction unchanged.\nrefactoring: Simplified comparator logic using a single comparison result (cmp) and a conditional inversion to improve readability without changing external behavior.\nmisc: Added brief inline comments to document the purpose of the reverse parameter and the defensive comparison behavior; no new custom API calls were introduced (none)."
}