{
  "code": "public static <K, V extends Comparable<? super V>> Map<K, V> sortByValue(Map<K, V> map, boolean doReverse) {\n\tList<Map.Entry<K, V>> entries = new LinkedList<Map.Entry<K, V>>(map.entrySet());\n\n\tComparator<Map.Entry<K, V>> valueComparator = new Comparator<Map.Entry<K, V>>() {\n\t\t@Override\n\t\tpublic int compare(Map.Entry<K, V> o1, Map.Entry<K, V> o2) {\n\t\t\treturn o1.getValue().compareTo(o2.getValue());\n\t\t}\n\t};\n\n\tComparator<Map.Entry<K, V>> effectiveComparator = doReverse\n\t\t\t? Collections.reverseOrder(valueComparator)\n\t\t\t: valueComparator;\n\n\tCollections.sort(entries, effectiveComparator);\n\n\tMap<K, V> result = new LinkedHashMap<K, V>();\n\tfor (Map.Entry<K, V> entry : entries) {\n\t\tresult.put(entry.getKey(), entry.getValue());\n\t}\n\treturn result;\n}",
  "explanation": "code_hardening: none\nresolve_compilation_errors: none\nexception_handling: none\nlogic_customization: Added a boolean parameter doReverse to the method signature. Defined a single Comparator<Map.Entry<K,V>> for comparing values and conditionally wrapped it with java.util.Collections.reverseOrder(Comparator) when doReverse is true, otherwise using the natural ordering. The selected comparator is then applied during sorting without changing the overall algorithm.\nrefactoring: Extracted the value comparison logic into a named comparator variable and introduced clearer local variable names (entries, effectiveComparator) to improve readability while preserving behavior.\nmisc: none"
}