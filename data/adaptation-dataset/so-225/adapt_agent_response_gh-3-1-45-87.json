{
  "code": "@Override\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);\n    final int widthSize = MeasureSpec.getSize(widthMeasureSpec);\n    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);\n    final int heightSize = MeasureSpec.getSize(heightMeasureSpec);\n\n    final int paddingLeft = getPaddingLeft();\n    final int paddingRight = getPaddingRight();\n    final int paddingTop = getPaddingTop();\n    final int paddingBottom = getPaddingBottom();\n\n    // Compute available content width; fall back safely for UNSPECIFIED\n    int contentWidth = widthSize - paddingLeft - paddingRight;\n    if (widthMode == MeasureSpec.UNSPECIFIED) {\n        contentWidth = Integer.MAX_VALUE;\n    }\n    if (contentWidth < 0) {\n        contentWidth = 0;\n    }\n\n    int xPosition = paddingLeft;\n    int yPosition = paddingTop;\n    int currentLineHeight = 0;\n\n    final int count = getChildCount();\n    for (int i = 0; i < count; i++) {\n        final View child = getChildAt(i);\n        if (child == null || child.getVisibility() == GONE) {\n            continue;\n        }\n\n        final ViewGroup.LayoutParams rawLp = child.getLayoutParams();\n        if (!(rawLp instanceof LayoutParams)) {\n            continue;\n        }\n        final LayoutParams lp = (LayoutParams) rawLp;\n\n        // Measure child against available content width and unspecified height\n        final int childWidthSpec = MeasureSpec.makeMeasureSpec(contentWidth, MeasureSpec.AT_MOST);\n        final int childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\n        child.measure(childWidthSpec, childHeightSpec);\n\n        final int childWidth = child.getMeasuredWidth();\n        final int childHeight = child.getMeasuredHeight();\n\n        // Wrap to next line if needed\n        if (xPosition + childWidth > paddingLeft + contentWidth) {\n            xPosition = paddingLeft;\n            yPosition += currentLineHeight;\n            currentLineHeight = 0;\n        }\n\n        currentLineHeight = Math.max(currentLineHeight, childHeight + lp.vertical_spacing);\n        xPosition += childWidth + lp.horizontal_spacing;\n    }\n\n    // Store for onLayout usage\n    this.line_height = currentLineHeight;\n\n    int measuredHeight = yPosition + currentLineHeight + paddingBottom;\n    if (measuredHeight < paddingTop + paddingBottom) {\n        measuredHeight = paddingTop + paddingBottom;\n    }\n\n    // Resolve final measured dimensions respecting MeasureSpec modes\n    int measuredWidth;\n    if (widthMode == MeasureSpec.EXACTLY) {\n        measuredWidth = widthSize;\n    } else if (widthMode == MeasureSpec.AT_MOST) {\n        measuredWidth = Math.min(widthSize, paddingLeft + contentWidth + paddingRight);\n    } else {\n        measuredWidth = paddingLeft + contentWidth + paddingRight;\n    }\n\n    if (heightMode == MeasureSpec.EXACTLY) {\n        measuredHeight = heightSize;\n    } else if (heightMode == MeasureSpec.AT_MOST) {\n        measuredHeight = Math.min(heightSize, measuredHeight);\n    }\n\n    setMeasuredDimension(measuredWidth, measuredHeight);\n}",
  "explanation": "code_hardening: Added null and visibility checks for child views, verified LayoutParams type before casting, removed the assert on UNSPECIFIED width and replaced it with a safe fallback, and clamped computed content width and measured height to non-negative values after padding subtraction.\nresolve_compilation_errors: Implemented the missing onMeasure override using existing fields (line_height) and the projectâ€™s custom PredicateLayout.LayoutParams with horizontal_spacing and vertical_spacing; ensured correct MeasureSpec usage without relying on imports.\nexception_handling: none.\nlogic_customization: Computed available content width by subtracting horizontal padding from the width spec size, measured children with AT_MOST content width and UNSPECIFIED height, replaced misuse of lp.width/lp.height with horizontal_spacing and vertical_spacing, wrapped based on content width rather than raw spec width, and calculated final height including wrapping and padding while respecting height MeasureSpec modes.\nrefactoring: Renamed positional variables for clarity (xPosition, yPosition, currentLineHeight), extracted padding and content-size calculations into locals, and removed magic values in favor of clearly named spacing fields.\nmisc: Reformatted and commented the measurement logic for readability and to reflect the corrected padding-aware, spacing-based wrapping behavior; no new custom API calls were introduced."
}