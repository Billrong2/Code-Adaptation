{
"code":"    /**\n     * Decodes the specified Base64 string into a byte array.\n     *\n     * @param base64 the Base64-encoded string (not null, length multiple of 4)\n     * @return the decoded byte array\n     * @throws IllegalArgumentException if the input is not valid Base64\n     */\n    public static byte[] decode(String base64) {\n        if (base64 == null) {\n            throw new IllegalArgumentException(\"Base64 input must not be null\");\n        }\n\n        final int len = base64.length();\n        if ((len & 0x03) != 0) {\n            throw new IllegalArgumentException(\"Base64 input length must be a multiple of 4\");\n        }\n\n        // count padding\n        int padding = 0;\n        if (len > 0 && base64.charAt(len - 1) == '=') {\n            padding++;\n            if (base64.charAt(len - 2) == '=') {\n                padding++;\n            }\n        }\n\n        final int outputLen = (len / 4) * 3 - padding;\n        if (outputLen < 0) {\n            throw new IllegalArgumentException(\"Invalid Base64 padding\");\n        }\n\n        byte[] out = new byte[outputLen];\n        int outIndex = 0;\n\n        for (int inIndex = 0; inIndex < len; inIndex += 4) {\n            char c0 = base64.charAt(inIndex);\n            char c1 = base64.charAt(inIndex + 1);\n            char c2 = base64.charAt(inIndex + 2);\n            char c3 = base64.charAt(inIndex + 3);\n\n            if (c0 >= toInt.length || c1 >= toInt.length ||\n                (c2 != '=' && c2 >= toInt.length) ||\n                (c3 != '=' && c3 >= toInt.length)) {\n                throw new IllegalArgumentException(\"Invalid Base64 character\");\n            }\n\n            int b0 = toInt[c0];\n            int b1 = toInt[c1];\n            int b2 = (c2 == '=') ? 0 : toInt[c2];\n            int b3 = (c3 == '=') ? 0 : toInt[c3];\n\n            int triple = (b0 << 18) | (b1 << 12) | (b2 << 6) | b3;\n\n            if (outIndex < outputLen) {\n                out[outIndex++] = (byte) ((triple >> 16) & 0xFF);\n            } else {\n                return out;\n            }\n            if (outIndex < outputLen) {\n                out[outIndex++] = (byte) ((triple >> 8) & 0xFF);\n            } else {\n                return out;\n            }\n            if (outIndex < outputLen) {\n                out[outIndex++] = (byte) (triple & 0xFF);\n            } else {\n                return out;\n            }\n        }\n\n        return out;\n    }",
"explanation":"code_hardening: Added null checks, enforced input length to be a multiple of 4, validated padding, checked character bounds against the lookup table, preallocated the exact output buffer, and guarded all writes with bounds checks and early returns.\nresolve_compilation_errors: Removed any dependency on the ALPHABET for decoding and relied solely on the existing static toInt lookup array; declared and initialized all indices, counters, and buffers locally within the function.\nexception_handling: Chose to throw IllegalArgumentException for malformed Base64 input (null, wrong length, invalid characters, or padding) to clearly signal decoding errors to callers.\nlogic_customization: Replaced encoding logic with decoding logic by processing input in 4-character blocks, converting Base64 characters to 6-bit values via toInt, assembling a 24-bit group, and extracting up to three bytes per block; computed the exact output length based on padding and stopped decoding once the buffer was filled.\nrefactoring: Renamed the method to decode, updated the Javadoc to reflect decoding semantics, and used clearer variable names such as inIndex, outIndex, outputLen, and padding; removed all encode-specific behavior.\nmisc: Kept formatting and comments consistent with the surrounding codebase style; no new custom API calls were introduced beyond standard Java language constructs (none)."
}