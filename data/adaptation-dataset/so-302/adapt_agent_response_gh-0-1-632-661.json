{
  "code": "// Adapted from Stack Overflow: http://stackoverflow.com/questions/2368802/how-to-create-dynamic-template-string\n// Author: cletus http://stackoverflow.com/users/18393/cletus\nprivate static String replaceAll(String text, Map<String, String> params, char leading, char trailing) {\n\tif (text == null || params == null) {\n\t\treturn text;\n\t}\n\n\tString pattern = \"\";\n\tif (leading != 0) {\n\t\tpattern += leading;\n\t}\n\tpattern += \"(\\\\w+)\";\n\tif (trailing != 0) {\n\t\tpattern += trailing;\n\t}\n\n\tfinal Pattern p = Pattern.compile(pattern);\n\tfinal Matcher m = p.matcher(text);\n\tboolean result = m.find();\n\tif (result) {\n\t\tfinal StringBuffer sb = new StringBuffer();\n\t\tdo {\n\t\t\tString replacement = params.get(m.group(1));\n\t\t\tif (replacement == null) {\n\t\t\t\treplacement = m.group();\n\t\t\t}\n\t\t\tm.appendReplacement(sb, replacement);\n\t\t\tresult = m.find();\n\t\t} while (result);\n\t\tm.appendTail(sb);\n\t\treturn sb.toString();\n\t}\n\treturn text;\n}",
  "explanation": "code_hardening: Added minimal null guards for text and params to safely return the original text when inputs are missing, and marked local variables Pattern, Matcher, and StringBuffer as final where possible without changing behavior.\nresolve_compilation_errors: Used existing java.util.regex.Pattern and Matcher, java.util.Map, and StringBuffer types already imported in the class; ensured the method signature matches the internal recursive call structure without ambiguity.\nexception_handling: Left regex compilation and matching unchecked exceptions as-is to preserve original behavior and align with existing codebase patterns; no new try/catch blocks added.\nlogic_customization: none.\nrefactoring: Changed method visibility from public to private while keeping it static, and preserved the original algorithm and control flow exactly.\nmisc: Added an attribution comment above the method consistent with existing Stack Overflow reference comments in the file; no new custom API calls introduced."
}