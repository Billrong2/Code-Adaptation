

package fontastic;

import processing.core.*;

import fontastic.FGlyph;
import fontastic.FContour;
import fontastic.FPoint;

import org.doubletype.ossa.*;
import org.doubletype.ossa.module.*;
import org.doubletype.ossa.truetype.*;
import org.doubletype.ossa.adapter.*;

import com.google.typography.font.sfntly.Font;
import com.google.typography.font.sfntly.FontFactory;
import com.google.typography.font.sfntly.data.WritableFontData;
import com.google.typography.font.tools.conversion.woff.WoffWriter;

import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.regex.Pattern;
import java.util.regex.Matcher;


public class Fontastic {

	private PApplet myParent;

	private org.doubletype.ossa.module.TypefaceFile typeface;
	private org.doubletype.ossa.Engine m_engine;

	private String fontname;

	private String TTFfilename;
	private String WOFFfilename;
	private String HTMLfilename;
	
	private List<FGlyph> glyphs;

	private int advanceWidth = 512;

	public final static String VERSION = "0.4";
	private boolean debug = true; 

	
	public final static char alphabet[] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G',
			'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
			'U', 'V', 'W', 'X', 'Y', 'Z' };
	
	public final static char alphabetLc[] = { 'a', 'b', 'c', 'd', 'e', 'f',
			'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',
			't', 'u', 'v', 'w', 'x', 'y', 'z' };

	
	public static String version() {
		return VERSION;
	}

	
	public Fontastic(PApplet myParent, String fontname) {
		this.myParent = myParent;
		this.fontname = fontname;
		intitialiseFont();
		this.glyphs = new ArrayList<FGlyph>();
	}

	
	public String getFontname() {
		return fontname;
	}

	
	private void intitialiseFont() {
		File data_dir = new File(myParent.dataPath(""));
		if (!data_dir.exists()) {
			data_dir.mkdir();
		}

		File a_dir = new File(myParent.dataPath(fontname));
		if (!a_dir.exists()) {
			a_dir.mkdir();
		} else {
			deleteFolderContents(a_dir, false);
		}

		m_engine = Engine.getSingletonInstance();
		m_engine.buildNewTypeface(fontname, a_dir);

		this.setFontFamilyName(fontname);
		this.setVersion("CC BY-SA 3.0 http://creativecommons.org/licenses/by-sa/3.0/"); 
																						

		String directoryName = a_dir + File.separator + "bin" + File.separator;

		TTFfilename = directoryName + fontname + ".ttf";
		WOFFfilename = directoryName + fontname + ".woff";
		HTMLfilename = directoryName + "template.html";
	}

	
	public void buildFont() {
		
		
		
		m_engine.addDefaultGlyphs();

		for (FGlyph glyph : glyphs) {

			GlyphFile glyphFile = m_engine.addNewGlyph(glyph.getGlyphChar());
			glyphFile.setAdvanceWidth(glyph.getAdvanceWidth());

			for (FContour contour : glyph.getContours()) {

				EContour econtour = new EContour();
				econtour.setType(EContour.k_cubic);

				for (FPoint point : contour.points) {

					EContourPoint e = new EContourPoint(point.x, point.y, true);

					if (point.hasControlPoint1()) {
						EControlPoint cp1 = new EControlPoint(true,
								point.controlPoint1.x, point.controlPoint1.y);
						e.setControlPoint1(cp1);
					}

					if (point.hasControlPoint2()) {
						EControlPoint cp2 = new EControlPoint(false,
								point.controlPoint2.x, point.controlPoint2.y);
						e.setControlPoint2(cp2);
					}

					econtour.addContourPoint(e);
				}

				glyphFile.addContour(econtour);
			}
			glyphFile.saveGlyphFile();
		}

		m_engine.buildTrueType(false);
		if (debug)
			System.out.println("TTF file created successfully: " + getTTFfilename());

		
		
		

		FontFactory fontFactory = FontFactory.getInstance();

		File fontFile = new File(getTTFfilename());
		File outputFile = new File(WOFFfilename);

		byte[] fontBytes = new byte[0];
		try {
			FileInputStream fis = new FileInputStream(fontFile);
			fontBytes = new byte[(int) fontFile.length()];
			fis.read(fontBytes);
		} catch (IOException e) {
			System.out
					.println("Error while creating WOFF File. TTF file not found: "
							+ getTTFfilename());
			e.printStackTrace();
		}

		Font[] fontArray = null;
		try {
			fontArray = fontFactory.loadFonts(fontBytes);
		} catch (IOException e) {
			System.out
					.println("Error while creating WOFF File. TTF file could not be read: "
							+ getTTFfilename());
			e.printStackTrace();
		}
		Font font = fontArray[0];

		try {
			FileOutputStream fos = new FileOutputStream(outputFile);
			WoffWriter w = new WoffWriter();
			WritableFontData woffData = w.convert(font);
			woffData.copyTo(fos);
			if (debug)
				System.out.println("WOFF File created successfully: "
						+ getWOFFfilename());
		} catch (IOException e) {
			System.out
					.println("Error while creating WOFF File. WOFF file could not be written."
							+ outputFile);
			e.printStackTrace();
		}

		
		
		
		String htmlTemplate = myParent.join(myParent.loadStrings("template.html"), "\n");
		Map<String, String> params = new HashMap<String, String>();
		params.put("FONTNAME", fontname);
		params.put("WOFFFILENAME", getFontname()+".woff");
		String htmlContent = replaceAll(htmlTemplate, params);
		
		myParent.saveStrings(HTMLfilename, myParent.split(htmlContent, "\n"));
		
	}

	
	public void cleanup() {

		File a_dir = new File(myParent.dataPath(fontname));
		File[] filesToExclude = new File[3];
		filesToExclude[0] = new File(getTTFfilename());
		filesToExclude[1] = new File(getWOFFfilename());
		filesToExclude[2] = new File(HTMLfilename);

		deleteFolderContents(a_dir, true, filesToExclude);
		if (debug)
			System.out
					.println("Cleaned up and deleted all glyph files, except font files.");

	}

	
	public void setAuthor(String author) {
		m_engine.setAuthor(author);
	}

	
	public void setCopyrightYear(String copyrightYear) {
		m_engine.setCopyrightYear(copyrightYear);
	}

	
	public void setVersion(String version) {
		m_engine.getTypeface().getGlyph().getHead().setVersion(version);
	}

	
	public void setFontFamilyName(String fontFamilyName) {
		m_engine.setFontFamilyName(fontFamilyName);
	}

	
	public void setSubFamily(String subFamily) {
		m_engine.getTypeface().setSubFamily(subFamily);
	}

	
	public void setTypefaceLicense(String typefaceLicense) {
		m_engine.setTypefaceLicense(typefaceLicense);
	}

	
	public void setBaseline(float baseline) {
		m_engine.setBaseline(baseline);
	}

	
	public void setMeanline(float meanline) {
		m_engine.setMeanline(meanline);
	}

	
	public void setAdvanceWidth(int advanceWidth) {
		m_engine.setAdvanceWidth(advanceWidth);
		this.advanceWidth = advanceWidth;
	}

	public void setTopSideBearing(float topSideBearing) {
		try {
			m_engine.getTypeface().setTopSideBearing(topSideBearing);
		} catch (OutOfRangeException e) {
			System.out
					.println("Error while setting aopSideBearing (must be within range "
							+ m_engine.getTypeface().getEm());
			e.printStackTrace();
		}
	}

	public void setBottomSideBearing(float bottomSideBearing) {
		try {
			m_engine.getTypeface().setBottomSideBearing(bottomSideBearing);
		} catch (OutOfRangeException e) {
			System.out
					.println("Error while setting bottomSideBearing (must be within range "
							+ m_engine.getTypeface().getEm());
			e.printStackTrace();
		}
	}

	public void setAscender(float ascender) {
		try {
			m_engine.getTypeface().setAscender(ascender);
		} catch (OutOfRangeException e) {
			System.out
					.println("Error while setting ascender (must be within range 0 to "
							+ m_engine.getTypeface().getEm() + ")");
			e.printStackTrace();
		}
	}

	public void setDescender(float descender) {
		try {
			m_engine.getTypeface().setDescender(descender);
		} catch (OutOfRangeException e) {
			System.out
					.println("Error while setting descender (must be within range 0 to "
							+ m_engine.getTypeface().getEm() + ")");
			e.printStackTrace();
		}
	}

	public void setXHeight(float xHeight) {
		try {
			m_engine.getTypeface().setXHeight(xHeight);
		} catch (OutOfRangeException e) {
			System.out
					.println("Error while setting xHeight (must be within range 0 to "
							+ m_engine.getTypeface().getEm()
							+ " as well as lower than the ascender "
							+ m_engine.getTypeface().getAscender() + ")");
			e.printStackTrace();
		}
	}

	
	public void setDefaultMetrics() {
		m_engine.getTypeface().setDefaultMetrics();
	}

	
	public void setDebug() {
		setDebug(true);
	}

	
	public void setDebug(boolean debug) {
		this.debug = debug;
	}

	
	public FGlyph addGlyph(char c) {

		FGlyph glyph = new FGlyph(c);
		glyph.setAdvanceWidth(advanceWidth);
		glyphs.add(glyph);
		if (debug)
			System.out.println("Glyph " + c + " added. Number of glyphs: "
					+ glyphs.size());
		return glyph;

	}

	
	public FGlyph addGlyph(char c, FContour contour) {

		FGlyph glyph = new FGlyph(c);
		glyphs.add(glyph);
		if (debug)
			System.out.println("Glyph " + c + " added. Number of glyphs: "
					+ glyphs.size());

		glyph.addContour(contour);

		glyph.setAdvanceWidth(advanceWidth);
		return glyph;

	}

	
	public FGlyph addGlyph(char c, FContour[] contours) {

		FGlyph glyph = new FGlyph(c);
		glyphs.add(glyph);
		if (debug)
			System.out.println("Glyph " + c + " added. Number of glyphs: "
					+ glyphs.size());

		for (FContour contour : contours) {
			
			glyph.addContour(contour);
		}
		glyph.setAdvanceWidth(advanceWidth);
		return glyph;

	}

	

	public FGlyph getGlyph(char c) {

		FGlyph glyph = null;
		for (int i = 0; i < glyphs.size(); i++) {
			if (glyphs.get(i).getGlyphChar() == c) {
				glyph = glyphs.get(i);
				break;
			}
		}
		return glyph;

	}

	
	public Engine getEngine() {
		return m_engine;
	}

	
	public TypefaceFile getTypefaceFile() {
		return m_engine.getTypeface();
	}

	
	public String getTTFfilename() {
		return TTFfilename;
	}

	
	public String getWOFFfilename() {
		return WOFFfilename;
	}

	private static void deleteFolderContents(File folder,
			boolean deleteFolderItself) {
		File[] files = folder.listFiles();
		if (files != null) { 
			for (File f : files) {
				if (f.isDirectory()) {
					deleteFolderContents(f, true);
					f.delete();
				} else {
					f.delete();
				}
			}
		}
		if (deleteFolderItself)
			folder.delete();
	}

	private static void deleteFolderContents(File folder,
			boolean deleteFolderItself, File[] exceptions) {
		File[] files = folder.listFiles();
		if (files != null) { 
			for (File f : files) {
				boolean deleteFile = true;
				for (File exceptfile : exceptions) {
					if (f.equals(exceptfile))
						deleteFile = false;
				}
				if (deleteFile) {
					if (f.isDirectory()) {
						deleteFolderContents(f, true, exceptions);
						f.delete();
					} else {
						f.delete();
					}
				}
			}
		}
		if (deleteFolderItself)
			folder.delete();
	}

	private String sketchName() {
		String s = myParent.sketchPath("");
		s = s.substring(0, s.length() - 1);
		String sketchName = s.substring(s.lastIndexOf(File.separator) + 1,
				s.length());
		return sketchName;
	}

	
	
	private static String replaceAll(String text, Map<String, String> params) {
		return replaceAll(text, params, '%', '%');
	}

		// TODO


}
