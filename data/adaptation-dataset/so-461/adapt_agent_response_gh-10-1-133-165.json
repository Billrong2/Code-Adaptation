{
  "code": "public static void zipDirectory(File directory, String prefixDir, ZipOutputStream zout) throws IOException {\n        // Validate inputs\n        if (directory == null || zout == null) {\n            throw new IllegalArgumentException(\"directory and ZipOutputStream must not be null\");\n        }\n        if (!directory.exists() || !directory.isDirectory()) {\n            return;\n        }\n\n        // Normalize prefixDir\n        String normalizedPrefix = prefixDir == null ? \"\" : prefixDir.trim();\n        if (normalizedPrefix.length() > 0 && !normalizedPrefix.endsWith(\"/\")) {\n            normalizedPrefix = normalizedPrefix + \"/\";\n        }\n        if (normalizedPrefix.startsWith(\"/\")) {\n            normalizedPrefix = normalizedPrefix.substring(1);\n        }\n\n        URI baseUri = directory.toURI();\n        java.util.Queue<File> queue = new LinkedList<File>();\n        queue.add(directory);\n\n        while (!queue.isEmpty()) {\n            File currentDir = queue.remove();\n            Log.d(TAG, \"Zipping directory: \" + currentDir.getAbsolutePath());\n\n            File[] children = currentDir.listFiles();\n            if (children == null) {\n                continue;\n            }\n\n            for (File child : children) {\n                String relativeName = baseUri.relativize(child.toURI()).getPath();\n                String entryName = normalizedPrefix + relativeName;\n\n                if (child.isDirectory()) {\n                    // Ensure trailing slash for directory entries\n                    if (!entryName.endsWith(\"/\")) {\n                        entryName = entryName + \"/\";\n                    }\n                    zout.putNextEntry(new ZipEntry(entryName));\n                    zout.closeEntry();\n                    queue.add(child);\n                } else {\n                    zout.putNextEntry(new ZipEntry(entryName));\n                    FileInputStream fis = new FileInputStream(child);\n                    try {\n                        IOUtils.copy(fis, zout);\n                    } finally {\n                        fis.close();\n                    }\n                    zout.closeEntry();\n                }\n            }\n        }\n    }",
  "explanation": "code_hardening: Validated non-null inputs, checked that the base directory exists and is a directory, null-checked listFiles() to avoid NPEs, normalized prefixDir to avoid malformed zip entry names, and ensured FileInputStream is always closed while leaving the ZipOutputStream open.\nresolve_compilation_errors: Removed creation/closure of FileOutputStream and ZipOutputStream, updated the signature to accept an existing ZipOutputStream, and replaced the undefined copy call with org.apache.commons.io.IOUtils.copy(InputStream, OutputStream) using a FileInputStream.\nexception_handling: Kept the IOException throws clause, removed any logic that would close the ZipOutputStream, and added localized try/finally blocks to safely close each FileInputStream.\nlogic_customization: Switched traversal from a stack to a FIFO queue to achieve breadth-first order, computed relative paths via base URI relativization, prepended a normalized prefixDir to each entry name, ensured directory entries end with '/', continued emitting directory entries and enqueuing subdirectories, and avoided closing the ZipOutputStream.\nrefactoring: Renamed local variables for clarity (currentDir, children, normalizedPrefix), simplified control flow within a single helper-style method, and aligned the method behavior with its helper role.\nmisc: Added basic debug logging using android.util.Log.d for each directory processed; new custom API used: org.apache.commons.io.IOUtils.copy(InputStream, OutputStream)."
}