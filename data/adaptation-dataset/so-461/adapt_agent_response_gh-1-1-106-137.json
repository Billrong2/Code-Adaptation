{
  "code": "private static void zipDirectory(File directory, String prefix, ZipOutputStream zout) throws IOException {\n    if (directory == null || zout == null || prefix == null) {\n        throw new IllegalArgumentException(\"directory, prefix, and ZipOutputStream must not be null\");\n    }\n    if (!directory.exists() || !directory.isDirectory()) {\n        throw new IllegalArgumentException(\"directory must exist and be a directory: \" + directory);\n    }\n\n    java.net.URI baseUri = directory.toURI();\n    java.util.LinkedList<File> queue = new java.util.LinkedList<File>();\n    queue.add(directory); // FIFO for BFS\n\n    while (!queue.isEmpty()) {\n        File currentDir = queue.poll();\n        File[] children = currentDir.listFiles();\n        if (children == null) {\n            continue;\n        }\n        for (File child : children) {\n            String relativePath = baseUri.relativize(child.toURI()).getPath();\n            String entryName = prefix + relativePath;\n            if (child.isDirectory()) {\n                queue.add(child);\n                if (!entryName.endsWith(\"/\")) {\n                    entryName = entryName + \"/\";\n                }\n                zout.putNextEntry(new java.util.zip.ZipEntry(entryName));\n                zout.closeEntry();\n            } else {\n                java.io.FileInputStream in = null;\n                zout.putNextEntry(new java.util.zip.ZipEntry(entryName));\n                try {\n                    in = new java.io.FileInputStream(child);\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    int count;\n                    while ((count = in.read(buffer)) != -1) {\n                        zout.write(buffer, 0, count);\n                    }\n                } finally {\n                    try {\n                        if (in != null) {\n                            in.close();\n                        }\n                    } finally {\n                        zout.closeEntry();\n                    }\n                }\n            }\n        }\n    }\n}",
  "explanation": "code_hardening: Added null checks for directory, prefix, and ZipOutputStream; validated that the directory exists and is a directory; null-checked listFiles(); ensured FileInputStream is always closed in a finally block; explicitly avoided closing the caller-provided ZipOutputStream.\nresolve_compilation_errors: Removed use of undefined copy/IOUtils helpers; updated the method signature to accept File, String prefix, and ZipOutputStream; used fully qualified names for java.util and java.io classes where needed; relied on existing BUFFER_SIZE constant.\nexception_handling: Declared throws IOException; structured nested try/finally so FileInputStream is closed and ZipOutputStream.closeEntry() is always invoked even if copying fails; did not close the ZipOutputStream itself.\nlogic_customization: Switched traversal to BFS using a FIFO queue; prepended the provided prefix to every zip entry name; preserved directory entries with guaranteed trailing slashes; enqueued directories before processing their children.\nrefactoring: Extracted functionality into a helper that writes to a caller-managed ZipOutputStream; renamed loop variables for clarity; simplified resource management by removing external helpers and Closeable patterns.\nmisc: Reformatted code to match existing style and added clear argument validation messages; no new custom API calls beyond standard java.io/java.util.zip classes (none)."
}