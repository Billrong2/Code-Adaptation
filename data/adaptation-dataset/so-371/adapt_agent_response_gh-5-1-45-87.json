{
  "code": "@Override\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    // Reset per-measure state\n    line_height = 0;\n\n    final int widthMode = android.view.View.MeasureSpec.getMode(widthMeasureSpec);\n    final int widthSize = android.view.View.MeasureSpec.getSize(widthMeasureSpec);\n    final int heightMode = android.view.View.MeasureSpec.getMode(heightMeasureSpec);\n    final int heightSize = android.view.View.MeasureSpec.getSize(heightMeasureSpec);\n\n    // Available width for children, guarding against negatives\n    int availableWidth = widthSize - getPaddingLeft() - getPaddingRight();\n    if (availableWidth < 0) {\n        availableWidth = 0;\n    }\n\n    final int count = getChildCount();\n    int x = getPaddingLeft();\n    int y = getPaddingTop();\n\n    final int childWidthMeasureSpec = android.view.View.MeasureSpec.makeMeasureSpec(\n            availableWidth, android.view.View.MeasureSpec.AT_MOST);\n    final int childHeightMeasureSpec = android.view.View.MeasureSpec.makeMeasureSpec(\n            0, android.view.View.MeasureSpec.UNSPECIFIED);\n\n    for (int i = 0; i < count; i++) {\n        final android.view.View child = getChildAt(i);\n        if (child == null || child.getVisibility() == GONE) {\n            continue;\n        }\n\n        final android.view.ViewGroup.LayoutParams rawLp = child.getLayoutParams();\n        if (!(rawLp instanceof LayoutParams)) {\n            continue; // skip children with unexpected LayoutParams\n        }\n        final LayoutParams lp = (LayoutParams) rawLp;\n\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n\n        final int childw = child.getMeasuredWidth();\n        final int childh = child.getMeasuredHeight();\n\n        // Wrap to next line if this child would exceed available width\n        if (x + childw > getPaddingLeft() + availableWidth) {\n            x = getPaddingLeft();\n            y += line_height;\n            line_height = 0;\n        }\n\n        // Track max height for the current line, including vertical spacing\n        line_height = Math.max(line_height, childh + lp.vertical_spacing);\n\n        x += childw + lp.horizontal_spacing;\n    }\n\n    int measuredHeight = y + line_height + getPaddingBottom();\n\n    // Respect parent height constraints\n    if (heightMode == android.view.View.MeasureSpec.AT_MOST) {\n        measuredHeight = Math.min(measuredHeight, heightSize);\n    } else if (heightMode == android.view.View.MeasureSpec.EXACTLY) {\n        measuredHeight = heightSize;\n    }\n\n    // Width is determined by parent; height computed above\n    setMeasuredDimension(widthSize, measuredHeight);\n}",
  "explanation": "code_hardening: Added null checks for child views and their LayoutParams, guarded against negative available width after padding subtraction, and reset the member field line_height at the start of onMeasure.\nresolve_compilation_errors: Used the existing PredicateLayout.LayoutParams with horizontal_spacing and vertical_spacing, relied on the existing member field line_height, and referenced MeasureSpec via fully qualified android.view.View.MeasureSpec to avoid import issues.\nexception_handling: none.\nlogic_customization: Replaced fixed spacing with per-child spacing from LayoutParams, always measured children with width AT_MOST to the available line width and height UNSPECIFIED, tracked the current rowâ€™s max height in line_height, wrapped to a new line when the next child would exceed available width and advanced y by line_height, recomputed the final measured height as y + line_height honoring UNSPECIFIED/AT_MOST/EXACTLY modes, and removed the bottom fudge factor.\nrefactoring: Renamed local variables for clarity (x/y instead of xpos/ypos), extracted MeasureSpec calculations into final locals, and simplified width handling to rely on the parent-provided size.\nmisc: Updated inline comments to reflect the new measurement and wrapping behavior; no new custom API calls were introduced."
}