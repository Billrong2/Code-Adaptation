{
"code":"private static String replaceTokens(String template, java.util.Map<String, String> variables) {\n    if (template == null || variables == null) {\n        return template;\n    }\n    final java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(\"_(.+?)_\");\n    final java.util.regex.Matcher matcher = pattern.matcher(template);\n    final StringBuffer buffer = new StringBuffer();\n    while (matcher.find()) {\n        final String tokenName = matcher.group(1);\n        final String replacement = variables.get(tokenName);\n        // remove the matched token first\n        matcher.appendReplacement(buffer, \"\");\n        if (replacement != null) {\n            // append raw replacement without regex escaping\n            buffer.append(replacement);\n        } else {\n            // leave the original token unchanged\n            buffer.append(matcher.group(0));\n        }\n    }\n    matcher.appendTail(buffer);\n    return buffer.toString();\n}",
"explanation":"code_hardening: Added null checks for template and variables to avoid NPEs and marked locals as final where applicable.\nresolve_compilation_errors: Introduced the private static replaceTokens(String, Map<String,String>) method expected by populateTemplate, using fully qualified names for Pattern and Matcher to avoid import issues.\nexception_handling: none.\nlogic_customization: Updated token syntax to _name_ via a new regex pattern, changed replacement criteria to only substitute when variables.get(tokenName) is non-null, and implemented replacement by removing the match with appendReplacement(buffer, \"\") and manually appending either the raw replacement or the original token.\nrefactoring: Renamed variables to reflect token semantics and removed any reliance on Matcher.quoteReplacement or ${} syntax.\nmisc: Updated inline comments to document the new behavior and API restrictions."}