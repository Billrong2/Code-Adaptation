

package net.yacy.document.parser;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

import net.yacy.cora.document.id.AnchorURL;
import net.yacy.cora.document.id.DigestURL;
import net.yacy.cora.util.ConcurrentLog;
import net.yacy.document.AbstractParser;
import net.yacy.document.Document;
import net.yacy.document.Parser;
import net.yacy.document.VocabularyScraper;

public class apkParser extends AbstractParser implements Parser  {

    public apkParser() {
        super("Android Application Parser");
        this.SUPPORTED_EXTENSIONS.add("apk");
        this.SUPPORTED_MIME_TYPES.add("application/vnd.android.package-archive");
    }
    
    @Override
    public Document[] parse(
            final DigestURL location,
            final String mimeType,
            final String charset,
            final VocabularyScraper scraper, 
            final int timezoneOffset,
            final InputStream source) throws Parser.Failure, InterruptedException {

        
        Document[] docs = null;
        try {
            File tempFile = File.createTempFile("apk" + System.currentTimeMillis(), "jar");
            final FileOutputStream out = new FileOutputStream(tempFile);
            int read = 0;
            final byte[] data = new byte[1024];
            while((read = source.read(data, 0, 1024)) != -1) {
                out.write(data, 0, read);
            }
            out.close();
            JarFile jf = new JarFile(tempFile);
            docs = parse(location, mimeType, charset, jf);
            tempFile.delete();
        } catch (IOException e) {
            ConcurrentLog.logException(e);
        }
        return docs;
    }
    
    public Document[] parse(final DigestURL location, final String mimeType, final String charset, final JarFile jf) {
        StringBuilder sb = new StringBuilder();
        String title = location.getFileName();
        AndroidManifestParser manifest = null;
        try {
            InputStream is = jf.getInputStream(jf.getEntry("AndroidManifest.xml"));
            byte[] xml = new byte[is.available()];
            is.read(xml);
            manifest = new AndroidManifestParser(xml, true);
            title = location.getFileName() + " " + manifest.packageName + " " + manifest.versionName;
            sb.append(title).append(". ");
            for (String p: manifest.permissions) sb.append(p).append(". ");
        } catch (IOException e) {
            ConcurrentLog.logException(e);
        }

        Enumeration<JarEntry> je = jf.entries();
        while (je.hasMoreElements()) {
            String path = je.nextElement().toString();
            sb.append(path).append(". ");
        }

        final Collection<AnchorURL> links = new ArrayList<>();
        try {
            InputStream is = jf.getInputStream(jf.getEntry("resources.arsc"));
            List<String> resources = resourcesArscParser(is);
            for (String s: resources) {
                sb.append(s).append(". ");
                int p = s.indexOf("http://");
                if (p < 0) p = s.indexOf("https://");
                if (p < 0) p = s.indexOf("ftp://");
                if (p >= 0) {
                    int q = s.indexOf(' ', p + 1);
                    String link = q < 0 ? s.substring(p) : s.substring(p, q);
                    try {
                        links.add(new AnchorURL(link));
                    } catch (MalformedURLException e) {}
                }
            }
        } catch (IOException e) {
            ConcurrentLog.logException(e);
        }        

        return new Document[]{new Document(
                location,
                mimeType,
                charset,
                this,
                null,
                null,
                singleList(title),
                null,
                manifest == null ? "" : manifest.packageName,
                null,
                null,
                0.0d, 0.0d,
                sb.toString(),
                links,
                null,
                null,
                false,
                new Date())};
    }
    
    public static class AndroidManifestParser {
        
        
    
        private boolean debug = false;
        public String versionCode = null;
        public String versionName = null;
        public String packageName = null;
        public String minSdkVersion = null;
        public String targetSdkVersion = null;
        public Set<String> permissions = new HashSet<>();
        public Set<String> actions = new HashSet<>();
        public Set<String> categories = new HashSet<>();
        
        public AndroidManifestParser(final byte[] xml, final boolean debug) {
            this.debug = debug;
            decompressXML(xml);
        }
            
        
        
        private static final int endDocTag = 0x00100101;
        private static final int startTag = 0x00100102;
        private static final int endTag = 0x00100103;
    
                // TODO

    
        public String compXmlString(byte[] xml, int sitOff, int stOff, int strInd) {
            if (strInd < 0) return null;
            int strOff = stOff + LEW(xml, sitOff + strInd * 4);
            return compXmlStringAt(xml, strOff);
        }
    
        public void evaluateTag(int indent, String tagName, Map<String, String> attributes) {
            if (this.debug) {
                StringBuilder sb = new StringBuilder(100);
                for (int i = 0; i < indent; i++) sb.append("  ");
                if (attributes == null) {
                    sb.append("</").append(tagName).append('>');
                } else {
                    sb.append('<').append(tagName);
                    for (Map.Entry<String, String> entry: attributes.entrySet()) {
                        sb.append(' ').append(entry.getKey()).append("=\"").append(entry.getValue()).append('\"');
                    }
                    sb.append('>');
                }
                //System.out.println(sb.toString());
            }
            
            // evaluate the content
            if (attributes != null) {
                if ("manifest".equals(tagName)) {
                    this.versionCode = attributes.get("versionCode");
                    this.versionName = attributes.get("versionName");
                    this.packageName = attributes.get("package");
                }
                if ("uses-sdk".equals(tagName)) {
                    this.minSdkVersion = attributes.get("minSdkVersion");
                    this.targetSdkVersion = attributes.get("targetSdkVersion");
                }
                if ("uses-permission".equals(tagName)) {
                    final String permission = attributes.get("name");
                    if (permission != null) this.permissions.add(permission);
                }
                if ("action".equals(tagName)) {
                    final String action = attributes.get("name");
                    if (action != null) this.actions.add(action);
                }
                if ("category".equals(tagName)) {
                    final String category = attributes.get("name");
                    if (category != null) this.categories.add(category);
                }
            }
        }
    
        /**
         * Return the string stored in StringTable format at offset strOff.
         * This offset points to the 16 bit string length, which
         * is followed by that number of 16 bit (Unicode) chars.
         * @param arr
         * @param strOff
         * @return
         */
        public String compXmlStringAt(byte[] arr, int strOff) {
            int strLen = arr[strOff + 1] << 8 & 0xff00 | arr[strOff] & 0xff;
            char[] chars = new char[strLen];
            for (int ii = 0; ii < strLen; ii++) {
                int p0 = strOff + 2 + ii * 2;
                if (p0 >= arr.length - 1) break; // this should never happen if the compressed xml is well-formed, but some are not(!)
                chars[ii] = (char) (((arr[p0 + 1] & 0x00FF) << 8) + (arr[p0] & 0x00FF));
            }
            return new String(chars);
        }
    
        /**
         * Return value of a Little Endian 32 bit word from the byte array at offset off.
         * @param arr
         * @param off
         * @return
         */
        public int LEW(byte[] arr, int off) {
            return arr[off + 3] << 24 & 0xff000000 | arr[off + 2] << 16 & 0xff0000 | arr[off + 1] << 8 & 0xff00 | arr[off] & 0xFF;
        } // end of LEW
    
    }
    
    /**
     * this arsc parser is far away from being correct, it's just a hack
     * @param arscStream a stream from the arsc content
     * @return a list of resource strings
     * @throws IOException
     */
    public static List<String> resourcesArscParser(InputStream arscStream) throws IOException {
        final byte[] asa = new byte[arscStream.available()];
        arscStream.read(asa);
        int pos = 0;
        final Charset charset = StandardCharsets.UTF_8;
        final List<String> s = new ArrayList<>();
        parseloop: while (pos < asa.length) {
            while (pos < asa.length && asa[pos] != 0) pos++;
            if (pos + 2 >= asa.length) break parseloop;
            
            
            
            int charcount = asa[++pos];
            if (charcount == 0) continue parseloop;
            int bytecount = asa[++pos];
            if (bytecount == 0) continue parseloop;
            pos++;
            if (bytecount < charcount) continue parseloop;
            if (pos + bytecount + 1 > asa.length) break parseloop;
            if (asa[pos + bytecount] != 0) {pos++; continue parseloop;} 
            for (int i = pos; i < pos + bytecount; i++) if (asa[i] == 0) {pos++; continue parseloop;} 
            String t = new String(asa, pos, bytecount, charset);
            if (t.length() == charcount) s.add(t);
            pos += bytecount;
        }
        return s;
    }
    
    public static void main(String[] args) {
        System.out.println("apk parser test with file " + args[0]);
        System.out.println();
        System.out.println("File list:");
        try {
            JarFile jf = new JarFile(args[0]);
            Enumeration<JarEntry> e = jf.entries();
            while (e.hasMoreElements()) {
                String path = e.nextElement().toString();
                System.out.println(path);
            }
            System.out.println();
            System.out.println("AndroidManifest.xml:");
            InputStream is = jf.getInputStream(jf.getEntry("AndroidManifest.xml"));
            byte[] xml = new byte[is.available()];
            is.read(xml);
            @SuppressWarnings("unused")
            AndroidManifestParser manifest = new AndroidManifestParser(xml, true);

            System.out.println();
            System.out.println("resources.arsc:");
            is = jf.getInputStream(jf.getEntry("resources.arsc"));
            List<String> resources = resourcesArscParser(is);
            for (String s: resources) {
                System.out.println(s);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.exit(1);
    }
    
}
