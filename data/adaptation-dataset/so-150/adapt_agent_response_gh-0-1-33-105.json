{
"code":"public static long nthPrime(final long n) {\n\tif (n < 0L) {\n\t\tthrow new IllegalArgumentException(\"n must be non-negative\");\n\t}\n\t// Preserve special cases from original algorithm\n\tif (n < 2L) {\n\t\treturn 2L;\n\t}\n\tif (n == 2L) {\n\t\treturn 3L;\n\t}\n\tif (n == 3L) {\n\t\treturn 5L;\n\t}\n\n\t// Defensive handling for logarithms\n\tfinal double dn = (double) n;\n\tfinal double logn = dn > 1.0 ? Math.log(dn) : 0.0;\n\tfinal double loglogn = dn > 2.0 ? Math.log(logn) : 0.0;\n\n\tlong limit = (long) (dn * (logn + loglogn)) + 3L;\n\tlong root = (long) Math.sqrt((double) limit);\n\tlong count = 2L; // counting primes 2 and 3 implicitly\n\n\t// Normalize limit to 6kÂ±1 representation\n\tswitch ((int) (limit % 6L)) {\n\tcase 0:\n\t\tlimit = 2L * (limit / 6L) - 1L;\n\t\tbreak;\n\tcase 5:\n\t\tlimit = 2L * (limit / 6L) + 1L;\n\t\tbreak;\n\tdefault:\n\t\tlimit = 2L * (limit / 6L);\n\t}\n\n\t// Normalize root similarly\n\tswitch ((int) (root % 6L)) {\n\tcase 0:\n\t\troot = 2L * (root / 6L) - 1L;\n\t\tbreak;\n\tcase 5:\n\t\troot = 2L * (root / 6L) + 1L;\n\t\tbreak;\n\tdefault:\n\t\troot = 2L * (root / 6L);\n\t}\n\n\t// Sieve uses int indexing; ensure array size fits int\n\tif (limit > (long) Integer.MAX_VALUE * 32L) {\n\t\tthrow new IllegalArgumentException(\"n too large for sieve representation\");\n\t}\n\tfinal int dim = (int) ((limit + 31L) >> 5);\n\tfinal int[] sieve = new int[dim];\n\n\t// Sieve marking with micro-optimizations\n\tfor (int i = 0; i < (int) root; ++i) {\n\t\tfinal int word = sieve[i >> 5];\n\t\tif ((word & (1 << (i & 31))) == 0) {\n\t\t\tfinal long li = (long) i;\n\t\t\tfinal long start;\n\t\t\tfinal long s1;\n\t\t\tfinal long s2;\n\t\t\tif ((i & 1) == 1) {\n\t\t\t\tstart = li * (3L * li + 8L) + 4L;\n\t\t\t\ts1 = 4L * li + 5L;\n\t\t\t\ts2 = 2L * li + 3L;\n\t\t\t} else {\n\t\t\t\tstart = li * (3L * li + 10L) + 7L;\n\t\t\t\ts1 = 2L * li + 3L;\n\t\t\t\ts2 = 4L * li + 7L;\n\t\t\t}\n\t\t\tfor (long j = start; j < limit; j += s2) {\n\t\t\t\tfinal int idx = (int) j;\n\t\t\t\tsieve[idx >> 5] |= 1 << (idx & 31);\n\t\t\t\tj += s1;\n\t\t\t\tif (j >= limit) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfinal int idx2 = (int) j;\n\t\t\t\tsieve[idx2 >> 5] |= 1 << (idx2 & 31);\n\t\t\t}\n\t\t}\n\t}\n\n\tint i = 0;\n\tfor (; count < n; ++i) {\n\t\tcount += popCount(~sieve[i]);\n\t}\n\t--i;\n\tint mask = ~sieve[i];\n\tint p;\n\tfor (p = 31; count >= n; --p) {\n\t\tcount -= (mask >> p) & 1;\n\t}\n\n\t// Final prime reconstruction, widened to long\n\treturn 3L * ((long) p + ((long) i << 5)) + 7L + (long) (p & 1);\n}",
"explanation":"code_hardening: Added validation for negative n, defensive handling for logarithms when n is small, and a guard to prevent sieve array overflow beyond int-indexable limits. Marked key locals as final where safe.\nresolve_compilation_errors: Aligned the method signature to a static nthPrime(long) returning long to match evaluate(); reused existing popCount(int) without introducing new helpers; ensured all sieve indices are explicitly cast to int.\nexception_handling: Chose IllegalArgumentException for invalid or excessively large n so callers (evaluate) can handle it uniformly as a RuntimeException.\nlogic_customization: Broadened numeric range by converting n, limit, root, count, loop arithmetic, and final reconstruction to long while keeping sieve storage as int[]. Preserved the original algorithm and special cases, iterated marking indices as long, and accumulated counts in long.\nrefactoring: Renamed and reused locals (li, s1, s2) to reduce repeated calculations, precomputed parity branches, and removed magic int arithmetic in favor of clearer long expressions without changing behavior.\nmisc: Added brief comments describing major steps (sieve normalization, marking, reconstruction) and kept formatting consistent with the surrounding class. New custom API calls: none."}