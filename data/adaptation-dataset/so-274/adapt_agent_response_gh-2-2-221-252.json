{
"code":"private void updatePredecessorsWithCheckMode(TreePath tp, boolean checkMode) {\n\tif (tp == null || nodesCheckingState == null) {\n\t\treturn;\n\t}\n\tTreePath parentPath = tp.getParentPath();\n\t// Stop recursion at root\n\tif (parentPath == null) {\n\t\treturn;\n\t}\n\tCheckedNode parentState = nodesCheckingState.get(parentPath);\n\tif (parentState == null) {\n\t\treturn;\n\t}\n\tObject parentComponent = parentPath.getLastPathComponent();\n\tif (!(parentComponent instanceof DefaultMutableTreeNode)) {\n\t\treturn;\n\t}\n\tDefaultMutableTreeNode parentNode = (DefaultMutableTreeNode) parentComponent;\n\n\tboolean anyChildSelected = false;\n\tboolean allChildrenFullySelected = true;\n\n\tfor (int i = 0; i < parentNode.getChildCount(); i++) {\n\t\tObject child = parentNode.getChildAt(i);\n\t\tTreePath childPath = parentPath.pathByAddingChild(child);\n\t\tCheckedNode childState = nodesCheckingState.get(childPath);\n\t\tif (childState == null) {\n\t\t\tallChildrenFullySelected = false;\n\t\t\tcontinue;\n\t\t}\n\t\tif (childState.isSelected) {\n\t\t\tanyChildSelected = true;\n\t\t}\n\t\t// A child is fully selected only if it is selected and either has no children\n\t\t// or all of its children are fully selected\n\t\tboolean childFullySelected = childState.isSelected && (!childState.hasChildren || childState.allChildrenSelected);\n\t\tif (!childFullySelected) {\n\t\t\tallChildrenFullySelected = false;\n\t\t}\n\t}\n\n\tparentState.hasChildren = parentNode.getChildCount() > 0;\n\tparentState.isSelected = anyChildSelected;\n\tparentState.allChildrenSelected = anyChildSelected && allChildrenFullySelected;\n\n\t// Maintain checkedPaths consistency based on recomputed state\n\tif (parentState.isSelected) {\n\t\tcheckedPaths.add(parentPath);\n\t} else {\n\t\tcheckedPaths.remove(parentPath);\n\t}\n\n\t// Recurse upward\n\tupdatePredecessorsWithCheckMode(parentPath, parentState.isSelected);\n}",
"explanation":"code_hardening: Added null checks for TreePath, nodesCheckingState, parent state, and path components; explicitly stop recursion at the root; avoid unsafe casts; recompute flags defensively even if some child states are missing.\nresolve_compilation_errors: Implemented the missing updatePredecessorsWithCheckMode method using existing project types (TreePath, DefaultMutableTreeNode, CheckedNode) without any UI dependencies; relied only on fields already present in the class (nodesCheckingState, checkedPaths).\nexception_handling: none.\nlogic_customization: Replaced renderer-based logic with a state-management routine that propagates selection changes upward; for each ancestor, iterates over all children to determine whether any child is selected and whether all child subtrees are fully selected; sets parent as fully selected only if all children are fully selected, partially selected if at least one child is selected; updates checkedPaths to add or remove the parent path based on recomputed state; stops propagation at the root.\nrefactoring: Focused the method purely on model/state updates with clear local variable names (anyChildSelected, allChildrenFullySelected) and separated child evaluation from parent state assignment.\nmisc: Added brief inline comments to document tri-state ancestor recomputation behavior; no new custom API calls were introduced (none)."}