{
"code":"protected void updatePredecessorsAllChildrenSelectedState(TreePath tp) {\n    if (tp == null || nodesCheckingState == null) {\n        return;\n    }\n    TreePath parentPath = tp.getParentPath();\n    if (parentPath == null) {\n        return; // reached root\n    }\n    CheckedNode parentState = nodesCheckingState.get(parentPath);\n    if (parentState == null) {\n        return;\n    }\n    Object parentComp = parentPath.getLastPathComponent();\n    if (!(parentComp instanceof DefaultMutableTreeNode)) {\n        return;\n    }\n    DefaultMutableTreeNode parentNode = (DefaultMutableTreeNode) parentComp;\n\n    boolean prevAllChildrenSelected = parentState.allChildrenSelected;\n    boolean prevIsSelected = parentState.isSelected;\n\n    boolean allChildrenSelected = true;\n    boolean anyChildSelected = false;\n\n    for (int i = 0; i < parentNode.getChildCount(); i++) {\n        TreePath childPath = parentPath.pathByAddingChild(parentNode.getChildAt(i));\n        CheckedNode childState = nodesCheckingState.get(childPath);\n        if (childState == null) {\n            allChildrenSelected = false;\n            continue;\n        }\n        if (!allSelected(childState)) {\n            allChildrenSelected = false;\n        }\n        if (childState.isSelected) {\n            anyChildSelected = true;\n        }\n    }\n\n    parentState.allChildrenSelected = allChildrenSelected;\n    parentState.isSelected = anyChildSelected;\n\n    if (parentState.isSelected) {\n        checkedPaths.add(parentPath);\n    } else {\n        checkedPaths.remove(parentPath);\n    }\n\n    // Stop recursion if no state changed to avoid unnecessary traversal\n    if (prevAllChildrenSelected == parentState.allChildrenSelected\n            && prevIsSelected == parentState.isSelected) {\n        return;\n    }\n\n    updatePredecessorsAllChildrenSelectedState(parentPath);\n}",
"explanation":"code_hardening: Added null checks for TreePath, nodesCheckingState, parent path, CheckedNode lookups, and node type; stopped recursion at root and when no state change occurs to avoid infinite or redundant traversal.\nresolve_compilation_errors: Implemented the missing helper method updatePredecessorsAllChildrenSelectedState(TreePath) referenced by existing callers, using existing fields and the allSelected(CheckedNode) method; relied on fully qualified Swing tree types already present in the class.\nexception_handling: none.\nlogic_customization: Replaced any renderer-driven behavior with pure state maintenance: recomputed parent allChildrenSelected by scanning all siblings and invoking allSelected, set parent isSelected if any child is selected, updated checkedPaths accordingly, and recursively propagated the recalculation up to the root using nodesCheckingState as the single source of truth.\nrefactoring: Used descriptive local variable names, removed UI concerns entirely, and centralized sibling-scanning logic within this helper to be reused by both check and checkSubTree flows.\nmisc: Added brief inline comments to clarify stopping conditions and intent of recursion; no new custom API calls introduced."
}