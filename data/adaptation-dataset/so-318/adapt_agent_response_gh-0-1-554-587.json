{
  "code": "/**\n\t * Converts an exact {@code double} value to a rational representation as a\n\t * numerator/denominator pair.\n\t * <p>\n\t * The conversion is exact and reflects the IEEE&nbsp;754 binary representation\n\t * of the given {@code double}. Subnormal values are handled correctly. If the\n\t * value is {@code NaN} or infinite, an {@link IllegalArgumentException} is thrown.\n\t * </p>\n\t *\n\t * @param value\n\t *            the {@code double} value to convert\n\t * @return a {@code BigInteger[]} of length&nbsp;2 where index&nbsp;0 is the\n\t *         numerator and index&nbsp;1 is the denominator\n\t * @throws IllegalArgumentException\n\t *             if {@code value} is {@code NaN} or infinite\n\t */\n\tpublic static BigInteger[] convertToFraction(double value) {\n\t\tfinal int exponent = Math.getExponent(value);\n\t\tif (exponent > Double.MAX_EXPONENT) {\n\t\t\t// The value is infinite or NaN.\n\t\t\tthrow new IllegalArgumentException(\"Illegal parameter 'value': \" + value);\n\t\t}\n\n\t\tfinal long significandMask = 0x000fffffffffffffL;\n\t\tfinal long implicitBit = 0x0010000000000000L;\n\n\t\tfinal long positiveSignificand;\n\t\tint adjustedExponent = exponent;\n\n\t\tif (adjustedExponent < Double.MIN_EXPONENT) {\n\t\t\t// The value is subnormal.\n\t\t\tadjustedExponent++;\n\t\t\tpositiveSignificand = Double.doubleToLongBits(value) & significandMask;\n\t\t} else {\n\t\t\tpositiveSignificand = (Double.doubleToLongBits(value) & significandMask) | implicitBit;\n\t\t}\n\n\t\tfinal BigInteger significand = BigInteger.valueOf(value < 0 ? -positiveSignificand : positiveSignificand);\n\t\tadjustedExponent -= 52; // Adjust the exponent for an integral significand.\n\n\t\tfinal BigInteger coefficient = BigInteger.ONE.shiftLeft(Math.abs(adjustedExponent));\n\t\tif (adjustedExponent >= 0) {\n\t\t\treturn new BigInteger[] { significand.multiply(coefficient), BigInteger.ONE };\n\t\t}\n\n\t\tfinal BigInteger gcd = significand.gcd(coefficient);\n\t\treturn new BigInteger[] { significand.divide(gcd), coefficient.divide(gcd) };\n\t}",
  "explanation": "code_hardening: Marked local variables as final where possible and clarified NaN/Infinity behavior in Javadoc without changing runtime checks.\nresolve_compilation_errors: Ensured usage of existing java.math.BigInteger only; no new imports or APIs were required.\nexception_handling: Preserved the original IllegalArgumentException behavior and documented it explicitly in the Javadoc with @throws.\nlogic_customization: none.\nrefactoring: Improved readability with consistent brace/whitespace formatting and replaced magic bit masks with clearly named local constants while keeping identical values and logic.\nmisc: Added comprehensive Javadoc describing the exact double-to-fraction conversion, parameters, return value, and edge cases; applied minor style adjustments consistent with surrounding code."
}