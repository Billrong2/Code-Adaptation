{
"code":"public String getForegroundApp(android.content.Context context) {\n    if (context == null) return null;\n    try {\n        // Pre-Lollipop: use ActivityManager.getRunningTasks\n        if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.LOLLIPOP) {\n            if (_activityManager == null) return null;\n            try {\n                java.util.List<android.app.ActivityManager.RunningTaskInfo> tasks = _activityManager.getRunningTasks(1);\n                if (tasks != null && !tasks.isEmpty() && tasks.get(0).topActivity != null) {\n                    return tasks.get(0).topActivity.getPackageName();\n                }\n            } catch (SecurityException ignored) {\n                return null;\n            }\n            return null;\n        }\n\n        // Lollipop and above: procfs heuristic\n        File procDir = new File(\"/proc\");\n        File[] pidDirs = procDir.listFiles();\n        if (pidDirs == null) return null;\n\n        String bestCmdline = null;\n        int bestOomAdj = Integer.MAX_VALUE;\n        int bestOomScore = Integer.MAX_VALUE;\n\n        for (File pidDir : pidDirs) {\n            if (pidDir == null || !pidDir.isDirectory()) continue;\n            String pidName = pidDir.getName();\n            int pid;\n            try {\n                pid = Integer.parseInt(pidName);\n            } catch (NumberFormatException e) {\n                continue;\n            }\n\n            try {\n                // Read cgroup\n                String cgroup = read(pidDir.getAbsolutePath() + \"/cgroup\");\n                if (cgroup == null || cgroup.length() == 0) continue;\n                if (cgroup.contains(\"bg_non_interactive\")) continue; // background\n\n                // Extract UID from cgroup\n                int uid = -1;\n                String[] lines = cgroup.split(\"\\n\");\n                for (String line : lines) {\n                    int idx = line.indexOf(\"uid_\");\n                    if (idx >= 0) {\n                        int start = idx + 4;\n                        int end = start;\n                        while (end < line.length() && Character.isDigit(line.charAt(end))) end++;\n                        try {\n                            uid = Integer.parseInt(line.substring(start, end));\n                        } catch (NumberFormatException ignored) {\n                        }\n                        break;\n                    }\n                }\n                if (uid < 0) continue;\n\n                // Derive appId and filter non-app/system processes\n                int appId = uid % AID_USER;\n                if (appId < AID_APP) continue;\n\n                // Read cmdline (package name)\n                String cmdline = read(pidDir.getAbsolutePath() + \"/cmdline\");\n                if (cmdline == null || cmdline.trim().length() == 0) continue;\n                cmdline = cmdline.replace('\\u0000', ' ').trim();\n                if (cmdline.startsWith(\"com.android.systemui\")) continue;\n\n                // Read oom scores\n                int oomAdj = Integer.MAX_VALUE;\n                int oomScore = Integer.MAX_VALUE;\n                try {\n                    String adjStr = read(pidDir.getAbsolutePath() + \"/oom_score_adj\");\n                    if (adjStr != null) oomAdj = Integer.parseInt(adjStr.trim());\n                } catch (Exception ignored) {\n                }\n                try {\n                    String scoreStr = read(pidDir.getAbsolutePath() + \"/oom_score\");\n                    if (scoreStr != null) oomScore = Integer.parseInt(scoreStr.trim());\n                } catch (Exception ignored) {\n                }\n\n                // Prefer foreground (oom_score_adj == 0), then lowest oom_score\n                boolean isBetter = false;\n                if (oomAdj == 0 && bestOomAdj != 0) {\n                    isBetter = true;\n                } else if (oomAdj == bestOomAdj && oomScore < bestOomScore) {\n                    isBetter = true;\n                }\n\n                if (isBetter) {\n                    bestOomAdj = oomAdj;\n                    bestOomScore = oomScore;\n                    bestCmdline = cmdline;\n                }\n            } catch (IOException | SecurityException ignored) {\n                // Skip unreadable or restricted entries\n            }\n        }\n        return bestCmdline;\n    } catch (Exception ignored) {\n        return null;\n    }\n}",
"explanation":"code_hardening: Added null checks for context, ActivityManager, directory listings, and procfs file contents; guarded numeric parsing for PID, UID, and oom values; skipped unreadable or malformed proc entries; relied on existing read() with controlled usage.\nresolve_compilation_errors: Introduced a public getForegroundApp(android.content.Context) method consistent with the existing ProcessHelper; used fully qualified Android/Java types to avoid import issues; avoided name conflicts with java.lang.Process by not referencing it.\nexception_handling: Replaced broad throws with localized try/catch blocks for SecurityException, IOException, and NumberFormatException; ensured per-PID failures do not abort scanning; method safely returns null on failure.\nlogic_customization: Replaced line-based parsing with Android-version branchingâ€”ActivityManager.getRunningTasks for pre-Lollipop and procfs heuristics for Lollipop+; iterated numeric /proc PIDs, read cgroup/cmdline/oom files, filtered background/system processes, ranked by oom_score_adj then oom_score, and returned the best cmdline as the foreground package.\nrefactoring: Removed all legacy per-process field extraction; simplified control flow into a single responsibility method; replaced magic UID logic with existing AID_APP/AID_USER constants.\nmisc: Updated inline comments to describe foreground-app detection; no additional logging added; new custom API calls used include android.app.ActivityManager#getRunningTasks(int), android.os.Build.VERSION, and procfs file access via java.io.File and existing read(String)."}