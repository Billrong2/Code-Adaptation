{
  "code": "public void resizeText(final int width, final int height) {\n        final CharSequence text = getText();\n        // Do not resize if there is no text or no vertical space\n        if (text == null || text.length() == 0 || height <= 0) {\n            mNeedsResize = false;\n            return;\n        }\n\n        // Get the text view's paint object\n        final TextPaint textPaint = getPaint();\n        if (textPaint == null) {\n            mNeedsResize = false;\n            return;\n        }\n\n        // Store the current text size\n        final float oldTextSize = textPaint.getTextSize();\n\n        // Determine starting text size (do not early-exit when mTextSize == 0)\n        float targetTextSize = mMaxTextSize > 0\n                ? Math.min(mTextSize, mMaxTextSize)\n                : mTextSize;\n        if (targetTextSize <= 0) {\n            targetTextSize = Math.max(oldTextSize, mMinTextSize);\n        }\n\n        // Measure required text height (height-only driven resizing)\n        int textHeight = getTextHeight(text, textPaint, width, targetTextSize);\n\n        // Reduce text size until it fits vertically or reaches minimum size\n        while (textHeight > height && targetTextSize > mMinTextSize) {\n            targetTextSize = Math.max(targetTextSize - 2, mMinTextSize);\n            textHeight = getTextHeight(text, textPaint, width, targetTextSize);\n        }\n\n        // If at minimum size and still too tall, optionally append ellipsis\n        if (mAddEllipsis && targetTextSize == mMinTextSize && textHeight > height && width > 0) {\n            final StaticLayout layout = new StaticLayout(text, textPaint, width,\n                    Alignment.ALIGN_NORMAL, mSpacingMult, mSpacingAdd, false);\n            layout.draw(sTextResizeCanvas);\n\n            final int lastLine = layout.getLineForVertical(height) - 1;\n            if (lastLine >= 0) {\n                final int start = layout.getLineStart(lastLine);\n                int end = layout.getLineEnd(lastLine);\n                float lineWidth = layout.getLineWidth(lastLine);\n                final float ellipsisWidth = textPaint.measureText(mEllipsis);\n\n                // Trim characters until the ellipsis fits on the last visible line\n                while (end > start && width < lineWidth + ellipsisWidth) {\n                    end--;\n                    lineWidth = textPaint.measureText(text.subSequence(start, end).toString());\n                }\n                setText(text.subSequence(0, end) + mEllipsis);\n            }\n        }\n\n        // Apply final text size and force default line spacing\n        textPaint.setTextSize(targetTextSize);\n        setLineSpacing(mSpacingAdd, mSpacingMult);\n\n        // Notify listener if registered\n        if (mTextResizeListener != null) {\n            mTextResizeListener.onTextResize(this, oldTextSize, targetTextSize);\n        }\n\n        // Reset force resize flag\n        mNeedsResize = false;\n    }",
  "explanation": "code_hardening: Added final modifiers to local variables where applicable, validated text, height, TextPaint, and width before use, and ensured resizing proceeds safely even when mTextSize is 0 by selecting a fallback starting size.\nresolve_compilation_errors: Removed all width-based fitting logic and references to undefined helpers such as getTextWidth and textWidth, updating the loop and measurements to rely solely on getTextHeight.\nexception_handling: none.\nlogic_customization: Changed the resize loop to depend only on textHeight > height and the minimum text size, removed the early exit for mTextSize == 0, and preserved ellipsis behavior so it triggers only when height still overflows at the minimum size (independent of width overflow).\nrefactoring: Simplified comments to reflect height-only resizing, clarified variable names, and reorganized the flow for readability after removing width-based logic.\nmisc: Minor formatting updates consistent with existing style; no new custom API calls were introduced."
}