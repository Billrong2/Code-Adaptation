{
  "code": "void resizeText(int width, int height) {\n        CharSequence text = getText();\n        if (text == null || text.length() == 0 || height <= 0 || width <= 0 || mTextSize <= 0) {\n            return;\n        }\n\n        final float STEP_SIZE_PX = 2f;\n\n        TextPaint textPaint = getPaint();\n        float oldTextSize = textPaint.getTextSize();\n\n        float targetTextSize = mMaxTextSize > 0 ? Math.min(mTextSize, mMaxTextSize) : mTextSize;\n\n        // Measure height only\n        int textHeight = getTextHeight(text, textPaint, width, targetTextSize);\n\n        // Decrease text size until it fits height or reaches minimum\n        while (textHeight > height && targetTextSize > mMinTextSize) {\n            targetTextSize = Math.max(targetTextSize - STEP_SIZE_PX, mMinTextSize);\n            textHeight = getTextHeight(text, textPaint, width, targetTextSize);\n        }\n\n        // Handle ellipsis when at minimum size and still too tall\n        if (mAddEllipsis && targetTextSize == mMinTextSize && textHeight > height) {\n            textPaint.setTextSize(targetTextSize);\n            StaticLayout layout = new StaticLayout(text, textPaint, width,\n                    Alignment.ALIGN_NORMAL, mSpacingMult, mSpacingAdd, false);\n\n            int lineCount = layout.getLineCount();\n            if (lineCount > 0) {\n                int lastLine = layout.getLineForVertical(height) - 1;\n                if (lastLine < 0) {\n                    // No line fits at all\n                    setText(\"\");\n                } else {\n                    int start = layout.getLineStart(lastLine);\n                    int end = layout.getLineEnd(lastLine);\n                    float lineWidth = layout.getLineWidth(lastLine);\n                    float ellipsisWidth = textPaint.measureText(mEllipsis);\n\n                    // Trim characters until ellipsis fits\n                    while (end > start && lineWidth + ellipsisWidth > width) {\n                        end--;\n                        lineWidth = textPaint.measureText(text.subSequence(start, end).toString());\n                    }\n                    setText(text.subSequence(0, end) + mEllipsis);\n                }\n            } else {\n                setText(\"\");\n            }\n        }\n\n        // Apply final text size and line spacing\n        textPaint.setTextSize(targetTextSize);\n        setLineSpacing(mSpacingAdd, mSpacingMult);\n\n        if (mTextResizeListener != null) {\n            mTextResizeListener.onTextResize(this, oldTextSize, targetTextSize);\n        }\n\n        mNeedsResize = false;\n    }",
  "explanation": "code_hardening: Added guards for null/empty text and non-positive width/height, verified StaticLayout has lines before accessing them, handled the case where no line fits by clearing text, and removed any measurement-time side effects. TextPaint size is explicitly set to the final value before exiting.\nresolve_compilation_errors: Removed all width-based fitting and getTextWidth references, relied only on existing fields and methods in the class, and used an in-scope StaticLayout constructor consistent with the rest of the file.\nexception_handling: none.\nlogic_customization: Updated the resize loop to consider only text height fitting, implemented safer ellipsis logic that clears text when no line fits and trims only the last fitting line otherwise, and removed the unnecessary canvas draw call during ellipsis computation.\nrefactoring: Reduced method visibility to package-private, replaced the magic decrement value with a named constant, and simplified variable naming to reflect height-only fitting behavior.\nmisc: Updated inline comments to reflect height-only resizing and safer ellipsis handling; no new custom API calls were introduced."
}