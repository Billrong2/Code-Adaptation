{
  "code": "public List<String> getResourcesFromDirectory(File rootDir, Pattern pattern) {\n        List<String> results = new ArrayList<>();\n        if (rootDir == null || pattern == null) {\n            return results;\n        }\n        if (!rootDir.exists() || !rootDir.isDirectory() || !rootDir.canRead()) {\n            log.warn(\"Cannot scan directory: {}\", rootDir);\n            return results;\n        }\n        // Track visited canonical paths to avoid infinite recursion (e.g., via symlinks)\n        java.util.Set<String> visited = new java.util.HashSet<>();\n        java.util.ArrayDeque<File> stack = new java.util.ArrayDeque<>();\n        stack.push(rootDir);\n        while (!stack.isEmpty()) {\n            File current = stack.pop();\n            String canonicalPath;\n            try {\n                canonicalPath = current.getCanonicalPath();\n            } catch (IOException ioe) {\n                log.warn(\"Failed to resolve canonical path for {}\", current, ioe);\n                continue;\n            }\n            if (!visited.add(canonicalPath)) {\n                continue; // already visited\n            }\n            File[] children;\n            try {\n                children = current.listFiles();\n            } catch (SecurityException se) {\n                log.warn(\"Access denied while listing directory {}\", current, se);\n                continue;\n            }\n            if (children == null) {\n                continue;\n            }\n            for (File child : children) {\n                if (child == null) {\n                    continue;\n                }\n                try {\n                    if (child.isDirectory()) {\n                        // Avoid following symbolic links to directories\n                        if (!java.nio.file.Files.isSymbolicLink(child.toPath())) {\n                            stack.push(child);\n                        }\n                    } else if (child.isFile()) {\n                        String fileCanonicalPath = child.getCanonicalPath();\n                        boolean accept = pattern.matcher(fileCanonicalPath).matches();\n                        if (accept) {\n                            results.add(fileCanonicalPath);\n                        }\n                    }\n                } catch (IOException ioe) {\n                    log.warn(\"I/O error processing file {}\", child, ioe);\n                    // continue with remaining files\n                }\n            }\n        }\n        return results;\n    }",
  "explanation": "code_hardening: Added null checks for the root directory and pattern, verified directory existence/readability, guarded against infinite recursion by tracking visited canonical paths, avoided following symbolic links, and handled potential nulls from listFiles.\nresolve_compilation_errors: Switched from Zip APIs to filesystem traversal using java.io.File and fully qualified java.nio.file.Files where needed; used generics consistently and relied on the existing SLF4J Logger field.\nexception_handling: Removed throwing of Error; caught IOExceptions and SecurityExceptions during canonical resolution, directory listing, and per-file access, logging warnings and continuing processing.\nlogic_customization: Replaced Zip entry iteration with recursive directory traversal, applied the Pattern to each fileâ€™s canonical filesystem path, aggregated matches across subdirectories, and implemented the method as a public instance method returning List<String>.\nrefactoring: Renamed parameters/locals to reflect directory-based scanning, returned List<String> explicitly, removed static behavior, and structured traversal iteratively for clarity and safety.\nmisc: Updated log messages to reflect directory scanning context and added minimal inline comments; new custom API calls used include java.nio.file.Files.isSymbolicLink(java.nio.file.Path)."
}