{
  "code": "@Override\npublic void onScrollStateChanged(int state) {\n    super.onScrollStateChanged(state);\n\n    if (state != SCROLL_STATE_IDLE) {\n        return;\n    }\n\n    RecyclerView.LayoutManager lm = getLayoutManager();\n    if (!(lm instanceof LinearLayoutManager)) {\n        return;\n    }\n\n    final LinearLayoutManager linearLayoutManager = (LinearLayoutManager) lm;\n\n    final int recyclerViewWidth = getMeasuredWidth();\n    if (recyclerViewWidth <= 0) {\n        return;\n    }\n\n    final int lastVisibleItemPosition = linearLayoutManager.findLastVisibleItemPosition();\n    final int firstVisibleItemPosition = linearLayoutManager.findFirstVisibleItemPosition();\n    if (lastVisibleItemPosition == RecyclerView.NO_POSITION\n            || firstVisibleItemPosition == RecyclerView.NO_POSITION) {\n        return;\n    }\n\n    final View lastView = linearLayoutManager.findViewByPosition(lastVisibleItemPosition);\n    final View firstView = linearLayoutManager.findViewByPosition(firstVisibleItemPosition);\n    if (lastView == null || firstView == null) {\n        return;\n    }\n\n    // distance we need to scroll, all relative to RecyclerView's own width\n    final int leftMargin = (recyclerViewWidth - lastView.getWidth()) / 2;\n    final int rightMargin = (recyclerViewWidth - firstView.getWidth()) / 2 + firstView.getWidth();\n    final int leftEdge = lastView.getLeft();\n    final int rightEdge = firstView.getRight();\n    final int scrollDistanceLeft = leftEdge - leftMargin;\n    final int scrollDistanceRight = rightMargin - rightEdge;\n\n    final int halfWidth = recyclerViewWidth / 2;\n\n    if (leftEdge > halfWidth) {\n        smoothScrollBy(-scrollDistanceRight, 0);\n    } else if (rightEdge < halfWidth) {\n        smoothScrollBy(scrollDistanceLeft, 0);\n    }\n}",
  "explanation": "code_hardening: Added guards for scroll state, layout manager type, measured width validity, adapter positions, and null views to prevent NullPointerException and invalid state access during fast scrolls or empty layouts.\nresolve_compilation_errors: Ensured use of RecyclerView.LayoutManager casting and RecyclerView.NO_POSITION, and relied only on methods available within RecyclerView (getMeasuredWidth, smoothScrollBy, getLayoutManager).\nexception_handling: none.\nlogic_customization: Replaced any screen-based width usage with the RecyclerViewâ€™s own measured width and updated all edge, margin, halfway, and scroll distance calculations to be relative to that width, preserving the original snapping behavior.\nrefactoring: Renamed screenWidth to recyclerViewWidth, introduced halfWidth to avoid repeated division, and clarified variable scoping with final locals.\nmisc: Added minimal early returns for readability and to match existing style; no new custom API calls were introduced."
}