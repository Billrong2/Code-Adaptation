{
  "code": "static public void unzipToDirectory(File zipFile, String outputDirectoryPath) throws ZipException, IOException {\n\tfinal int BUFFER_SIZE = 8192;\n\tif (zipFile == null || !zipFile.exists() || !zipFile.isFile()) {\n\t\tthrow new IOException(\"Zip file does not exist or is not a file: \" + zipFile);\n\t}\n\tif (outputDirectoryPath == null || outputDirectoryPath.trim().isEmpty()) {\n\t\tthrow new IOException(\"Output directory path must be specified\");\n\t}\n\tFile outputDirectory = new File(outputDirectoryPath);\n\tif (!outputDirectory.exists()) {\n\t\tif (!outputDirectory.mkdirs()) {\n\t\t\tthrow new IOException(\"Could not create output directory: \" + outputDirectory.getAbsolutePath());\n\t\t}\n\t}\n\tif (!outputDirectory.isDirectory()) {\n\t\tthrow new IOException(\"Output path is not a directory: \" + outputDirectory.getAbsolutePath());\n\t}\n\n\ttry (ZipFile zip = new ZipFile(zipFile)) {\n\t\tjava.util.Enumeration<? extends ZipEntry> entries = zip.entries();\n\t\twhile (entries.hasMoreElements()) {\n\t\t\tZipEntry entry = entries.nextElement();\n\t\t\tFile destFile = new File(outputDirectory, entry.getName());\n\t\t\tFile parentDir = destFile.getParentFile();\n\t\t\tif (parentDir != null && !parentDir.exists()) {\n\t\t\t\tparentDir.mkdirs();\n\t\t\t}\n\n\t\t\tif (!entry.isDirectory()) {\n\t\t\t\ttry (BufferedInputStream in = new BufferedInputStream(zip.getInputStream(entry));\n\t\t\t\t\t BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(destFile), BUFFER_SIZE)) {\n\t\t\t\t\tbyte[] buffer = new byte[BUFFER_SIZE];\n\t\t\t\t\tint count;\n\t\t\t\t\twhile ((count = in.read(buffer)) != -1) {\n\t\t\t\t\t\tout.write(buffer, 0, count);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
  "explanation": "code_hardening: Validated that the zip File exists and is a regular file, validated the output directory path, ensured the output directory (and parents) are created using mkdirs(), and used try-with-resources to guarantee ZipFile and all streams are closed to prevent resource leaks.\nresolve_compilation_errors: Introduced a File-based overload consistent with existing callers, used a typed Enumeration<? extends ZipEntry>, relied on fully qualified java.util.Enumeration where needed, and aligned parameter types with the existing String-based delegator.\nexception_handling: Preserved the throws ZipException, IOException contract expected by callers; validation failures now throw IOException with clear context, while IO errors during extraction propagate naturally.\nlogic_customization: Removed any filename-derived output path logic and console logging, always extracted into the explicitly provided output directory, iterated entries non-recursively, and intentionally skipped any special handling of nested .zip entries.\nrefactoring: Renamed locals for clarity (outputDirectory, BUFFER_SIZE), replaced magic numbers with a named constant, and simplified stream handling using try-with-resources for readability.\nmisc: none"
}