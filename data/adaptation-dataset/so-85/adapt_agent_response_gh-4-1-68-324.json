{
"code":"public final static String unescape_perl_string(final String oldstr) {\n\n    /*\n     * In contrast to fixing Java's broken regex charclasses,\n     * this one need be no bigger, as unescaping shrinks the string\n     * here, where in the other one, it grows it.\n     */\n\n    final StringBuffer newstr = new StringBuffer(oldstr.length());\n\n    boolean saw_backslash = false;\n\n    for (int i = 0; i < oldstr.length(); i++) {\n        int cp = oldstr.codePointAt(i);\n        if (cp > Character.MAX_VALUE) {\n            i++; /****WE HATES UTF-16! WE HATES IT FOREVERSES!!!****/\n        }\n\n        if (!saw_backslash) {\n            if (cp == '\\\\') {\n                saw_backslash = true;\n            } else {\n                newstr.append(Character.toChars(cp));\n            }\n            continue;\n        }\n\n        if (cp == '\\\\') {\n            saw_backslash = false;\n            newstr.append('\\\\');\n            newstr.append('\\\\');\n            continue;\n        }\n\n        switch (cp) {\n\n            case 'r':  newstr.append('\\r'); break;\n            case 'n':  newstr.append('\\n'); break;\n            case 'f':  newstr.append('\\f'); break;\n\n            /* PASS a \\b THROUGH!! */\n            case 'b':  newstr.append(\"\\\\b\"); break;\n\n            case 't':  newstr.append('\\t'); break;\n            case 'a':  newstr.append('\\007'); break;\n            case 'e':  newstr.append('\\033'); break;\n\n            case 'c': {\n                if (++i == oldstr.length()) { die(\"trailing \\\\c\"); }\n                cp = oldstr.codePointAt(i);\n                if (cp > 0x7f) { die(\"expected ASCII after \\\\c\"); }\n                newstr.append(Character.toChars(cp ^ 64));\n                break;\n            }\n\n            case '8':\n            case '9':\n                die(\"illegal octal digit\");\n                break;\n\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n                --i;\n                /* FALLTHROUGH */\n\n            case '0': {\n                if (i + 1 == oldstr.length()) {\n                    newstr.append(Character.toChars(0));\n                    break;\n                }\n                i++;\n                int digits = 0;\n                int j;\n                for (j = 0; j <= 2; j++) {\n                    if (i + j == oldstr.length()) {\n                        break;\n                    }\n                    int ch = oldstr.charAt(i + j);\n                    if (ch < '0' || ch > '7') {\n                        break;\n                    }\n                    digits++;\n                }\n                if (digits == 0) {\n                    --i;\n                    newstr.append('\\0');\n                    break;\n                }\n                int value;\n                try {\n                    value = Integer.parseInt(oldstr.substring(i, i + digits), 8);\n                } catch (NumberFormatException nfe) {\n                    die(\"invalid octal value for \\\\0 escape\");\n                    break;\n                }\n                newstr.append(Character.toChars(value));\n                i += digits - 1;\n                break;\n            }\n\n            case 'x': {\n                if (i + 2 > oldstr.length()) {\n                    die(\"string too short for \\\\x escape\");\n                }\n                i++;\n                boolean saw_brace = false;\n                if (oldstr.charAt(i) == '{') {\n                    i++;\n                    saw_brace = true;\n                }\n                int j;\n                for (j = 0; j < 8; j++) {\n                    if (!saw_brace && j == 2) {\n                        break;\n                    }\n                    int ch = oldstr.charAt(i + j);\n                    if (ch > 127) {\n                        die(\"illegal non-ASCII hex digit in \\\\x escape\");\n                    }\n                    if (saw_brace && ch == '}') { break; }\n                    if (!((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F'))) {\n                        die(String.format(\"illegal hex digit #%d '%c' in \\\\x\", ch, ch));\n                    }\n                }\n                if (j == 0) { die(\"empty braces in \\\\x{} escape\"); }\n                int value;\n                try {\n                    value = Integer.parseInt(oldstr.substring(i, i + j), 16);\n                } catch (NumberFormatException nfe) {\n                    die(\"invalid hex value for \\\\x escape\");\n                    break;\n                }\n                newstr.append(Character.toChars(value));\n                if (saw_brace) { j++; }\n                i += j - 1;\n                break;\n            }\n\n            case 'u': {\n                if (i + 4 > oldstr.length()) {\n                    die(\"string too short for \\\\u escape\");\n                }\n                i++;\n                int j;\n                for (j = 0; j < 4; j++) {\n                    if (oldstr.charAt(i + j) > 127) {\n                        die(\"illegal non-ASCII hex digit in \\\\u escape\");\n                    }\n                }\n                int value;\n                try {\n                    value = Integer.parseInt(oldstr.substring(i, i + j), 16);\n                } catch (NumberFormatException nfe) {\n                    die(\"invalid hex value for \\\\u escape\");\n                    break;\n                }\n                newstr.append(Character.toChars(value));\n                i += j - 1;\n                break;\n            }\n\n            case 'U': {\n                if (i + 8 > oldstr.length()) {\n                    die(\"string too short for \\\\U escape\");\n                }\n                i++;\n                int j;\n                for (j = 0; j < 8; j++) {\n                    if (oldstr.charAt(i + j) > 127) {\n                        die(\"illegal non-ASCII hex digit in \\\\U escape\");\n                    }\n                }\n                int value;\n                try {\n                    value = Integer.parseInt(oldstr.substring(i, i + j), 16);\n                } catch (NumberFormatException nfe) {\n                    die(\"invalid hex value for \\\\U escape\");\n                    break;\n                }\n                newstr.append(Character.toChars(value));\n                i += j - 1;\n                break;\n            }\n\n            default:\n                newstr.append('\\\\');\n                newstr.append(Character.toChars(cp));\n                break;\n        }\n        saw_backslash = false;\n    }\n\n    if (saw_backslash) {\n        newstr.append('\\\\');\n    }\n\n    return newstr.toString();\n}",
"explanation":"code_hardening: Added the final modifier to the method parameter oldstr as requested and marked the StringBuffer local variable newstr as final since it is not reassigned. No additional null checks were added to avoid changing runtime behavior.\nresolve_compilation_errors: No compilation issues remained after adaptation; the existing die(String) method in the target class is used directly and all referenced classes are from java.lang.\nexception_handling: Preserved the existing exception strategy by continuing to delegate all fatal error conditions to the die(String) method, which throws IllegalArgumentException.\nlogic_customization: none.\nrefactoring: Applied minor formatting and whitespace normalization, simplified some switch case layouts, and removed redundant comments without altering control flow or semantics.\nmisc: Minor readability improvements only; no new APIs or helpers were introduced."}