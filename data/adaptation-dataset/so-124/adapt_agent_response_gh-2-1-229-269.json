{
  "code": "/**\n     * Discovers external storage mount paths by parsing the output of the system \"mount\" command.\n     * <p>\n     * The returned list preserves discovery (insertion) order and may contain duplicates. This allows\n     * callers to reliably select \"the first\" mounted SD card path when multiple mounts are present.\n     * </p>\n     *\n     * @return An ordered {@link java.util.ArrayList} of mount paths (possibly empty, never null).\n     */\n    public static ArrayList<String> getExternalMounts() {\n        final ArrayList<String> mounts = new ArrayList<String>();\n        final String mountRegex = \"(?i).*vold.*(vfat|ntfs|exfat|fat32|ext3|ext4).*rw.*\";\n        final String mountCommand = \"mount\";\n\n        Process process = null;\n        try {\n            process = new ProcessBuilder().command(mountCommand)\n                    .redirectErrorStream(true)\n                    .start();\n\n            // Read process output safely and in order\n            try (java.io.InputStream is = process.getInputStream();\n                 java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(is))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    // Skip asec mounts\n                    if (line.toLowerCase(Locale.US).contains(\"asec\")) {\n                        continue;\n                    }\n\n                    if (line.matches(mountRegex)) {\n                        String[] parts = line.split(\" \");\n                        for (String part : parts) {\n                            if (part != null && part.startsWith(\"/\")\n                                    && !part.toLowerCase(Locale.US).contains(\"vold\")) {\n                                mounts.add(part);\n                            }\n                        }\n                    }\n                }\n            }\n\n            try {\n                process.waitFor();\n            } catch (InterruptedException ie) {\n                // Restore interrupt status and continue with whatever data was read\n                Thread.currentThread().interrupt();\n            }\n        } catch (IOException ioe) {\n            Log.e(LOG_TOKEN, \"Error while discovering external mounts\", ioe);\n        }\n\n        return mounts;\n    }",
  "explanation": "code_hardening: Replaced manual stream handling with try-with-resources for the process InputStream, used a BufferedReader to read complete lines safely, avoided string concatenation by processing lines incrementally, added null-safe checks, and preserved locale-safe string comparisons.\nresolve_compilation_errors: Changed the return type to ArrayList<String>, updated local declarations and instantiation accordingly, and ensured compatibility with existing callers (e.g., getDumpDirectory) that expect an ArrayList.\nexception_handling: Narrowed exception handling to IOException and InterruptedException; restored the thread interrupt flag when interrupted and logged IO failures using the existing Android Log utility.\nlogic_customization: Switched from a Set to a List to preserve insertion order and allow duplicates, added mounts in discovery order without de-duplication, and retained the original filtering/regex logic while making it compatible with list semantics.\nrefactoring: Renamed variables for clarity (out → mounts, reg → mountRegex), extracted command and regex into local constants, and simplified nested conditionals during line parsing.\nmisc: Added descriptive JavaDoc explaining SD card path discovery, ordered return semantics, and usage; applied minor formatting cleanup consistent with the surrounding FileUtil style. No new custom API calls were introduced."
}