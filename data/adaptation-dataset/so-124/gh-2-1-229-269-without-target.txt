package org.commcare.utils;

import android.annotation.SuppressLint;
import android.content.ContentUris;
import android.content.Context;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.net.Uri;
import android.os.Build;
import android.os.Environment;
import android.provider.DocumentsContract;
import android.provider.MediaStore;
import android.util.Log;
import android.util.Pair;

import org.commcare.logging.AndroidLogger;
import org.commcare.resources.model.MissingMediaException;
import org.commcare.resources.model.Resource;
import org.javarosa.core.io.StreamsUtil;
import org.javarosa.core.reference.InvalidReferenceException;
import org.javarosa.core.reference.Reference;
import org.javarosa.core.reference.ReferenceManager;
import org.javarosa.core.services.Logger;
import org.javarosa.core.util.PropertyUtils;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.math.BigInteger;
import java.nio.channels.FileChannel;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Locale;
import java.util.Properties;
import java.util.Vector;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;


public class FileUtil {

    private static final int WARNING_SIZE = 3000;

    private static final String LOG_TOKEN = "cc-file-util";

    public static boolean deleteFileOrDir(String path) {
        return deleteFileOrDir(new File(path));
    }

    
    public static boolean deleteFileOrDir(File f) {
        if (!f.exists()) {
            return true;
        }
        if (f.isDirectory()) {
            for (File child : f.listFiles()) {
                if (!deleteFileOrDir(child)) {
                    return false;
                }
            }
        }
        return f.delete();
    }

    public static boolean cleanFilePath(String fullPath, String extendedPath) {
        

        
        if (extendedPath == null) {
            return true;
        }

        
        if (!fullPath.contains(extendedPath)) {
            return true;
        }

        
        File terminal = new File(fullPath.replace(extendedPath, ""));

        File walker = new File(fullPath);

        
        while (walker != null && !terminal.equals(walker)) {
            if (walker.isDirectory()) {
                
                if (walker.list().length == 0) {
                    if (!walker.delete()) {
                        
                        Log.w("cleanup", "couldn't delete directory " + walker.getAbsolutePath() + " while cleaning up file paths");
                        
                    }
                }
            }
            walker = walker.getParentFile();
        }
        return true;
    }

    private static final String illegalChars = "'*','+'~|<> !?:./\\";

    public static String SanitizeFileName(String input) {
        for (char c : illegalChars.toCharArray()) {
            input = input.replace(c, '_');
        }
        return input;
    }

    public static void copyFile(File oldPath, File newPath) throws IOException {
        if (oldPath.exists()) {
            if (newPath.isDirectory()) {
                newPath = new File(newPath, oldPath.getName());
            }

            FileChannel src;
            src = new FileInputStream(oldPath).getChannel();
            FileChannel dst = new FileOutputStream(newPath).getChannel();
            dst.transferFrom(src, 0, src.size());
            src.close();
            dst.close();
        } else {
            Log.e(LOG_TOKEN, "Source file does not exist: " + oldPath.getAbsolutePath());
        }

    }

    public static void copyFile(File oldPath, File newPath, Cipher oldRead, Cipher newWrite) throws IOException {

        if (!newPath.createNewFile()) {
            throw new IOException("Couldn't create new file @ " + newPath.toString());
        }

        InputStream is = null;
        OutputStream os = null;
        try {

            is = new FileInputStream(oldPath);
            if (oldRead != null) {
                is = new CipherInputStream(is, oldRead);
            }

            os = new FileOutputStream(newPath);
            if (newWrite != null) {
                os = new CipherOutputStream(os, newWrite);
            }

            StreamsUtil.writeFromInputToOutputUnmanaged(is, os);
        } finally {
            try {
                if (is != null) {
                    is.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

            try {
                if (os != null) {
                    os.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    
    public static File getNewFileLocation(File f, String slug, boolean removeExisting) {
        if (slug == null) {
            slug = PropertyUtils.genGUID(5);
        }
        String name = f.getName();

        int lastDot = name.lastIndexOf(".");
        if (lastDot != -1) {
            String prefix = name.substring(0, lastDot);
            String postfix = name.substring(lastDot);

            name = prefix + "_" + slug + postfix;
        } else {
            name = name + "_" + slug;
        }

        File newLocation = new File(f.getParent() + File.separator + name);
        if (newLocation.exists()) {
            if (removeExisting) {
                deleteFileOrDir(newLocation);
            } else {
                return getNewFileLocation(newLocation, null, removeExisting);
            }
        }
        return newLocation;
    }

    public static void copyFileDeep(File oldFolder, File newFolder) throws IOException {
        
        newFolder.mkdir();

        if (oldFolder.listFiles() != null) {
            
            for (File oldFile : oldFolder.listFiles()) {
                File newFile = new File(newFolder.getPath() + File.separator + oldFile.getName());
                if (oldFile.isDirectory()) {
                    copyFileDeep(oldFile, newFile);
                } else {
                    FileUtil.copyFile(oldFile, newFile);
                }
            }
        }
    }

        // TODO


    
    public static String getGlobalStringUri(String fileLocation) {
        return "file://" + fileLocation;
    }

    public static void checkReferenceURI(Resource r, String URI, Vector<MissingMediaException> problems) throws IOException {
        try {
            Reference mRef = ReferenceManager.instance().DeriveReference(URI);

            if (!mRef.doesBinaryExist()) {
                String mLocalReference = mRef.getLocalURI();
                problems.addElement(new MissingMediaException(r, "Missing external media: " + mLocalReference, mLocalReference));
            }

        } catch (InvalidReferenceException ire) {
            
        }
    }

    public static boolean referenceFileExists(String uri) {
        if (uri != null && !uri.equals("")) {
            try {
                return new File(ReferenceManager.instance().DeriveReference(uri).getLocalURI()).exists();
            } catch (InvalidReferenceException e) {
                e.printStackTrace();
            }
        }
        return false;
    }


    
    public static void ensureFilePathExists(File f) {
        File folder = f.getParentFile();
        if (folder != null) {
            
            folder.mkdirs();
        }
    }

    
    @SuppressLint("NewApi")
    private static String getExternalDirectoryKitKat(Context c) {
        File[] extMounts = c.getExternalFilesDirs(null);
        

        if (extMounts.length < 2) {
            return null;
        }

        

        File sdRoot = extMounts[1];

        
        if (sdRoot == null) {
            return null;
        }

        return sdRoot.getAbsolutePath() + "/Android/data/org.commcare.dalvik";
    }

    
    public static String getDumpDirectory(Context c) {
        if (android.os.Build.VERSION.SDK_INT >= 19) {
            return getExternalDirectoryKitKat(c);
        } else {
            ArrayList<String> mArrayList = getExternalMounts();
            if (mArrayList.size() > 0) {
                return getExternalMounts().get(0);
            }
            return null;
        }
    }

    public static Properties loadProperties(File file) throws IOException{
        Properties prop = new Properties();
        InputStream input = null;
        try {
            input = new FileInputStream(file);
            prop.load(input);
            return prop;
        } finally {
            if (input != null) {
                try {
                    input.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static boolean createFolder(String path) {
        boolean made = true;
        File dir = new File(path);
        if (!dir.exists()) {
            made = dir.mkdirs();
        }
        return made;
    }

    public static String getMd5Hash(File file) {
        try {
            
            MessageDigest md = MessageDigest.getInstance("MD5");
            int chunkSize = 256;

            byte[] chunk = new byte[chunkSize];

            
            long lLength = file.length();

            if (lLength > Integer.MAX_VALUE) {
                Log.e(LOG_TOKEN, "File " + file.getName() + "is too large");
                return null;
            }

            int length = (int)lLength;

            InputStream is;
            is = new FileInputStream(file);

            int l;
            for (l = 0; l + chunkSize < length; l += chunkSize) {
                is.read(chunk, 0, chunkSize);
                md.update(chunk, 0, chunkSize);
            }

            int remaining = length - l;
            if (remaining > 0) {
                is.read(chunk, 0, remaining);
                md.update(chunk, 0, remaining);
            }
            byte[] messageDigest = md.digest();

            BigInteger number = new BigInteger(1, messageDigest);
            String md5 = number.toString(16);
            while (md5.length() < 32)
                md5 = "0" + md5;
            is.close();
            return md5;

        } catch (NoSuchAlgorithmException e) {
            Log.e("MD5", e.getMessage());
            return null;

        } catch (FileNotFoundException e) {
            Log.e("No Cache File", e.getMessage());
            return null;
        } catch (IOException e) {
            Log.e("Problem reading file", e.getMessage());
            return null;
        }
    }

    public static String getExtension(String filePath) {
        if (filePath.contains(".")) {
            return last(filePath.split("\\."));
        }
        return "";
    }

    
    private static String last(String[] strings) {
        return strings[strings.length - 1];
    }

    
    public static boolean scaleAndSaveImage(File originalImage, String finalFilePath, int maxDimen) {
        String extension = getExtension(originalImage.getAbsolutePath());
        ImageType type = ImageType.fromExtension(extension);
        if (type == null) {
            
            Log.i(LOG_TOKEN, "Could not scale image " + originalImage.getAbsolutePath() + " due to incompatible extension");
            return false;
        }

        Pair<Bitmap, Boolean> bitmapAndScaledBool = MediaUtil.inflateImageSafe(originalImage.getAbsolutePath());
        if (bitmapAndScaledBool.second) {
            Logger.log(AndroidLogger.TYPE_FORM_ENTRY,
                    "An image captured during form entry was too large to be processed at its original size, and had to be downsized");
        }
        Bitmap scaledBitmap = getBitmapScaledByMaxDimen(bitmapAndScaledBool.first, maxDimen);
        if (scaledBitmap != null) {
            
            FileOutputStream out = null;
            try {
                out = new FileOutputStream(finalFilePath);
                scaledBitmap.compress(type.getCompressFormat(), 100, out);
                return true;
            } catch (Exception e) {
                e.printStackTrace();
                return false;
            } finally {
                try {
                    if (out != null) {
                        out.close();
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return false;
    }

    
    private static Bitmap getBitmapScaledByMaxDimen(Bitmap originalBitmap, int maxDimen) {
        if (originalBitmap == null) {
            return null;
        }
        int height = originalBitmap.getHeight();
        int width = originalBitmap.getWidth();
        int sideToScale = Math.max(height, width);
        int otherSide = Math.min(height, width);

        if (sideToScale > maxDimen) {
            
            double aspectRatio = ((double)otherSide) / sideToScale;
            sideToScale = maxDimen;
            otherSide = (int)Math.floor(maxDimen * aspectRatio);
            if (width > height) {
                
                return Bitmap.createScaledBitmap(originalBitmap, sideToScale, otherSide, false);
            } else {
                return Bitmap.createScaledBitmap(originalBitmap, otherSide, sideToScale, false);
            }
        } else {
            return null;
        }
    }

    public static boolean isFileOversized(File mf) {
        double length = getFileSize(mf);
        return length > WARNING_SIZE;
    }

    public static double getFileSize(File mf) {
        return mf.length() / 1024;
    }

    public static double getFileSizeInMegs(File mf) {
        return bytesToMeg(mf.length());
    }

    private static final long MEGABYTE_IN_BYTES = 1024L * 1024L;

    public static long bytesToMeg(long bytes) {
        return bytes / MEGABYTE_IN_BYTES;
    }

    public static boolean isFileTooLargeToUpload(File mf) {
        return mf.length() > FormUploadUtil.MAX_BYTES;
    }

    
    @SuppressLint("NewApi")
    public static String getPath(final Context context, final Uri uri) {
        final boolean isKitKat = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;

        
        if (isKitKat && DocumentsContract.isDocumentUri(context, uri)) {
            
            if (isExternalStorageDocument(uri)) {
                final String docId = DocumentsContract.getDocumentId(uri);
                final String[] split = docId.split(":");
                final String type = split[0];

                if ("primary".equalsIgnoreCase(type)) {
                    return Environment.getExternalStorageDirectory() + "/" + split[1];
                }

                
            }
            
            else if (isDownloadsDocument(uri)) {

                final String id = DocumentsContract.getDocumentId(uri);
                final Uri contentUri = ContentUris.withAppendedId(
                        Uri.parse("content://downloads/public_downloads"), Long.valueOf(id));

                return getDataColumn(context, contentUri, null, null);
            }
            
            else if (isMediaDocument(uri)) {
                final String docId = DocumentsContract.getDocumentId(uri);
                final String[] split = docId.split(":");
                final String type = split[0];

                Uri contentUri = null;
                if ("image".equals(type)) {
                    contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
                } else if ("video".equals(type)) {
                    contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;
                } else if ("audio".equals(type)) {
                    contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
                }

                final String selection = "_id=?";
                final String[] selectionArgs = new String[]{
                        split[1]
                };

                return getDataColumn(context, contentUri, selection, selectionArgs);
            }
        }
        
        else if ("content".equalsIgnoreCase(uri.getScheme())) {

            
            if (isGooglePhotosUri(uri))
                return uri.getLastPathSegment();

            return getDataColumn(context, uri, null, null);
        }
        
        else if ("file".equalsIgnoreCase(uri.getScheme())) {
            return uri.getPath();
        }

        return null;
    }

    
    private static String getDataColumn(Context context, Uri uri, String selection,
                                        String[] selectionArgs) {

        Cursor cursor = null;
        final String column = "_data";
        final String[] projection = {
                column
        };

        try {
            cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs,
                    null);
            if (cursor != null && cursor.moveToFirst()) {
                final int index = cursor.getColumnIndexOrThrow(column);
                return cursor.getString(index);
            }
        } finally {
            if (cursor != null)
                cursor.close();
        }
        return null;
    }

    
    private static boolean isExternalStorageDocument(Uri uri) {
        return "com.android.externalstorage.documents".equals(uri.getAuthority());
    }

    
    private static boolean isDownloadsDocument(Uri uri) {
        return "com.android.providers.downloads.documents".equals(uri.getAuthority());
    }

    
    private static boolean isMediaDocument(Uri uri) {
        return "com.android.providers.media.documents".equals(uri.getAuthority());
    }

    
    private static boolean isGooglePhotosUri(Uri uri) {
        return "com.google.android.apps.photos.content".equals(uri.getAuthority());
    }
}
