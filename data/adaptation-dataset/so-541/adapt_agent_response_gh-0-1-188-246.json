{
  "code": "public JCheckBoxTree() {\n        super();\n        // Disable default selection behavior; checking is handled internally\n        setSelectionModel(new javax.swing.tree.DefaultTreeSelectionModel() {{\n            setSelectionMode(javax.swing.tree.TreeSelectionModel.SINGLE_TREE_SELECTION);\n            clearSelection();\n        }});\n        setToggleClickCount(0); // disable default double-click expand/toggle\n\n        // Install custom renderer for checkbox display\n        setCellRenderer(new CheckBoxCellRenderer());\n\n        // Initialize checking state for an empty/default model\n        resetCheckingState(getModel() != null ? (javax.swing.tree.DefaultMutableTreeNode) getModel().getRoot() : null);\n\n        // Custom mouse handling for checkbox toggling\n        final JCheckBoxTree checkBoxTree = this;\n        addMouseListener(new java.awt.event.MouseListener() {\n            @Override\n            public void mouseClicked(java.awt.event.MouseEvent e) {\n                try {\n                    if (e == null) {\n                        return;\n                    }\n                    int row = checkBoxTree.getRowForLocation(e.getX(), e.getY());\n                    if (row < 0) {\n                        return;\n                    }\n                    javax.swing.tree.TreePath path = checkBoxTree.getPathForRow(row);\n                    if (path == null) {\n                        return;\n                    }\n                    CheckedNode cn = nodesCheckingState.get(path);\n                    if (cn == null || !cn.isCheckBoxEnabled) {\n                        return;\n                    }\n                    // Toggle selection state\n                    boolean newState = !cn.isSelected;\n                    // Propagate to descendants\n                    checkSubTree(path, newState);\n                    // Update ancestors\n                    updatePredecessorsWithCheckMode(path, newState);\n                    // Fire internal check-change event\n                    fireCheckChangeEvent(new CheckChangeEvent(checkBoxTree));\n                    // Repaint to reflect updated states\n                    checkBoxTree.repaint();\n                } catch (ClassCastException ex) {\n                    // Ignore invalid node types to keep UI responsive\n                } catch (RuntimeException ex) {\n                    // Defensive: avoid breaking UI interaction on unexpected errors\n                }\n            }\n\n            @Override public void mousePressed(java.awt.event.MouseEvent e) {}\n            @Override public void mouseReleased(java.awt.event.MouseEvent e) {}\n            @Override public void mouseEntered(java.awt.event.MouseEvent e) {}\n            @Override public void mouseExited(java.awt.event.MouseEvent e) {}\n        });\n    }",
  "explanation": "code_hardening: Added null checks for mouse events, rows, and TreePath resolution; guarded against invalid indices; ensured repaint and event firing occur only after safe state changes; relied on existing CheckedNode enablement checks.\nresolve_compilation_errors: Introduced a proper JCheckBoxTree constructor instead of a JFrame-based Main constructor; removed all JFrame/container logic; initialized renderer, mouse listener, and checking state using existing project types and fully qualified names where needed.\nexception_handling: Wrapped mouse-click processing in try/catch to handle ClassCastException and unexpected RuntimeException defensively, preventing UI lockups while keeping state consistent.\nlogic_customization: Disabled default tree selection and double-click behavior; installed the custom checkbox cell renderer; implemented custom mouse handling to toggle only enabled checkboxes; propagated state changes to descendants and recomputed ancestors; fired the internal CheckChangeEvent and repainted, fully encapsulating behavior within the tree component.\nrefactoring: Moved former frame-level initialization responsibilities into the component constructor; clarified local naming (checkBoxTree); structured logic to clearly separate hit-testing, toggling, propagation, and notification.\nmisc: Triggered repaint after updates; added minimal comments to reflect component-centric design. New custom API calls used: none (relied solely on existing methods and inner types within org.zaproxy.zap.view.JCheckBoxTree)."
}