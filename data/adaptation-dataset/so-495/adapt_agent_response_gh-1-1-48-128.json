{
"code":"public static String globToRegex(final String line) {\n    if (line == null) {\n        return \"\";\n    }\n    String trimmed = line.trim();\n    int strLen = trimmed.length();\n    StringBuilder sb = new StringBuilder(strLen);\n    boolean escaping = false;\n    int inCurlies = 0;\n    for (char currentChar : trimmed.toCharArray()) {\n        switch (currentChar) {\n        case '*':\n            if (escaping) {\n                sb.append(\"\\\\*\");\n            } else {\n                sb.append(\".*\");\n            }\n            escaping = false;\n            break;\n        case '?':\n            if (escaping) {\n                sb.append(\"\\\\?\");\n            } else {\n                sb.append('.');\n            }\n            escaping = false;\n            break;\n        case '.':\n        case '(':\n        case ')':\n        case '+':\n        case '|':\n        case '^':\n        case '$':\n        case '@':\n        case '%':\n            sb.append('\\\\');\n            sb.append(currentChar);\n            escaping = false;\n            break;\n        case '\\\\':\n            if (escaping) {\n                sb.append(\"\\\\\\\\\");\n                escaping = false;\n            } else {\n                escaping = true;\n            }\n            break;\n        case '{':\n            if (escaping) {\n                sb.append(\"\\\\{\");\n            } else {\n                sb.append('(');\n                inCurlies++;\n            }\n            escaping = false;\n            break;\n        case '}':\n            if (inCurlies > 0 && !escaping) {\n                sb.append(')');\n                inCurlies--;\n            } else if (escaping) {\n                sb.append(\"\\\\}\");\n            } else {\n                sb.append(\"}\");\n            }\n            escaping = false;\n            break;\n        case ',':\n            if (inCurlies > 0 && !escaping) {\n                sb.append('|');\n            } else if (escaping) {\n                sb.append(\"\\\\,\");\n            } else {\n                sb.append(\",\");\n            }\n            break;\n        default:\n            escaping = false;\n            sb.append(currentChar);\n        }\n    }\n    return sb.toString();\n}",
"explanation":"code_hardening: Added a null check for the input and return an empty string for null; kept whitespace trimming; used local variables with limited scope and avoided side effects.\nresolve_compilation_errors: Removed all references to logging and instance state; made the method public static so it can be called without an instance and compiles within the utility class.\nexception_handling: none.\nlogic_customization: Removed the logic that stripped leading and trailing asterisks; all '*' characters are now consistently translated to the regex \".*\" when not escaped, preserving leading and trailing wildcards while keeping the original glob-to-regex behavior otherwise unchanged.\nrefactoring: Renamed the method to globToRegex and converted it from a private instance method to a public static utility method suitable for RegexUtil.\nmisc: No logging or other side effects remain; behavior is documented implicitly by the utility-style signature. New custom API calls: none."}