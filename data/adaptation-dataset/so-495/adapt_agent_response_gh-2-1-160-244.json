{
  "code": "public static @Nonnull String convertGlobToRegEx(@Nonnull String glob) {\n    String line = glob.trim();\n    if (line.isEmpty()) {\n        return \"\";\n    }\n    int strLen = line.length();\n    // Remove beginning and ending * globs because they're useless\n    if (line.startsWith(\"*\")) {\n        line = line.substring(1);\n        strLen--;\n    }\n    if (strLen > 0 && line.endsWith(\"*\")) {\n        line = line.substring(0, strLen - 1);\n        strLen--;\n    }\n    StringBuilder regex = new StringBuilder(Math.max(0, strLen));\n    boolean escaping = false;\n    int inCurlies = 0;\n    for (char currentChar : line.toCharArray()) {\n        boolean wasEscaping = escaping;\n        escaping = false; // reset once per iteration; only carried over by backslash\n        if (!wasEscaping && currentChar == '\\\\') {\n            escaping = true;\n            continue; // apply escape to exactly the next character\n        }\n        switch (currentChar) {\n            case '*':\n                if (wasEscaping)\n                    regex.append(\"\\\\*\");\n                else\n                    regex.append(\".*\");\n                break;\n            case '?':\n                if (wasEscaping)\n                    regex.append(\"\\\\?\");\n                else\n                    regex.append('.');\n                break;\n            case '.':\n            case '(':\n            case ')':\n            case '+':\n            case '|':\n            case '^':\n            case '$':\n            case '@':\n            case '%':\n                regex.append('\\\\').append(currentChar);\n                break;\n            case '{':\n                if (wasEscaping) {\n                    regex.append(\"\\\\{\");\n                } else {\n                    regex.append('(');\n                    inCurlies++;\n                }\n                break;\n            case '}':\n                if (inCurlies > 0 && !wasEscaping) {\n                    regex.append(')');\n                    inCurlies--;\n                } else if (wasEscaping) {\n                    regex.append(\"\\\\}\");\n                } else {\n                    regex.append('}');\n                }\n                break;\n            case ',':\n                if (inCurlies > 0 && !wasEscaping) {\n                    regex.append('|');\n                } else if (wasEscaping) {\n                    regex.append(\"\\\\,\");\n                } else {\n                    regex.append(',');\n                }\n                break;\n            default:\n                if (wasEscaping)\n                    regex.append('\\\\');\n                regex.append(currentChar);\n        }\n    }\n    return regex.toString();\n}",
  "explanation": "code_hardening: Made the method public static, added @Nonnull annotations to the parameter and return type, trimmed input defensively, and handled the empty-string case safely.\nresolve_compilation_errors: Removed the undefined LOG usage entirely and relied only on existing javax.annotation.Nonnull already present in the codebase; no new imports required.\nexception_handling: none.\nlogic_customization: Reworked escaping so the escape state is reset once per loop iteration and only carried over when a backslash is encountered; used a continue after handling '\\\\' so escaping applies to exactly the next character while preserving existing glob-to-regex semantics (*, ?, regex metacharacter escaping, and {a,b} -> (a|b)).\nrefactoring: Renamed locals for clarity (glob/line to regex builder naming), simplified control flow around escaping with a wasEscaping flag, and clarified comments.\nmisc: Removed logging as requested and kept formatting consistent with the surrounding utility class; no new custom API calls were introduced (none)."
}