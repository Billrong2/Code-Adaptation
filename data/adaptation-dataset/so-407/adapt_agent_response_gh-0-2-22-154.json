{
  "code": "public static boolean save(Bitmap orgBitmap, String filePath) throws IOException {\n    long start = System.currentTimeMillis();\n\n    if (orgBitmap == null) {\n        return false;\n    }\n\n    if (filePath == null) {\n        return false;\n    }\n\n    boolean isSaveSuccess = true;\n\n    // image size\n    int width = orgBitmap.getWidth();\n    int height = orgBitmap.getHeight();\n\n    // image dummy data size\n    // reason : the amount of bytes per image row must be a multiple of 4 (requirements of bmp format)\n    byte[] dummyBytesPerRow = null;\n    boolean hasDummy = false;\n    int rowWidthInBytes = BYTE_PER_PIXEL * width; // source image width * number of bytes to encode one pixel.\n\n    if (rowWidthInBytes % BMP_WIDTH_OF_TIMES > 0) {\n        hasDummy = true;\n        // the number of dummy bytes we need to add on each row\n        dummyBytesPerRow = new byte[BMP_WIDTH_OF_TIMES - (rowWidthInBytes % BMP_WIDTH_OF_TIMES)];\n        // just fill an array with the dummy bytes we need to append at the end of each row\n        for (int i = 0; i < dummyBytesPerRow.length; i++) {\n            dummyBytesPerRow[i] = (byte) 0xFF;\n        }\n    }\n\n    // an array to receive the pixels from the source image\n    int[] pixels = new int[width * height];\n\n    // the number of bytes used in the file to store raw image data (excluding file headers)\n    int imageSize = (rowWidthInBytes + (hasDummy ? dummyBytesPerRow.length : 0)) * height;\n    // file headers size\n    int imageDataOffset = 0x36;\n\n    // final size of the file\n    int fileSize = imageSize + imageDataOffset;\n\n    // Android Bitmap Image Data\n    orgBitmap.getPixels(pixels, 0, width, 0, 0, width, height);\n\n    ByteBuffer buffer = ByteBuffer.allocate(fileSize);\n\n    /**\n     * BITMAP FILE HEADER Write Start\n     */\n    buffer.put((byte) 0x42);\n    buffer.put((byte) 0x4D);\n\n    // size\n    buffer.put(writeInt(fileSize));\n\n    // reserved\n    buffer.put(writeShort((short) 0));\n    buffer.put(writeShort((short) 0));\n\n    // image data start offset\n    buffer.put(writeInt(imageDataOffset));\n\n    /** BITMAP FILE HEADER Write End */\n\n    // *******************************************\n\n    /** BITMAP INFO HEADER Write Start */\n    // size\n    buffer.put(writeInt(0x28));\n\n    // width, height\n    // if we add 3 dummy bytes per row : it means we add a pixel (and the image width is modified.\n    buffer.put(writeInt(width + (hasDummy ? (dummyBytesPerRow.length == 3 ? 1 : 0) : 0)));\n    buffer.put(writeInt(height));\n\n    // planes\n    buffer.put(writeShort((short) 1));\n\n    // bit count\n    buffer.put(writeShort((short) 24));\n\n    // bit compression\n    buffer.put(writeInt(0));\n\n    // image data size\n    buffer.put(writeInt(imageSize));\n\n    // horizontal resolution in pixels per meter\n    buffer.put(writeInt(0));\n\n    // vertical resolution in pixels per meter (unreliable)\n    buffer.put(writeInt(0));\n\n    buffer.put(writeInt(0));\n    buffer.put(writeInt(0));\n\n    /** BITMAP INFO HEADER Write End */\n\n    int row = height;\n    int col = width;\n    int startPosition = (row - 1) * col;\n    int endPosition = row * col;\n\n    while (row > 0) {\n        for (int i = startPosition; i < endPosition; i++) {\n            buffer.put((byte) (pixels[i] & 0x000000FF));\n            buffer.put((byte) ((pixels[i] & 0x0000FF00) >> 8));\n            buffer.put((byte) ((pixels[i] & 0x00FF0000) >> 16));\n        }\n        if (hasDummy) {\n            buffer.put(dummyBytesPerRow);\n        }\n        row--;\n        endPosition = startPosition;\n        startPosition = startPosition - col;\n    }\n\n    FileOutputStream fos = new FileOutputStream(filePath);\n    fos.write(buffer.array());\n    fos.close();\n\n    Log.v(\"AndroidBmpUtil\", System.currentTimeMillis() - start + \" ms\");\n\n    return isSaveSuccess;\n}",
  "explanation": "code_hardening: none\nresolve_compilation_errors: none\nexception_handling: none\nlogic_customization: none\nrefactoring: Reformatted the method with consistent indentation, brace placement, and spacing around operators, casts, commas, and control structures. Aligned comments and grouped related sections for readability while preserving all identifiers and logic exactly.\nmisc: Tidied Javadoc and inline comment formatting, standardized spacing in the Log.v call, and adjusted line breaks for long expressions to improve readability without changing behavior."
}