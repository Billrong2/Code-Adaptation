{
  "code": "public static float getCPUUsage() {\n\tfinal String STAT_PATH = \"/proc/stat\";\n\tfinal int SLEEP_MS = 360;\n\tfinal int IDLE_INDEX = 5;\n\tfinal int[] BUSY_INDICES = new int[] { 2, 3, 4, 6, 7, 8 };\n\n\ttry (java.io.RandomAccessFile reader = new java.io.RandomAccessFile(STAT_PATH, \"r\")) {\n\t\tString statLine1 = reader.readLine();\n\t\tif (statLine1 == null) return 0f;\n\t\tString[] fields1 = statLine1.split(\" \"); // split on a single space\n\t\tif (fields1.length <= 8) return 0f;\n\n\t\tlong idle1 = Long.parseLong(fields1[IDLE_INDEX]);\n\t\tlong cpu1 = 0;\n\t\tfor (int idx : BUSY_INDICES) cpu1 += Long.parseLong(fields1[idx]);\n\n\t\ttry {\n\t\t\tThread.sleep(SLEEP_MS);\n\t\t} catch (InterruptedException ie) {\n\t\t\tThread.currentThread().interrupt();\n\t\t\treturn 0f;\n\t\t}\n\n\t\treader.seek(0);\n\t\tString statLine2 = reader.readLine();\n\t\tif (statLine2 == null) return 0f;\n\t\tString[] fields2 = statLine2.split(\" \");\n\t\tif (fields2.length <= 8) return 0f;\n\n\t\tlong idle2 = Long.parseLong(fields2[IDLE_INDEX]);\n\t\tlong cpu2 = 0;\n\t\tfor (int idx : BUSY_INDICES) cpu2 += Long.parseLong(fields2[idx]);\n\n\t\tlong denom = (cpu2 + idle2) - (cpu1 + idle1);\n\t\tif (denom == 0) return 0f;\n\n\t\treturn (float) (cpu2 - cpu1) / (float) denom;\n\t} catch (java.io.IOException ex) {\n\t\tex.printStackTrace();\n\t\treturn 0f;\n\t}\n}",
  "explanation": "code_hardening: Used try-with-resources to ensure RandomAccessFile is always closed, validated that the /proc/stat line is non-null and has sufficient tokens before indexing, guarded against division by zero, and used final constants for paths, indices, and sleep duration.\nresolve_compilation_errors: Renamed the method to public static getCPUUsage, removed any instance context, and used fully qualified java.io.RandomAccessFile and java.io.IOException to avoid missing imports.\nexception_handling: Explicitly caught InterruptedException during Thread.sleep, restored the interrupt flag, and returned a safe default; IOException is caught, logged via printStackTrace, and returns 0f consistently.\nlogic_customization: Changed tokenization to split on a single space, updated idle index to 5 and busy indices to 2,3,4,6,7,8, and applied these indices consistently to both reads while keeping the sleep duration and usage formula unchanged.\nrefactoring: Renamed variables for clarity (statLine, fields), replaced magic numbers with named constants, and used a small loop for summing busy CPU fields to reduce duplication.\nmisc: Reformatted code for readability and added minimal inline comments reflecting the new tokenization and index logic. No new custom API calls were introduced."
}