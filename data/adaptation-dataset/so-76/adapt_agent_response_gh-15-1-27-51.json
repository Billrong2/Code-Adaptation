{
  "code": "/**\n\t * Sorts the given map by its keys in natural order and returns a new {@link LinkedHashMap}\n\t * preserving the sorted iteration order.\n\t *\n\t * @param <K>\n\t *            the key type, must be {@link Comparable}\n\t * @param <V>\n\t *            the value type\n\t * @param map\n\t *            the map to sort\n\t * @return a new {@link LinkedHashMap} containing the entries sorted by key\n\t */\n\tpublic static <K extends Comparable<? super K>, V> Map<K, V> sortByKey(final Map<K, V> map) {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tfinal Map.Entry<K, V>[] array = map.entrySet().toArray(new Map.Entry[map.size()]);\n\n\t\tArrays.sort(array, new Comparator<Map.Entry<K, V>>() {\n\t\t\t@Override\n\t\t\tpublic int compare(final Map.Entry<K, V> e1, final Map.Entry<K, V> e2) {\n\t\t\t\treturn e1.getKey().compareTo(e2.getKey());\n\t\t\t}\n\t\t});\n\n\t\tfinal Map<K, V> result = new LinkedHashMap<K, V>();\n\t\tfor (final Map.Entry<K, V> entry : array) {\n\t\t\tresult.put(entry.getKey(), entry.getValue());\n\t\t}\n\n\t\treturn result;\n\t}",
  "explanation": "code_hardening: none\nresolve_compilation_errors: Updated the generic bounds to require K extends Comparable<? super K> and removed any Comparable constraint from V; ensured the comparator uses getKey() so the type bounds compile correctly; matched the caller expectation by providing a sortByKey method.\nexception_handling: none\nlogic_customization: Changed the sorting logic to compare map entry keys instead of values while preserving the original algorithm structure (array conversion followed by Arrays.sort) and returning a LinkedHashMap to maintain sorted order.\nrefactoring: Renamed the method from sortByValue to sortByKey, updated the method signature accordingly, added Javadoc, and marked parameters and local variables as final for clarity and immutability.\nmisc: none"
}