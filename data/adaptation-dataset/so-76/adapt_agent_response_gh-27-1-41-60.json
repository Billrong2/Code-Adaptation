{
  "code": "public static <K, V extends Comparable<? super V>> Map<K, V> sortByDescendingValue(Map<K, V> map)\n\t{\n\t\tif (map == null) {\n\t\t\tthrow new NullPointerException(\"map must not be null\");\n\t\t}\n\t\tif (map.isEmpty()) {\n\t\t\treturn new LinkedHashMap<K, V>();\n\t\t}\n\t\tfinal List<Map.Entry<K, V>> entries = new LinkedList<Map.Entry<K, V>>(map.entrySet());\n\t\tCollections.sort(entries, new Comparator<Map.Entry<K, V>>()\n\t\t{\n\t\t\tpublic int compare(Map.Entry<K, V> o1, Map.Entry<K, V> o2)\n\t\t\t{\n\t\t\t\t// reverse natural order to achieve descending sort by value\n\t\t\t\treturn o2.getValue().compareTo(o1.getValue());\n\t\t\t}\n\t\t});\n\t\tfinal Map<K, V> result = new LinkedHashMap<K, V>();\n\t\tfor (Map.Entry<K, V> entry : entries)\n\t\t{\n\t\t\tresult.put(entry.getKey(), entry.getValue());\n\t\t}\n\t\treturn result;\n\t}",
  "explanation": "code_hardening: Added a null check for the input map with a clear NullPointerException message and an early return for empty maps to avoid unnecessary sorting; marked locals as final for clarity.\nresolve_compilation_errors: Used existing java.util types already imported in the file (List, LinkedList, Map, LinkedHashMap, Collections, Comparator) and consistent generic types with List<Map.Entry<K,V>>.\nexception_handling: No checked exceptions introduced; comparator may still throw NullPointerException if values are null, which is allowed by design.\nlogic_customization: Implemented descending order by reversing the comparison operands in compareTo, sorted a List of entries using Collections.sort, and rebuilt a LinkedHashMap to preserve the sorted order.\nrefactoring: Introduced the new method name sortByDescendingValue, improved variable naming (entries instead of array/list ambiguity), and simplified logic consistent with the existing ascending variant.\nmisc: Updated inline comment to clarify descending sort behavior; no new custom API calls were introduced (none)."
}