{
  "code": "public static <K extends Comparable<? super K>, V> Map<K, V> sortByKey(final Map<K, V> map) {\n\t@SuppressWarnings(\"unchecked\")\n\tfinal Map.Entry<K, V>[] array = map.entrySet().toArray(new Map.Entry[map.size()]);\n\n\tArrays.sort(array, new Comparator<Map.Entry<K, V>>() {\n\t\t@Override\n\t\tpublic int compare(final Map.Entry<K, V> e1, final Map.Entry<K, V> e2) {\n\t\t\treturn e1.getKey().compareTo(e2.getKey());\n\t\t}\n\t});\n\n\tfinal Map<K, V> result = new LinkedHashMap<K, V>();\n\tfor (final Map.Entry<K, V> entry : array) {\n\t\tresult.put(entry.getKey(), entry.getValue());\n\t}\n\n\treturn result;\n}",
  "explanation": "code_hardening: none\nresolve_compilation_errors: Updated the generic signature to `<K extends Comparable<? super K>, V>` so key comparison via `compareTo` compiles correctly, and ensured the method name matches the caller (`sortByKey`). Comparator now operates on `Map.Entry<K, V>` keys, avoiding value-bound constraints.\nexception_handling: none\nlogic_customization: Changed the sorting logic to compare map entry keys (`e1.getKey().compareTo(e2.getKey())`) instead of values, preserving ascending order based on the natural ordering of keys.\nrefactoring: Renamed the method from `sortByValue` to `sortByKey`, marked parameters and locals as `final`, and added `@Override` to the comparator method for clarity and style consistency.\nmisc: Returned a `LinkedHashMap` to preserve the sorted iteration order and retained the existing array-based sorting approach without altering external behavior. No new custom API calls were introduced."
}