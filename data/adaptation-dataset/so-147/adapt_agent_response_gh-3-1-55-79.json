{
  "code": "private void setupProxyAuthenticator()\n{\n    try\n    {\n        Authenticator.setDefault(new Authenticator()\n        {\n            @Override\n            protected PasswordAuthentication getPasswordAuthentication()\n            {\n                if (getRequestorType() != RequestorType.PROXY)\n                    return null;\n\n                final String requestingProtocol = getRequestingProtocol();\n                final String requestingHost = getRequestingHost();\n                if (requestingProtocol == null || requestingHost == null)\n                    return null;\n\n                final String protocol = requestingProtocol.toLowerCase();\n                final String proxyHost = System.getProperty(protocol + \".proxyHost\");\n                final String proxyPortValue = System.getProperty(protocol + \".proxyPort\");\n                final String proxyUser = System.getProperty(protocol + \".proxyUser\");\n                final String proxyPassword = System.getProperty(protocol + \".proxyPassword\");\n\n                if (proxyHost == null || proxyHost.isEmpty() || proxyUser == null || proxyUser.isEmpty())\n                    return null;\n\n                final int proxyPort;\n                try\n                {\n                    proxyPort = proxyPortValue != null ? Integer.parseInt(proxyPortValue) : -1;\n                }\n                catch (NumberFormatException e)\n                {\n                    return null;\n                }\n\n                if (!requestingHost.equalsIgnoreCase(proxyHost))\n                    return null;\n\n                if (proxyPort >= 0 && proxyPort != getRequestingPort())\n                    return null;\n\n                final char[] passwordChars = proxyPassword != null ? proxyPassword.toCharArray() : new char[0];\n                return new PasswordAuthentication(proxyUser, passwordChars);\n            }\n        });\n    }\n    catch (SecurityException e)\n    {\n        log(e);\n    }\n}",
  "explanation": "code_hardening: Added null and empty checks for requesting protocol/host and proxy system properties; validated proxy port parsing with a guarded Integer.parseInt; avoided assumptions about presence of password; used early returns to keep logic safe and clear.\nresolve_compilation_errors: Removed subclassing and instead registered a JVM-wide authenticator via java.net.Authenticator.setDefault; relied on existing imports in the file (Authenticator, PasswordAuthentication) so the method compiles in this context.\nexception_handling: Wrapped Authenticator.setDefault in a try/catch to handle SecurityException; prevented NumberFormatException by catching it during proxy port parsing and falling back to returning null.\nlogic_customization: Moved the SO snippet logic into an anonymous Authenticator registered in setupProxyAuthenticator; ensured proxy-only behavior (RequestorType.PROXY) and matched protocol/host/port against system proxy properties before supplying credentials; returning null otherwise to allow normal handling.\nrefactoring: Introduced a clearly named setup method consistent with plugin conventions; improved local variable naming and structure; removed magic defaults in favor of explicit validation without changing behavior.\nmisc: Added minimal formatting and comments via structure; logged security failures using the pluginâ€™s existing log(Throwable) method; no new custom APIs beyond java.net.Authenticator.setDefault(java.net.Authenticator)."}