{
  "code": "public static Bitmap fastblur(Bitmap sourceBitmap, int outWidth, int outHeight, int radius) {\n    if (sourceBitmap == null) {\n        return null;\n    }\n    if (radius < 1 || outWidth <= 0 || outHeight <= 0) {\n        return null;\n    }\n\n    final Bitmap.Config safeConfig = sourceBitmap.getConfig() != null\n            ? sourceBitmap.getConfig()\n            : Bitmap.Config.ARGB_8888;\n\n    // Scale source bitmap directly to the requested output size\n    Bitmap scaledBitmap = Bitmap.createScaledBitmap(sourceBitmap, outWidth, outHeight, false);\n    Bitmap bitmap = scaledBitmap.copy(safeConfig, true);\n\n    final int w = bitmap.getWidth();\n    final int h = bitmap.getHeight();\n\n    int[] pix = new int[w * h];\n    Log.e(\"pix\", w + \" \" + h + \" \" + pix.length);\n    bitmap.getPixels(pix, 0, w, 0, 0, w, h);\n\n    final int wm = w - 1;\n    final int hm = h - 1;\n    final int wh = w * h;\n    final int div = radius + radius + 1;\n\n    int[] r = new int[wh];\n    int[] g = new int[wh];\n    int[] b = new int[wh];\n    int rsum, gsum, bsum, x, y, i, p, yp, yi, yw;\n    int[] vmin = new int[Math.max(w, h)];\n\n    int divsum = (div + 1) >> 1;\n    divsum *= divsum;\n    int[] dv = new int[256 * divsum];\n    for (i = 0; i < 256 * divsum; i++) {\n        dv[i] = (i / divsum);\n    }\n\n    yw = yi = 0;\n\n    int[][] stack = new int[div][3];\n    int stackpointer;\n    int stackstart;\n    int[] sir;\n    int rbs;\n    final int r1 = radius + 1;\n    int routsum, goutsum, boutsum;\n    int rinsum, ginsum, binsum;\n\n    for (y = 0; y < h; y++) {\n        rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;\n        for (i = -radius; i <= radius; i++) {\n            p = pix[yi + Math.min(wm, Math.max(i, 0))];\n            sir = stack[i + radius];\n            sir[0] = (p & 0xff0000) >> 16;\n            sir[1] = (p & 0x00ff00) >> 8;\n            sir[2] = (p & 0x0000ff);\n            rbs = r1 - Math.abs(i);\n            rsum += sir[0] * rbs;\n            gsum += sir[1] * rbs;\n            bsum += sir[2] * rbs;\n            if (i > 0) {\n                rinsum += sir[0];\n                ginsum += sir[1];\n                binsum += sir[2];\n            } else {\n                routsum += sir[0];\n                goutsum += sir[1];\n                boutsum += sir[2];\n            }\n        }\n        stackpointer = radius;\n\n        for (x = 0; x < w; x++) {\n            r[yi] = dv[rsum];\n            g[yi] = dv[gsum];\n            b[yi] = dv[bsum];\n\n            rsum -= routsum;\n            gsum -= goutsum;\n            bsum -= boutsum;\n\n            stackstart = stackpointer - radius + div;\n            sir = stack[stackstart % div];\n\n            routsum -= sir[0];\n            goutsum -= sir[1];\n            boutsum -= sir[2];\n\n            if (y == 0) {\n                vmin[x] = Math.min(x + r1, wm);\n            }\n            p = pix[yw + vmin[x]];\n\n            sir[0] = (p & 0xff0000) >> 16;\n            sir[1] = (p & 0x00ff00) >> 8;\n            sir[2] = (p & 0x0000ff);\n\n            rinsum += sir[0];\n            ginsum += sir[1];\n            binsum += sir[2];\n\n            rsum += rinsum;\n            gsum += ginsum;\n            bsum += binsum;\n\n            stackpointer = (stackpointer + 1) % div;\n            sir = stack[stackpointer % div];\n\n            routsum += sir[0];\n            goutsum += sir[1];\n            boutsum += sir[2];\n\n            rinsum -= sir[0];\n            ginsum -= sir[1];\n            binsum -= sir[2];\n\n            yi++;\n        }\n        yw += w;\n    }\n\n    for (x = 0; x < w; x++) {\n        rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;\n        yp = -radius * w;\n        for (i = -radius; i <= radius; i++) {\n            yi = Math.max(0, yp) + x;\n            sir = stack[i + radius];\n            sir[0] = r[yi];\n            sir[1] = g[yi];\n            sir[2] = b[yi];\n            rbs = r1 - Math.abs(i);\n            rsum += r[yi] * rbs;\n            gsum += g[yi] * rbs;\n            bsum += b[yi] * rbs;\n            if (i > 0) {\n                rinsum += sir[0];\n                ginsum += sir[1];\n                binsum += sir[2];\n            } else {\n                routsum += sir[0];\n                goutsum += sir[1];\n                boutsum += sir[2];\n            }\n            if (i < hm) {\n                yp += w;\n            }\n        }\n        yi = x;\n        stackpointer = radius;\n        for (y = 0; y < h; y++) {\n            // Preserve alpha channel\n            pix[yi] = (0xff000000 & pix[yi]) | (dv[rsum] << 16) | (dv[gsum] << 8) | dv[bsum];\n\n            rsum -= routsum;\n            gsum -= goutsum;\n            bsum -= boutsum;\n\n            stackstart = stackpointer - radius + div;\n            sir = stack[stackstart % div];\n\n            routsum -= sir[0];\n            goutsum -= sir[1];\n            boutsum -= sir[2];\n\n            if (x == 0) {\n                vmin[y] = Math.min(y + r1, hm) * w;\n            }\n            p = x + vmin[y];\n\n            sir[0] = r[p];\n            sir[1] = g[p];\n            sir[2] = b[p];\n\n            rinsum += sir[0];\n            ginsum += sir[1];\n            binsum += sir[2];\n\n            rsum += rinsum;\n            gsum += ginsum;\n            bsum += binsum;\n\n            stackpointer = (stackpointer + 1) % div;\n            sir = stack[stackpointer];\n\n            routsum += sir[0];\n            goutsum += sir[1];\n            boutsum += sir[2];\n\n            rinsum -= sir[0];\n            ginsum -= sir[1];\n            binsum -= sir[2];\n\n            yi += w;\n        }\n    }\n\n    Log.e(\"pix\", w + \" \" + h + \" \" + pix.length);\n    bitmap.setPixels(pix, 0, w, 0, 0, w, h);\n    return bitmap;\n}",
  "explanation": "code_hardening: Added null checks for the source bitmap, validated radius and output dimensions, and ensured a safe Bitmap.Config fallback (ARGB_8888) when the source config is null. Kept variables final where reasonable.\nresolve_compilation_errors: Updated the method to be static, replaced the scale factor with explicit outWidth and outHeight parameters, and adjusted bitmap scaling accordingly using Bitmap.createScaledBitmap. Ensured compatibility with the existing Log API.\nexception_handling: none.\nlogic_customization: Removed scale-based dimension computation and scaled the source bitmap exactly once to the provided width and height. Preserved the original Stack Blur algorithm, pixel processing, alpha preservation, and return behavior unchanged.\nrefactoring: Renamed the input parameter to sourceBitmap and updated local naming for clarity. Modernized comments to reflect the new API semantics.\nmisc: Updated inline comments to reflect static utility usage and new parameters; retained minimal debug logging consistent with the existing code style. No new custom API calls were introduced."
}