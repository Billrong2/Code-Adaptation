{
  "code": "void resizeText(int width, int height) {\n        CharSequence text = getText();\n        // Do not resize if the view does not have dimensions or there is no text\n        if (text == null || text.length() == 0 || height <= 0 || width <= 0 || mTextSize == 0) {\n            return;\n        }\n\n        // Operate strictly on raw text (no TransformationMethod)\n        TextPaint textPaint = getPaint();\n\n        // Store the current text size from the existing TextPaint\n        float oldTextSize = textPaint.getTextSize();\n\n        // Determine the starting target text size\n        float targetTextSize = mMaxTextSize > 0 ? Math.min(mTextSize, mMaxTextSize) : mTextSize;\n\n        // Measure text height at the target size\n        int textHeight = getTextHeight(text, textPaint, width, targetTextSize);\n\n        // Reduce text size until it fits or reaches the minimum size\n        while (textHeight > height && targetTextSize > mMinTextSize) {\n            targetTextSize = Math.max(targetTextSize - 2, mMinTextSize);\n            textHeight = getTextHeight(text, textPaint, width, targetTextSize);\n        }\n\n        // If at minimum size and still does not fit, append an ellipsis if enabled\n        if (mAddEllipsis && targetTextSize == mMinTextSize && textHeight > height) {\n            // Use the existing TextPaint for layout\n            StaticLayout layout = new StaticLayout(text, textPaint, width,\n                    Alignment.ALIGN_NORMAL, mSpacingMult, mSpacingAdd, false);\n            if (layout.getLineCount() > 0) {\n                int lastLine = layout.getLineForVertical(height) - 1;\n                if (lastLine < 0) {\n                    setText(\"\");\n                } else {\n                    int start = layout.getLineStart(lastLine);\n                    int end = layout.getLineEnd(lastLine);\n                    float lineWidth = layout.getLineWidth(lastLine);\n                    float ellipsisWidth = textPaint.measureText(mEllipsis);\n\n                    // Trim characters until there is room for the ellipsis\n                    while (end > start && width < lineWidth + ellipsisWidth) {\n                        end--;\n                        lineWidth = textPaint.measureText(text.subSequence(start, end).toString());\n                    }\n                    setText(text.subSequence(0, end) + mEllipsis);\n                }\n            }\n        }\n\n        // Apply the final text size directly to the TextPaint\n        textPaint.setTextSize(targetTextSize);\n\n        // Force default line spacing and trigger layout invalidation\n        setLineSpacing(mSpacingAdd, mSpacingMult);\n\n        // Notify the listener if registered\n        if (mTextResizeListener != null) {\n            mTextResizeListener.onTextResize(this, oldTextSize, targetTextSize);\n        }\n\n        // Reset force resize flag\n        mNeedsResize = false;\n    }",
  "explanation": "code_hardening: Added guards for null/empty text and invalid dimensions after removing TransformationMethod usage, and ensured layout/ellipsis logic safely handles zero or negative line scenarios while using the existing TextPaint.\nresolve_compilation_errors: Removed all references to getTransformationMethod and TextPaint copying, reused the viewâ€™s existing TextPaint, and kept StaticLayout construction compatible with the existing API and class context. Reduced visibility to package-private.\nexception_handling: none\nlogic_customization: Switched measurement and layout to operate on raw getText() output only, reused the existing TextPaint throughout, applied the final size via TextPaint.setTextSize(...), and relied on setLineSpacing(...) to invalidate layout instead of calling setTextSize.\nrefactoring: Reduced method visibility, removed unnecessary locals related to transformed text or copied paints, and simplified trimming logic while keeping behavior equivalent.\nmisc: Updated inline comments to reflect raw text measurement and direct TextPaint sizing; no new custom API calls were introduced."
}