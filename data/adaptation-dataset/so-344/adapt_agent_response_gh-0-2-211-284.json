{
  "code": "public void resizeText(int width, int height) {\n        final CharSequence text = getText();\n        // Do not resize if the view does not have dimensions or there is no text\n        if (text == null || text.length() == 0 || height <= 0 || width <= 0 || mTextSize == 0) {\n            return;\n        }\n\n        // Get the text view's paint object (read-only) and store the current text size\n        final TextPaint viewPaint = getPaint();\n        final float oldTextSize = viewPaint.getTextSize();\n\n        // If there is a max text size set, use the lesser of that and the default text size\n        float targetTextSize = mMaxTextSize > 0 ? Math.min(mTextSize, mMaxTextSize) : mTextSize;\n\n        // Get the required text height\n        int textHeight = getTextHeight(text, viewPaint, width, targetTextSize);\n\n        // Decrement step when shrinking text size\n        final float TEXT_SIZE_STEP = 2f;\n\n        // Until we either fit within our text view or we had reached our min text size, incrementally try smaller sizes\n        while (textHeight > height && targetTextSize > mMinTextSize) {\n            targetTextSize = Math.max(targetTextSize - TEXT_SIZE_STEP, mMinTextSize);\n            textHeight = getTextHeight(text, viewPaint, width, targetTextSize);\n        }\n\n        // If we had reached our minimum text size and still don't fit, append an ellipsis\n        if (mAddEllipsis && targetTextSize == mMinTextSize && textHeight > height && width > 0 && height > 0) {\n            // Use a single copied TextPaint instance for all measurements to keep consistency\n            final TextPaint paint = new TextPaint(viewPaint);\n            paint.setTextSize(targetTextSize);\n\n            // Measure using a static layout\n            final StaticLayout layout = new StaticLayout(text, paint, width, Layout.Alignment.ALIGN_NORMAL,\n                    mSpacingMult, mSpacingAdd, false);\n\n            // Check that we have at least one line of rendered text\n            if (layout.getLineCount() > 0) {\n                // Since the line at the specific vertical position would be cut off,\n                // we must trim up to the previous line\n                final int lastLine = layout.getLineForVertical(height) - 1;\n\n                // If the text would not even fit on a single line, clear it\n                if (lastLine < 0) {\n                    setText(\"\");\n                } else {\n                    final int start = layout.getLineStart(lastLine);\n                    int end = layout.getLineEnd(lastLine);\n                    float lineWidth = layout.getLineWidth(lastLine);\n                    final float ellipsisWidth = paint.measureText(M_ELLIPSIS);\n\n                    // Trim characters off until we have enough room to draw the ellipsis\n                    while (end > start && width < lineWidth + ellipsisWidth) {\n                        end--;\n                        lineWidth = paint.measureText(text.subSequence(start, end).toString());\n                    }\n\n                    // Guard against underflow\n                    if (end > 0) {\n                        setText(text.subSequence(0, end) + M_ELLIPSIS);\n                    } else {\n                        setText(M_ELLIPSIS);\n                    }\n                }\n            }\n        }\n\n        // Force default line spacing and apply the computed text size\n        setTextSize(TypedValue.COMPLEX_UNIT_PX, targetTextSize);\n        setLineSpacing(mSpacingAdd, mSpacingMult);\n\n        // Notify the listener if registered\n        if (mTextResizeListener != null) {\n            mTextResizeListener.onTextResize(this, oldTextSize, targetTextSize);\n        }\n\n        // Reset force resize flag\n        mNeedsResize = false;\n    }",
  "explanation": "code_hardening: Added early returns for null/empty text and non-positive width/height, guarded ellipsis trimming loop against index underflow (end > start), ensured width/height checks before creating StaticLayout, and used final locals where not reassigned.\nresolve_compilation_errors: Updated ellipsis usage to the constant M_ELLIPSIS, referenced Layout.Alignment.ALIGN_NORMAL explicitly, ensured all variables are locally declared and correctly scoped, and reused existing project fields/types.\nexception_handling: none.\nlogic_customization: Removed any use of TransformationMethod and measured directly from the original text; used a single copied TextPaint instance (with targetTextSize applied) for StaticLayout, line width, and ellipsis width measurements to keep consistency; preserved existing resize loop behavior while aligning measurements with the copied paint.\nrefactoring: Replaced the magic decrement value with a named constant (TEXT_SIZE_STEP), clarified variable names (viewPaint vs paint), and simplified trimming logic while keeping it within the same function.\nmisc: Minor comments and formatting updates to reflect consistent measurement behavior and ellipsis handling; no new custom API calls were introduced."
}