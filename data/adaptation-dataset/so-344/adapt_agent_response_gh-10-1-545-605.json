{
  "code": "private void resizeText(int width, int height) {\n        CharSequence text = getText();\n        // Do not resize if the view does not have dimensions or there is no text\n        if (text == null || text.length() == 0 || height <= 0 || width <= 0) {\n            return;\n        }\n\n        // Use the view's TextPaint directly\n        TextPaint textPaint = getPaint();\n\n        // Store the current text size\n        float oldTextSize = textPaint.getTextSize();\n        // If there is a max text size set, use the lesser of that and the default text size\n        float targetTextSize = mMaxTextSize > 0 ? Math.min(mTextSize, mMaxTextSize) : mTextSize;\n\n        // Get the required text height\n        int textHeight = getTextHeight(text, textPaint, width, targetTextSize);\n\n        // Until we either fit within our text view or we had reached our min text size, incrementally try smaller sizes\n        while (textHeight > height && targetTextSize > mMinTextSize) {\n            targetTextSize = Math.max(targetTextSize - 2, mMinTextSize);\n            textHeight = getTextHeight(text, textPaint, width, targetTextSize);\n        }\n\n        // If we had reached our minimum text size and still don't fit, append an ellipsis\n        if (mAddEllipsis && targetTextSize == mMinTextSize && textHeight > height) {\n            // Draw using a static layout with the view's paint\n            textPaint.setTextSize(targetTextSize);\n            StaticLayout layout = new StaticLayout(text, textPaint, width, Alignment.ALIGN_NORMAL, mSpacingMult, mSpacingAdd, false);\n            // Draw to the shared off-screen canvas\n            layout.draw(sTextResizeCanvas);\n\n            // Since the line at the specific vertical position would be cut off,\n            // we must trim up to the previous line\n            int lastLine = layout.getLineForVertical(height) - 1;\n            int start = layout.getLineStart(lastLine);\n            int end = layout.getLineEnd(lastLine);\n            float lineWidth = layout.getLineWidth(lastLine);\n            float ellipseWidth = textPaint.measureText(mEllipsis);\n\n            // Trim characters off until we have enough room to draw the ellipsis\n            while (width < lineWidth + ellipseWidth) {\n                lineWidth = textPaint.measureText(text.subSequence(start, --end + 1).toString());\n            }\n            setText(text.subSequence(0, end) + mEllipsis);\n        }\n\n        // Some devices try to auto adjust line spacing, so force default line spacing\n        // Apply the chosen size directly on the TextPaint\n        textPaint.setTextSize(targetTextSize);\n        setLineSpacing(mSpacingAdd, mSpacingMult);\n\n        // Notify the listener if registered\n        if (mTextResizeListener != null) {\n            mTextResizeListener.onTextResize(this, oldTextSize, targetTextSize);\n        }\n\n        // Reset force resize flag\n        mNeedsResize = false;\n    }",
  "explanation": "code_hardening: Kept basic null/empty text and width/height guards while removing the mTextSize==0 early exit as requested; reused the shared canvas without additional state, assuming existing usage patterns.\nresolve_compilation_errors: Switched to TextPaint.setTextSize(float) and ensured StaticLayout is constructed with the view’s TextPaint, matching available Android APIs; no transformation-method references remain.\nexception_handling: none.\nlogic_customization: Removed transformation preprocessing, relaxed the early-exit guard, used the view’s TextPaint directly for measurement and layout, applied text size via textPaint.setTextSize, and updated the ellipsis branch to draw the StaticLayout to the shared canvas and compute line indices without empty-layout or lastLine<0 fallback handling.\nrefactoring: Eliminated the copied TextPaint instance and simplified layout/measurement to consistently use the existing paint; cleaned up related comments accordingly.\nmisc: none."
}