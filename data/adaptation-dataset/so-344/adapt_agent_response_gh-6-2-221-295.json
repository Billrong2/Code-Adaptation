{
  "code": "public void resizeText(int width, int height) {\n        // Use the original, untransformed text for all measurements and resizing\n        CharSequence originalText = getText();\n\n        // Do not resize if the view does not have dimensions or there is no text\n        if (originalText == null || originalText.length() == 0 || height <= 0 || width <= 0 || mTextSize == 0) {\n            return;\n        }\n\n        // Get the text view's paint object\n        TextPaint textPaint = getPaint();\n\n        // Store the current text size\n        float oldTextSize = textPaint.getTextSize();\n\n        // If there is a max text size set, use the lesser of that and the default text size\n        float targetTextSize = mMaxTextSize > 0 ? Math.min(mTextSize, mMaxTextSize) : mTextSize;\n\n        // Get the required text height using the original text\n        int textHeight = getTextHeight(originalText, textPaint, width, targetTextSize);\n\n        // Until we either fit within our text view or we had reached our min text size, incrementally try smaller sizes\n        while (textHeight > height && targetTextSize > mMinTextSize) {\n            targetTextSize = Math.max(targetTextSize - 2, mMinTextSize);\n            textHeight = getTextHeight(originalText, textPaint, width, targetTextSize);\n        }\n\n        // If we had reached our minimum text size and still don't fit, append an ellipsis\n        if (mAddEllipsis && targetTextSize == mMinTextSize && textHeight > height) {\n            // Draw using a static layout with the original text\n            TextPaint paint = new TextPaint(textPaint);\n            StaticLayout layout = new StaticLayout(originalText, paint, width, Alignment.ALIGN_NORMAL, mSpacingMult, mSpacingAdd, false);\n\n            // Check that we have at least one line of rendered text\n            if (layout.getLineCount() > 0) {\n                // Since the line at the specific vertical position would be cut off,\n                // we must trim up to the previous line\n                int lastLine = layout.getLineForVertical(height) - 1;\n\n                // If the text would not even fit on a single line, clear it\n                if (lastLine < 0) {\n                    setText(\"\");\n                } else {\n                    int start = layout.getLineStart(lastLine);\n                    int end = layout.getLineEnd(lastLine);\n                    float lineWidth = layout.getLineWidth(lastLine);\n                    float ellipseWidth = textPaint.measureText(mEllipsis);\n\n                    // Trim characters off until we have enough room to draw the ellipsis\n                    while (width < lineWidth + ellipseWidth && end > start) {\n                        end--;\n                        lineWidth = textPaint.measureText(originalText.subSequence(start, end).toString());\n                    }\n                    setText(originalText.subSequence(0, end) + mEllipsis);\n                }\n            }\n        }\n\n        // Some devices try to auto adjust line spacing, so force default line spacing\n        // and invalidate the layout as a side effect\n        setTextSize(TypedValue.COMPLEX_UNIT_PX, targetTextSize);\n        setLineSpacing(mSpacingAdd, mSpacingMult);\n\n        // Notify the listener if registered\n        if (mTextResizeListener != null) {\n            mTextResizeListener.onTextResize(this, oldTextSize, targetTextSize);\n        }\n\n        // Reset force resize flag\n        mNeedsResize = false;\n    }",
  "explanation": "code_hardening: none\nresolve_compilation_errors: none\nexception_handling: none\nlogic_customization: removed any use of TransformationMethod; all height calculations, StaticLayout creation, resizing loop, and ellipsis trimming now operate directly on the original getText() content via the originalText variable.\nrefactoring: renamed the local text variable to originalText to clarify that it represents untransformed text; no behavioral changes.\nmisc: updated inline comments to reflect that transformation methods are no longer applied during measurement and resizing."
}