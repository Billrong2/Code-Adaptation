{
  "code": "public DraggableTabbedPane() {\n    super();\n\n    addMouseMotionListener(new MouseMotionAdapter() {\n      @Override\n      public void mouseDragged(MouseEvent e) {\n        // Begin drag: capture tab image on first drag event\n        if (!dragging) {\n          if (getUI() == null) {\n            return;\n          }\n          int tabIndex = getUI().tabForCoordinate(DraggableTabbedPane.this, e.getX(), e.getY());\n          if (tabIndex >= 0) {\n            draggedTabIndex = tabIndex;\n            Rectangle tabBounds = getUI().getTabBounds(DraggableTabbedPane.this, tabIndex);\n            if (tabBounds == null || tabBounds.width <= 0 || tabBounds.height <= 0) {\n              return;\n            }\n\n            // Paint the tabbed pane to an offscreen image\n            Image fullImage = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_ARGB);\n            Graphics fullGraphics = fullImage.getGraphics();\n            boolean wasDoubleBuffered = isDoubleBuffered();\n            try {\n              fullGraphics.setClip(tabBounds);\n              // Disable double buffering when painting to a static image\n              setDoubleBuffered(false);\n              paintComponent(fullGraphics);\n            } finally {\n              // Restore double buffering and dispose graphics\n              setDoubleBuffered(wasDoubleBuffered);\n              fullGraphics.dispose();\n            }\n\n            // Extract just the dragged tab image\n            BufferedImage draggedImage = new BufferedImage(tabBounds.width, tabBounds.height, BufferedImage.TYPE_INT_ARGB);\n            Graphics tabGraphics = draggedImage.getGraphics();\n            try {\n              tabGraphics.drawImage(\n                  fullImage,\n                  0,\n                  0,\n                  tabBounds.width,\n                  tabBounds.height,\n                  tabBounds.x,\n                  tabBounds.y,\n                  tabBounds.x + tabBounds.width,\n                  tabBounds.y + tabBounds.height,\n                  DraggableTabbedPane.this);\n            } finally {\n              tabGraphics.dispose();\n            }\n\n            tabImage = draggedImage;\n            currentMouseLocation = e.getPoint();\n            dragging = true;\n            repaint();\n          }\n        } else {\n          // Continue drag: update mouse location\n          currentMouseLocation = e.getPoint();\n          repaint();\n        }\n        super.mouseDragged(e);\n      }\n    });\n\n    addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseReleased(MouseEvent e) {\n        // Finish drag: move tab if applicable\n        if (dragging && getUI() != null) {\n          int releaseY = e.getY(); // computed value instead of magic constant\n          int targetIndex = getUI().tabForCoordinate(DraggableTabbedPane.this, e.getX(), releaseY);\n          if (targetIndex >= 0 && draggedTabIndex >= 0 && draggedTabIndex < getTabCount()) {\n            Component component = getComponentAt(draggedTabIndex);\n            String title = getTitleAt(draggedTabIndex);\n            removeTabAt(draggedTabIndex);\n            insertTab(title, null, component, null, targetIndex);\n          }\n        }\n\n        // Reset drag state\n        dragging = false;\n        tabImage = null;\n        currentMouseLocation = null;\n      }\n    });\n  }",
  "explanation": "code_hardening: Added null checks for getUI(), validated tab bounds before use, ensured Graphics objects are disposed in finally blocks, and restored the previous double-buffering state after offscreen painting.\nresolve_compilation_errors: Implemented the constructor matching the DraggableTabbedPane class, used existing fields (dragging, tabImage, currentMouseLocation, draggedTabIndex), and relied on already-present imports; no unresolved symbols remain.\nexception_handling: none.\nlogic_customization: Replaced the magic constant used for tab lookup on mouse release with a computed Y coordinate from the MouseEvent, and preserved correct tab index handling when removing and reinserting tabs during a drag.\nrefactoring: Renamed local variables for clarity (e.g., tabIndex, tabBounds, fullImage, draggedImage) and structured the drag lifecycle clearly within the constructor without changing behavior.\nmisc: Adjusted brace/whitespace formatting and added brief comments explaining drag start, continuation, and completion steps; no new custom API calls were introduced."
}