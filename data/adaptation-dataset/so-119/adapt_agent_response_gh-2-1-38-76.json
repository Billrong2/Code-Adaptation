{
  "code": "public void mouseDragged(MouseEvent e) {\n    // Always track current mouse location at the start\n    currentMouseLocation = e.getPoint();\n\n    // Guard against invalid UI state\n    if (getUI() == null || getTabCount() <= 0) {\n        super.mouseDragged(e);\n        return;\n    }\n\n    // Constant for Y-offset when querying tab bounds (avoid magic numbers)\n    final int TAB_QUERY_Y_OFFSET = e.getY();\n\n    if (!dragging) {\n        // Determine hovered tab index\n        int tabNumber = getUI().tabForCoordinate(DraggableTabbedPane.this, e.getX(), TAB_QUERY_Y_OFFSET);\n\n        // Prevent initiating drag on first or last tab\n        if (tabNumber > 0 && tabNumber < getTabCount() - 1) {\n            draggedTabIndex = tabNumber;\n            Rectangle bounds = getUI().getTabBounds(DraggableTabbedPane.this, tabNumber);\n            if (bounds != null) {\n                // Paint the tabbed pane to a buffer\n                Image totalImage = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_ARGB);\n                Graphics totalGraphics = totalImage.getGraphics();\n                boolean wasDoubleBuffered = isDoubleBuffered();\n                try {\n                    totalGraphics.setClip(bounds);\n                    // Don't be double buffered when painting to a static image\n                    setDoubleBuffered(false);\n                    paintComponent(totalGraphics);\n                } finally {\n                    // Restore double buffering and dispose graphics\n                    setDoubleBuffered(wasDoubleBuffered);\n                    totalGraphics.dispose();\n                }\n\n                // Paint just the dragged tab to the buffer\n                tabImage = new BufferedImage(bounds.width, bounds.height, BufferedImage.TYPE_INT_ARGB);\n                Graphics graphics = tabImage.getGraphics();\n                try {\n                    graphics.drawImage(\n                            totalImage,\n                            0,\n                            0,\n                            bounds.width,\n                            bounds.height,\n                            bounds.x,\n                            bounds.y,\n                            bounds.x + bounds.width,\n                            bounds.y + bounds.height,\n                            DraggableTabbedPane.this\n                    );\n                } finally {\n                    graphics.dispose();\n                }\n\n                dragging = true;\n                repaint();\n            }\n        }\n    } else {\n        // While dragging, determine potential placement\n        TabType potential = getTabType(e);\n        if (potential != null && potential.getType() != TabTypeEnum.TAB_NEITHER) {\n            toPlace = potential;\n        } else {\n            toPlace = null;\n        }\n        repaint();\n    }\n\n    super.mouseDragged(e);\n}",
  "explanation": "code_hardening: Added null checks for getUI() and tab count, ensured Graphics objects are always disposed in finally blocks, and safely restored the original double-buffering state after offscreen painting.\nresolve_compilation_errors: Used existing class fields (dragging, draggedTabIndex, currentMouseLocation, tabImage, toPlace) and existing APIs (getTabType, TabTypeEnum.TAB_NEITHER, getTabCount) without introducing unresolved symbols; relied on fully available Swing types.\nexception_handling: none.\nlogic_customization: Updated currentMouseLocation at the very beginning of every mouseDragged call; prevented drag initiation when the hovered tab is the first or last tab; preserved the original drag-image creation and dragging state initialization for valid tabs; while dragging, computed placement using getTabType(e), set toPlace when valid, cleared it otherwise, and repainted; retained the call to super.mouseDragged(e).\nrefactoring: Replaced implicit magic usage with a named constant for the tab query Y-coordinate and restructured the method into clear drag-start vs drag-update branches for readability.\nmisc: Added brief inline comments to clarify drag lifecycle steps; no new custom API calls were introduced."
}