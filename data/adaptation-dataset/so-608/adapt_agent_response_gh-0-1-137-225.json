{
"code":"@Override\npublic void onSensorChanged(SensorEvent event) {\n    try {\n        if (event == null || event.values == null) {\n            m_OrientationOK = false;\n            return;\n        }\n        if (parentActivity == null) {\n            m_OrientationOK = false;\n            return;\n        }\n\n        final int type = event.sensor.getType();\n        if (type == Sensor.TYPE_GRAVITY) {\n            if (m_NormGravityVector == null) m_NormGravityVector = new float[3];\n            float gx = event.values[0];\n            float gy = event.values[1];\n            float gz = event.values[2];\n            m_Norm_Gravity = (float) Math.sqrt(gx * gx + gy * gy + gz * gz);\n            if (m_Norm_Gravity > 1e-6f) {\n                m_NormGravityVector[0] = gx / m_Norm_Gravity;\n                m_NormGravityVector[1] = gy / m_Norm_Gravity;\n                m_NormGravityVector[2] = gz / m_Norm_Gravity;\n            }\n        } else if (type == Sensor.TYPE_MAGNETIC_FIELD) {\n            if (m_NormMagFieldValues == null) m_NormMagFieldValues = new float[3];\n            float mx = event.values[0];\n            float my = event.values[1];\n            float mz = event.values[2];\n            m_Norm_MagField = (float) Math.sqrt(mx * mx + my * my + mz * mz);\n            if (m_Norm_MagField > 1e-6f) {\n                m_NormMagFieldValues[0] = mx / m_Norm_MagField;\n                m_NormMagFieldValues[1] = my / m_Norm_MagField;\n                m_NormMagFieldValues[2] = mz / m_Norm_MagField;\n            }\n        } else {\n            return;\n        }\n\n        // proceed only if both vectors are available\n        if (m_NormGravityVector == null || m_NormMagFieldValues == null) {\n            m_OrientationOK = false;\n            return;\n        }\n\n        // validate magnitudes (free-fall or magnetic anomaly)\n        if (m_Norm_Gravity < 1e-3f || m_Norm_MagField < 1e-3f) {\n            m_OrientationOK = false;\n            return;\n        }\n\n        // East = magnetic x gravity\n        float ex = m_NormMagFieldValues[1] * m_NormGravityVector[2] - m_NormMagFieldValues[2] * m_NormGravityVector[1];\n        float ey = m_NormMagFieldValues[2] * m_NormGravityVector[0] - m_NormMagFieldValues[0] * m_NormGravityVector[2];\n        float ez = m_NormMagFieldValues[0] * m_NormGravityVector[1] - m_NormMagFieldValues[1] * m_NormGravityVector[0];\n        float eNorm = (float) Math.sqrt(ex * ex + ey * ey + ez * ez);\n        if (eNorm < 1e-6f) {\n            m_OrientationOK = false;\n            return;\n        }\n        m_NormEastVector[0] = ex / eNorm;\n        m_NormEastVector[1] = ey / eNorm;\n        m_NormEastVector[2] = ez / eNorm;\n\n        // North = magnetic with gravity component removed\n        float dotMG = m_NormMagFieldValues[0] * m_NormGravityVector[0]\n                + m_NormMagFieldValues[1] * m_NormGravityVector[1]\n                + m_NormMagFieldValues[2] * m_NormGravityVector[2];\n        float nx = m_NormMagFieldValues[0] - dotMG * m_NormGravityVector[0];\n        float ny = m_NormMagFieldValues[1] - dotMG * m_NormGravityVector[1];\n        float nz = m_NormMagFieldValues[2] - dotMG * m_NormGravityVector[2];\n        float nNorm = (float) Math.sqrt(nx * nx + ny * ny + nz * nz);\n        if (nNorm < 1e-6f) {\n            m_OrientationOK = false;\n            return;\n        }\n        m_NormNorthVector[0] = nx / nNorm;\n        m_NormNorthVector[1] = ny / nNorm;\n        m_NormNorthVector[2] = nz / nNorm;\n\n        // compute angles\n        float azimuth = (float) Math.atan2(m_NormEastVector[1], m_NormNorthVector[1]);\n        float pitch = (float) Math.acos(Math.max(-1f, Math.min(1f, m_NormGravityVector[2])));\n        float pitchAxis = (float) Math.atan2(m_NormGravityVector[0], m_NormGravityVector[1]);\n\n        // compensate for screen rotation\n        WindowManager wm = parentActivity.getWindowManager();\n        Display display = wm.getDefaultDisplay();\n        int rotation = display.getRotation();\n        switch (rotation) {\n            case Surface.ROTATION_90:\n                azimuth -= Math.PI / 2f;\n                break;\n            case Surface.ROTATION_180:\n                azimuth -= Math.PI;\n                break;\n            case Surface.ROTATION_270:\n                azimuth += Math.PI / 2f;\n                break;\n            case Surface.ROTATION_0:\n            default:\n                break;\n        }\n\n        m_azimuth_radians = azimuth;\n        m_pitch_radians = pitch;\n        m_pitch_axis_radians = pitchAxis;\n        m_OrientationOK = true;\n\n        if (m_parent != null) m_parent.onSensorChanged(event);\n    } catch (Exception e) {\n        m_OrientationOK = false;\n        GPLog.error(this, \"Error computing orientation from sensor event\", e);\n    }\n}",
"explanation":"code_hardening: Added null checks for SensorEvent, values, and parentActivity; guarded against near-zero magnitudes before normalization; clamped inputs to acos; ensured lazy initialization of arrays and safe early returns that mark orientation invalid.\nresolve_compilation_errors: Implemented the missing onSensorChanged(SensorEvent) override, removed any registration/counting concerns, relied on existing fields in the class, and used already-imported Android classes (Sensor, WindowManager, Display, Surface) and GPLog.\nexception_handling: Wrapped the entire processing in a try-catch, logged failures via GPLog, and ensured m_OrientationOK is set false on error.\nlogic_customization: Moved all sensor-processing logic into onSensorChanged; branched by sensor type; normalized gravity and magnetic vectors; computed East via cross product and North via gravity projection removal; validated anomalies; computed azimuth, pitch, and pitch-axis angles; compensated angles for screen rotation using parentActivity.getWindowManager(); forwarded events to an optional parent listener.\nrefactoring: Replaced registration/accuracy-driven logic with orientation-valid flag updates; used named local variables instead of magic indexing; removed sensor-count semantics and focused on event-driven updates.\nmisc: Updated logging to reflect orientation computation errors and kept comments concise to describe event-driven orientation processing. New custom API calls used: eu.geopaparazzi.library.database.GPLog.error(Object,String,Throwable)."}