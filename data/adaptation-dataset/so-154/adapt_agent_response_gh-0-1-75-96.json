{
  "code": "/**\n     * Creates a {@link BitSet} of the given size with exactly {@code cardinality} bits set to {@code true}\n     * using reservoir sampling.\n     *\n     * <p>This implementation is based on a well-known reservoir sampling technique for selecting\n     * {@code cardinality} items uniformly at random from a range {@code [0, size)} in a single pass.\n     * The approach was adapted from a Stack Overflow example commonly cited for random bit set\n     * generation.</p>\n     */\n    private static BitSet randomBitSet(int size, int cardinality, Random rnd) {\n        BitSet result = new BitSet(size);\n        int[] chosen = new int[cardinality];\n        int i;\n        for (i = 0; i < cardinality; ++i) {\n            chosen[i] = i;\n            result.set(i);\n        }\n        for (; i < size; ++i) {\n            int j = rnd.nextInt(i + 1);\n            if (j < cardinality) {\n                result.clear(chosen[j]);\n                result.set(i);\n                chosen[j] = i;\n            }\n        }\n        return result;\n    }",
  "explanation": "code_hardening: none\nresolve_compilation_errors: Changed the method visibility to private static and ensured no references to Preconditions or other unused APIs remain within the function body.\nexception_handling: Removed the IllegalArgumentException throw and did not introduce any alternative exception handling.\nlogic_customization: Preserved the reservoir sampling logic exactly as in the original snippet while adjusting only the method visibility to private static.\nrefactoring: Added a Javadoc comment explaining the purpose and origin of the algorithm without altering the code structure or behavior.\nmisc: Minor formatting adjustments were made to accommodate the Javadoc comment; no new custom API calls were introduced."
}