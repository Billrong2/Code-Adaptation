
package org.onebusaway.android.util;

import com.google.android.gms.common.ConnectionResult;
import com.google.android.gms.common.api.GoogleApiClient;
import com.google.android.gms.location.LocationServices;

import org.onebusaway.android.R;
import org.onebusaway.android.app.Application;
import org.onebusaway.android.directions.util.CustomAddress;
import org.onebusaway.android.io.elements.ObaRegion;

import android.content.Context;
import android.location.Address;
import android.location.Geocoder;
import android.location.Location;
import android.os.Build;
import android.os.Bundle;
import android.os.SystemClock;
import android.provider.Settings;
import android.text.TextUtils;
import android.util.Log;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.TimeUnit;


public class LocationUtils {

    public static final String TAG = "LocationUtil";

    public static final int DEFAULT_SEARCH_RADIUS = 40000;

    private static final float FUZZY_EQUALS_THRESHOLD = 15.0f;

    public static final float ACC_THRESHOLD = 50f;  

    public static final long TIME_THRESHOLD = TimeUnit.MINUTES.toMillis(10);  

    private static final int GEOCODER_MAX_RESULTS = 5;
    
    private static final int GEOCODING_MAX_ERROR = 100;


    public static Location getDefaultSearchCenter() {
        ObaRegion region = Application.get().getCurrentRegion();
        if (region != null) {
            double results[] = new double[4];
            RegionUtils.getRegionSpan(region, results);
            return LocationUtils.makeLocation(results[2], results[3]);
        } else {
            return null;
        }
    }

    
    public static boolean compareLocationsByTime(Location a, Location b) {
        return (a != null && (b == null || a.getTime() > b.getTime()));
    }

    
    public static boolean compareLocations(Location a, Location b) {
        if (a == null) {
            
            return false;
        }
        
        if (b == null) {
            return true;
        }

        
        
        if (System.currentTimeMillis() - b.getTime() > TIME_THRESHOLD
                && compareLocationsByTime(a, b)) {
            return true;
        }

        
        if (a.getAccuracy() < ACC_THRESHOLD && compareLocationsByTime(a, b)) {
            return true;
        }

        
        return false;
    }

    
    public static final Location makeLocation(double lat, double lon) {
        Location l = new Location("");
        l.setLatitude(lat);
        l.setLongitude(lon);
        return l;
    }

    
    public static boolean fuzzyEquals(Location a, Location b) {
        return a.distanceTo(b) <= FUZZY_EQUALS_THRESHOLD;
    }

        // TODO


    
    public static String printLocationDetails(Location loc) {
        if (loc == null) {
            return "";
        }

        long timeDiff;
        double timeDiffSec;

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
            timeDiff = SystemClock.elapsedRealtimeNanos() - loc.getElapsedRealtimeNanos();
            
            timeDiffSec = timeDiff / 1E9;
        } else {
            timeDiff = System.currentTimeMillis() - loc.getTime();
            timeDiffSec = timeDiff / 1E3;
        }

        StringBuilder sb = new StringBuilder();
        sb.append(loc.getProvider());
        sb.append(' ');
        sb.append(loc.getLatitude());
        sb.append(',');
        sb.append(loc.getLongitude());
        if (loc.hasAccuracy()) {
            sb.append(' ');
            sb.append(loc.getAccuracy());
        }
        sb.append(", ");
        sb.append(String.format("%.0f", timeDiffSec) + " second(s) ago");

        return sb.toString();
    }

    
    public static GoogleApiClient getGoogleApiClientWithCallbacks(Context context) {
        LocationServicesCallback locCallback = new LocationServicesCallback();
        return new GoogleApiClient.Builder(context)
                .addApi(LocationServices.API)
                .addConnectionCallbacks(locCallback)
                .addOnConnectionFailedListener(locCallback)
                .build();
    }

    
    public static class LocationServicesCallback
            implements GoogleApiClient.ConnectionCallbacks,
            GoogleApiClient.OnConnectionFailedListener {

        private static final String TAG = "LocationServicesCallbck";

        @Override
        public void onConnected(Bundle bundle) {
            Log.d(TAG, "GoogleApiClient.onConnected");
        }

        @Override
        public void onConnectionSuspended(int i) {
            Log.d(TAG, "GoogleApiClient.onConnectionSuspended");
        }

        @Override
        public void onConnectionFailed(ConnectionResult connectionResult) {
            Log.d(TAG, "GoogleApiClient.onConnectionFailed");
        }
    }

    public static List<CustomAddress> processGeocoding(Context context, ObaRegion region,
                                                            String... reqs) {
        return processGeocoding(context, region, false, reqs);
    }

    public static List<CustomAddress> processGeocoding(Context context, ObaRegion region, boolean geocodingForMarker, String... reqs) {
        ArrayList<CustomAddress> addressesReturn = new ArrayList<CustomAddress>();

        String address = reqs[0];

        if (address == null || address.equalsIgnoreCase("")) {
            return null;
        }

        double latitude = 0, longitude = 0;
        boolean latLngSet = false;

        try {
            if (reqs.length >= 3) {
                latitude = Double.parseDouble(reqs[1]);
                longitude = Double.parseDouble(reqs[2]);
                latLngSet = true;
            }
        } catch (Exception e) {
            Log.e(TAG, "Geocoding without reference latitude/longitude");
        }

        if (address.equalsIgnoreCase(context.getString(R.string.tripplanner_current_location))) {
            if (latLngSet) {
                CustomAddress addressReturn = new CustomAddress(context.getResources().getConfiguration().locale);
                addressReturn.setLatitude(latitude);
                addressReturn.setLongitude(longitude);
                addressReturn.setAddressLine(addressReturn.getMaxAddressLineIndex() + 1,
                        context.getString(R.string.tripplanner_current_location));

                addressesReturn.add(addressReturn);

                return addressesReturn;
            }
            return null;
        }

        List<CustomAddress> addresses = new ArrayList<>();

        

        Geocoder gc = new Geocoder(context);
        try {
            List<Address> androidTypeAddresses;
            if (region != null) {

                double[] regionSpan = new double[4];
                RegionUtils.getRegionSpan(region, regionSpan);
                double minLat = regionSpan[2] - (regionSpan[0] / 2);
                double minLon = regionSpan[3] - (regionSpan[1] / 2);
                double maxLat = regionSpan[2] + (regionSpan[0] / 2);
                double maxLon = regionSpan[3] + (regionSpan[1] / 2);

                androidTypeAddresses = gc.getFromLocationName(address,
                        GEOCODER_MAX_RESULTS, minLat, minLon, maxLat, maxLon);
            } else {
                androidTypeAddresses = gc.getFromLocationName(address,
                        GEOCODER_MAX_RESULTS);
            }
            for (Address androidTypeAddress : androidTypeAddresses) {
                addresses.add(new CustomAddress(androidTypeAddress));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }


        addresses = filterAddressesBBox(region, addresses);

        boolean resultsCloseEnough = true;

        if (geocodingForMarker && latLngSet) {
            float results[] = new float[1];
            resultsCloseEnough = false;

            for (CustomAddress addressToCheck : addresses) {
                Location.distanceBetween(latitude, longitude,
                        addressToCheck.getLatitude(), addressToCheck.getLongitude(), results);
                if (results[0] < GEOCODING_MAX_ERROR) {
                    resultsCloseEnough = true;
                    break;
                }
            }
        }

        if ((addresses == null) || addresses.isEmpty() || !resultsCloseEnough) {
            if (addresses == null) {
                addresses = new ArrayList<CustomAddress>();
            }
            Log.e(TAG, "Geocoder did not find enough addresses: " + addresses);
        }

        addresses = filterAddressesBBox(region, addresses);

        if (geocodingForMarker && latLngSet && addresses != null && !addresses.isEmpty()) {
            float results[] = new float[1];
            float minDistanceToOriginalLatLon = Float.MAX_VALUE;
            CustomAddress closestAddress = addresses.get(0);

            for (CustomAddress addressToCheck : addresses) {
                Location.distanceBetween(latitude, longitude,
                        addressToCheck.getLatitude(), addressToCheck.getLongitude(), results);
                if (results[0] < minDistanceToOriginalLatLon) {
                    closestAddress = addressToCheck;
                    minDistanceToOriginalLatLon = results[0];
                }
            }
            addressesReturn.add(closestAddress);
        } else {
            addressesReturn.addAll(addresses);
        }

        return addressesReturn;
    }

    
    private static List<CustomAddress> filterAddressesBBox(ObaRegion region, List<CustomAddress> addresses) {
        if ((!(addresses == null || addresses.isEmpty())) && region != null) {
            for (Iterator<CustomAddress> it = addresses.iterator(); it.hasNext(); ) {
                CustomAddress address = it.next();

                Location loc = new Location("");
                loc.setLatitude(address.getLatitude());
                loc.setLongitude(address.getLongitude());

                if (!RegionUtils.isLocationWithinRegion(loc, region)) {
                    it.remove();
                }
            }
        }
        return addresses;
    }

}
