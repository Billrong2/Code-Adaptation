{
  "code": "@Override\nprotected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n    if (!changed) {\n        return;\n    }\n\n    // Basic hardening checks\n    if (mCamera == null || mPreviewSize == null || mCameraView == null) {\n        return;\n    }\n\n    final int parentWidth = right - left;\n    final int parentHeight = bottom - top;\n    if (parentWidth <= 0 || parentHeight <= 0) {\n        return;\n    }\n\n    // Determine device rotation\n    int rotation = android.view.Surface.ROTATION_0;\n    try {\n        android.view.WindowManager wm = (android.view.WindowManager) mContext.getSystemService(android.content.Context.WINDOW_SERVICE);\n        if (wm != null) {\n            android.view.Display display = wm.getDefaultDisplay();\n            rotation = display.getRotation();\n        }\n    } catch (Exception e) {\n        android.util.Log.w(\"CameraPreview\", \"Failed to get display rotation\", e);\n    }\n\n    // Derive preview width/height based on rotation\n    int previewWidth;\n    int previewHeight;\n    int displayOrientation;\n    switch (rotation) {\n        case android.view.Surface.ROTATION_90:\n            previewWidth = mPreviewSize.height;\n            previewHeight = mPreviewSize.width;\n            displayOrientation = 90;\n            break;\n        case android.view.Surface.ROTATION_180:\n            previewWidth = mPreviewSize.width;\n            previewHeight = mPreviewSize.height;\n            displayOrientation = 180;\n            break;\n        case android.view.Surface.ROTATION_270:\n            previewWidth = mPreviewSize.height;\n            previewHeight = mPreviewSize.width;\n            displayOrientation = 270;\n            break;\n        case android.view.Surface.ROTATION_0:\n        default:\n            previewWidth = mPreviewSize.width;\n            previewHeight = mPreviewSize.height;\n            displayOrientation = 0;\n            break;\n    }\n\n    if (previewWidth <= 0 || previewHeight <= 0) {\n        return;\n    }\n\n    // Apply camera display orientation safely\n    try {\n        mCamera.setDisplayOrientation(displayOrientation);\n    } catch (RuntimeException e) {\n        android.util.Log.w(\"CameraPreview\", \"Failed to set camera display orientation\", e);\n    }\n\n    // Scale preview to fit parent width while preserving aspect ratio\n    float aspectRatio = (float) previewHeight / (float) previewWidth;\n    int scaledHeight = (int) (parentWidth * aspectRatio);\n    if (scaledHeight <= 0) {\n        return;\n    }\n\n    // Bottom-align the preview within the container\n    int childLeft = 0;\n    int childTop = parentHeight - scaledHeight;\n    if (childTop < 0) {\n        childTop = 0;\n    }\n    int childRight = parentWidth;\n    int childBottom = childTop + scaledHeight;\n\n    layout(childLeft, childTop, childRight, childBottom);\n}\n",
  "explanation": "code_hardening: Added null checks for mCamera, mPreviewSize, mCameraView, and guarded against zero/negative parent and preview dimensions. Ensured layout logic only runs when changed == true and added default handling for unexpected rotation values.\nresolve_compilation_errors: Implemented the correct Android View override signature onLayout(boolean, int, int, int, int) and relied only on existing fields in CameraPreview. Used fully qualified Android framework class names (android.view.Surface, android.view.WindowManager, android.view.Display) to avoid missing imports. No calls to getOptimalPreviewSize remain.\nexception_handling: Wrapped display rotation lookup and mCamera.setDisplayOrientation(int) in try/catch blocks and logged warnings to prevent crashes if the camera or window manager is in an invalid state.\nlogic_customization: Replaced preview-size scanning with orientation-aware width/height derivation from the existing mPreviewSize, determined device rotation, swapped dimensions as needed, set the camera display orientation, computed scaled preview height based on parent width while preserving aspect ratio, and bottom-aligned the preview within its container.\nrefactoring: Renamed local variables to clearly reflect responsibilities (previewWidth, previewHeight, scaledHeight, parentWidth/parentHeight) and removed all aspect-ratio scanning logic in favor of direct layout computation within onLayout.\nmisc: Updated inline comments to describe onLayout-based behavior reacting to layout and rotation changes and followed standard Android view layout conventions for readability. No new custom project-specific APIs were introduced."
}