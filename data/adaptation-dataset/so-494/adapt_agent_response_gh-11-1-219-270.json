{
  "code": "private static <T> List<Class<?>> getTypeArguments(Class<T> baseClass, Class<? extends T> childClass) {\n        if (baseClass == null || childClass == null) {\n            throw new IllegalArgumentException(\"baseClass and childClass must not be null\");\n        }\n\n        Map<TypeVariable<?>, Type> resolvedTypes = new HashMap<>();\n        Class<?> currentClass = childClass;\n        Type currentType = currentClass.getGenericSuperclass();\n\n        // Walk up the inheritance hierarchy until we reach the base class or Object\n        while (currentClass != null && !baseClass.equals(currentClass)) {\n            if (currentType instanceof ParameterizedType) {\n                ParameterizedType parameterizedType = (ParameterizedType) currentType;\n                Class<?> rawType = (Class<?>) parameterizedType.getRawType();\n\n                TypeVariable<?>[] typeParameters = rawType.getTypeParameters();\n                Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n\n                for (int i = 0; i < typeParameters.length && i < actualTypeArguments.length; i++) {\n                    resolvedTypes.put(typeParameters[i], actualTypeArguments[i]);\n                }\n\n                currentClass = rawType;\n            } else if (currentType instanceof Class) {\n                currentClass = (Class<?>) currentType;\n            } else {\n                // Unexpected Type implementation; fail fast for easier debugging\n                throw new IllegalArgumentException(\"Unsupported Type while resolving generics: \" + currentType);\n            }\n\n            if (currentClass == Object.class) {\n                break;\n            }\n            currentType = currentClass.getGenericSuperclass();\n        }\n\n        if (!baseClass.equals(currentClass)) {\n            throw new IllegalArgumentException(\"Child class does not inherit from base class: \" + baseClass);\n        }\n\n        // Resolve the base class type arguments\n        List<Class<?>> typeArgumentsAsClasses = new ArrayList<>();\n        Type baseType = currentType;\n        Type[] baseTypeArguments;\n\n        if (baseType instanceof ParameterizedType) {\n            baseTypeArguments = ((ParameterizedType) baseType).getActualTypeArguments();\n        } else {\n            // Raw base class: use its type parameters\n            TypeVariable<?>[] typeParameters = baseClass.getTypeParameters();\n            baseTypeArguments = new Type[typeParameters.length];\n            System.arraycopy(typeParameters, 0, baseTypeArguments, 0, typeParameters.length);\n        }\n\n        for (Type baseTypeArgument : baseTypeArguments) {\n            Type resolvedType = baseTypeArgument;\n            // Substitute type variables until a concrete type is reached\n            while (resolvedType instanceof TypeVariable && resolvedTypes.containsKey(resolvedType)) {\n                resolvedType = resolvedTypes.get(resolvedType);\n            }\n\n            Class<?> resolvedClass = getClass(resolvedType);\n            if (resolvedClass == null) {\n                throw new IllegalArgumentException(\"Could not resolve generic type to Class: \" + resolvedType);\n            }\n            typeArgumentsAsClasses.add(resolvedClass);\n        }\n\n        return typeArgumentsAsClasses;\n    }",
  "explanation": "code_hardening: Added null checks for baseClass and childClass, guarded traversal by stopping at Object.class, validated that the base class is actually reached, and ensured the returned list never contains null by failing fast if a type cannot be resolved.\nresolve_compilation_errors: Used existing imports (TypeVariable, ParameterizedType, Map, HashMap, List, ArrayList) already present in the file, declared and scoped the type-variable mapping, and applied proper generic bounds in the method signature.\nexception_handling: Chose to fail fast with descriptive IllegalArgumentException messages when encountering unsupported Type implementations, incorrect inheritance assumptions, or unresolvable generic types, avoiding silent ClassCastException or null propagation.\nlogic_customization: Implemented inheritance traversal using getGenericSuperclass(), recorded TypeVariable-to-Type mappings for parameterized superclasses, resolved base class type arguments through repeated substitution, and converted final Types to raw Class objects using the existing getClass(Type) helper without modifying it.\nrefactoring: Introduced the new private static getTypeArguments method, used intention-revealing variable names (resolvedTypes, currentClass, currentType), and organized the logic into clear traversal, resolution, and conversion phases.\nmisc: Added minimal inline comments to explain each logical block and aligned formatting with the surrounding code style; no new custom API calls were introduced beyond standard reflection usage."
}