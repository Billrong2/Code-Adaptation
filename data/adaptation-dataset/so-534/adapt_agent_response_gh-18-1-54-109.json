{
  "code": "public UnicodeReader(InputStream in, Charset defaultCharset) throws IOException {\n\t\tif (in == null) {\n\t\t\tthrow new NullPointerException(\"InputStream must not be null\");\n\t\t}\n\n\t\tfinal byte[] bom = new byte[BOM_SIZE];\n\t\tfinal PushbackInputStream pushbackStream = new PushbackInputStream(in, BOM_SIZE);\n\t\tfinal int n = pushbackStream.read(bom, 0, bom.length);\n\n\t\tfinal Charset charset;\n\t\tfinal int unread;\n\n\t\t// Read ahead up to four bytes and check for BOM marks.\n\t\tif (n >= 3 && (bom[0] == (byte) 0xEF) && (bom[1] == (byte) 0xBB) && (bom[2] == (byte) 0xBF)) {\n\t\t\tcharset = Charset.forName(\"UTF-8\");\n\t\t\tunread = n - 3;\n\t\t} else if (n >= 2 && (bom[0] == (byte) 0xFE) && (bom[1] == (byte) 0xFF)) {\n\t\t\tcharset = Charset.forName(\"UTF-16BE\");\n\t\t\tunread = n - 2;\n\t\t} else if (n >= 2 && (bom[0] == (byte) 0xFF) && (bom[1] == (byte) 0xFE)) {\n\t\t\tcharset = Charset.forName(\"UTF-16LE\");\n\t\t\tunread = n - 2;\n\t\t} else if (n >= 4 && (bom[0] == (byte) 0x00) && (bom[1] == (byte) 0x00) && (bom[2] == (byte) 0xFE) && (bom[3] == (byte) 0xFF)) {\n\t\t\tcharset = Charset.forName(\"UTF-32BE\");\n\t\t\tunread = n - 4;\n\t\t} else if (n >= 4 && (bom[0] == (byte) 0xFF) && (bom[1] == (byte) 0xFE) && (bom[2] == (byte) 0x00) && (bom[3] == (byte) 0x00)) {\n\t\t\tcharset = Charset.forName(\"UTF-32LE\");\n\t\t\tunread = n - 4;\n\t\t} else {\n\t\t\tcharset = defaultCharset != null ? defaultCharset : Charset.defaultCharset();\n\t\t\tunread = n;\n\t\t}\n\n\t\t// Unread bytes if necessary and skip BOM marks.\n\t\tif (unread > 0) {\n\t\t\tpushbackStream.unread(bom, n - unread, unread);\n\t\t}\n\n\t\tthis.reader = new InputStreamReader(pushbackStream, charset);\n\t}",
  "explanation": "code_hardening: Added a null check for the InputStream and made local variables final where applicable. Explicitly documented behavior through code that the provided InputStream is not closed here. Centralized Charset resolution per branch.\nresolve_compilation_errors: Introduced a constructor accepting Charset instead of String, matching the delegating constructor already present. Replaced all String-based InputStreamReader usage with the Charset-based constructor and used java.nio.charset.Charset explicitly.\nexception_handling: Allowed IllegalCharsetNameException and UnsupportedCharsetException from Charset.forName to propagate as runtime exceptions, keeping the existing IOException contract unchanged.\nlogic_customization: Replaced string-based encoding detection with Charset.forName for BOM-detected encodings. When no BOM is found and defaultCharset is null, explicitly used Charset.defaultCharset(). Preserved existing BOM detection and pushback logic without semantic changes.\nrefactoring: Renamed conceptual variables from encoding to charset for clarity and simplified the final reader construction to a single code path using Charset.\nmisc: Updated comments to refer to Charset usage and clarified that BOM bytes are skipped. No new custom APIs beyond java.nio.charset.Charset.forName and Charset.defaultCharset were introduced."
}