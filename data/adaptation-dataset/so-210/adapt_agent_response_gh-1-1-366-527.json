{
"code":"public static String reshape_reverse(String str) {\n    // Reverse-direction Arabic shaping: neighbors are interpreted as next/current/previous\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    // Padding increased to safely allow i+3 lookups when scanning ahead for diacritics\n    String temp = \"    \" + str + \"    \";\n    StringBuilder reshaped = new StringBuilder(str.length());\n\n    int len = str.length();\n    int i = 0;\n\n    while (i < len) {\n        // reversed semantics\n        char post = temp.charAt(i + 2);      // previous logical character\n        char at = temp.charAt(i + 3);        // current logical character\n        char pre = temp.charAt(i + 4);       // next logical character\n\n        int whichCase = getCase(at);\n        int postCase = getCase(post);\n        int preCase = getCase(pre);\n\n        // compute pre_step based on reversed joining direction\n        int pre_step = 0;\n\n        // Skip diacritics when determining the effective preceding joiner (scan ahead)\n        if (preCase == TASHKEEL) {\n            // look further ahead for the real joining character\n            int scanIndex = i + 5;\n            char scanChar = ' ';\n            int scanCase = 0;\n            while (scanIndex < temp.length()) {\n                scanChar = temp.charAt(scanIndex);\n                scanCase = getCase(scanChar);\n                if (scanCase != TASHKEEL) {\n                    break;\n                }\n                scanIndex++;\n            }\n            pre = scanChar;\n            preCase = scanCase;\n        }\n\n        if ((preCase & LEFT_CHAR_MASK) == LEFT_CHAR_MASK) {\n            pre_step = 1;\n        }\n\n        switch (whichCase & 0x000F) {\n            case NOTUSED_CHAR:\n            case NOTARABIC_CHAR:\n                reshaped.append(at);\n                i++;\n                continue;\n\n            case NORIGHT_NOLEFT_CHAR:\n            case TATWEEL_CHAR:\n                reshaped.append(getShape(at, 0));\n                i++;\n                continue;\n\n            case RIGHT_NOLEFT_CHAR_ALEF:\n                // Inverted Lam–Alef logic: detect preceding LAM in reversed context\n                if ((postCase & 0x000F) == RIGHT_LEFT_CHAR_LAM) {\n                    // recompute pre_step after consuming ligature\n                    int newPreStep = pre_step;\n                    reshaped.append(getShape(at, newPreStep + 2));\n                    i += 2; // consume ALEF + LAM\n                    continue;\n                }\n                reshaped.append(getShape(at, pre_step));\n                i++;\n                continue;\n\n            case RIGHT_LEFT_CHAR:\n            case RIGHT_LEFT_CHAR_LAM:\n                // General joining logic (LAM merged here; ligature handled above)\n                if ((postCase & RIGHT_NOLEFT_CHAR_MASK) == RIGHT_NOLEFT_CHAR_MASK) {\n                    reshaped.append(getShape(at, 2 + pre_step));\n                    i++;\n                    continue;\n                } else if (postCase == TANWEEN) {\n                    reshaped.append(getShape(at, pre_step));\n                    i++;\n                    continue;\n                } else if (postCase == TASHKEEL) {\n                    // look further back (reversed) to decide joining\n                    char postPost = (i + 1 >= 0) ? temp.charAt(i + 1) : ' ';\n                    int postPostCase = getCase(postPost);\n                    if ((postPostCase & RIGHT_NOLEFT_CHAR_MASK) == RIGHT_NOLEFT_CHAR_MASK) {\n                        reshaped.append(getShape(at, 2 + pre_step));\n                        i++;\n                        continue;\n                    } else {\n                        reshaped.append(getShape(at, pre_step));\n                        i++;\n                        continue;\n                    }\n                } else {\n                    reshaped.append(getShape(at, pre_step));\n                    i++;\n                    continue;\n                }\n\n            case RIGHT_NOLEFT_CHAR:\n                reshaped.append(getShape(at, pre_step));\n                i++;\n                continue;\n\n            case TASHKEEL:\n            case TANWEEN:\n                reshaped.append(getShape(at, 0));\n                i++;\n                continue;\n\n            default:\n                reshaped.append(getShape(at, 0));\n                i++;\n        }\n    }\n\n    return reshaped.toString();\n}",
"explanation":"code_hardening: Added null/empty input validation, increased padding to four spaces to safely support i+3 and further lookups, and guarded scan loops when skipping diacritics to avoid out-of-range access.\nresolve_compilation_errors: Renamed the method to reshape_reverse, initialized all reversed-context variables explicitly, and relied only on existing project constants and methods (getCase, getShape) already declared in the class.\nexception_handling: none.\nlogic_customization: Reversed neighbor interpretation so post/at/pre map to previous/current/next characters, inverted Lam–Alef ligature detection into the ALEF branch by looking back to LAM, consumed two characters on ligature detection, recomputed pre_step after diacritic skipping by scanning ahead, disabled old forward ALEF-post logic, merged RIGHT_LEFT_CHAR_LAM into general RIGHT_LEFT_CHAR handling, and applied all existing shaping rules using the reversed semantics.\nrefactoring: Renamed locals to clarify reversed semantics (post/at/pre), consolidated duplicated joining logic between RIGHT_LEFT_CHAR and LAM, and removed obsolete forward-direction ligature code paths.\nmisc: Updated inline comments to document reverse-direction shaping behavior and reformatted control flow for readability after logic inversion. New custom API calls: none."}