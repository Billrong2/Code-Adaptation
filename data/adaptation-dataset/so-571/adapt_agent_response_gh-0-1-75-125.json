{
  "code": "/**\n\t * Decomposes a floating-point value into a normalized mantissa and an exponent,\n\t * such that {@code value = mantissa * 2^exponent}. The mantissa is adjusted to\n\t * lie in the interval [0.5, 1.0) (or the corresponding signed range), while\n\t * preserving special-case behavior for zero, NaN, and infinity.\n\t *\n\t * @param value\n\t *            the floating-point value to decompose\n\t * @return an {@link ExponentAndMantissa} containing the mantissa and exponent\n\t */\n\tpublic static ExponentAndMantissa frexp(double value) {\n\t\tExponentAndMantissa ret = new ExponentAndMantissa();\n\n\t\tret.exponent = 0;\n\t\tret.mantissa = 0;\n\n\t\tif (value == 0.0 || value == -0.0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (Double.isNaN(value)) {\n\t\t\tret.mantissa = Double.NaN;\n\t\t\tret.exponent = -1;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (Double.isInfinite(value)) {\n\t\t\tret.mantissa = value;\n\t\t\tret.exponent = -1;\n\t\t\treturn ret;\n\t\t}\n\n\t\tret.mantissa = value;\n\t\tret.exponent = 0;\n\t\tint sign = 1;\n\n\t\tif (ret.mantissa < 0f) {\n\t\t\tsign--;\n\t\t\tret.mantissa = -(ret.mantissa);\n\t\t}\n\t\twhile (ret.mantissa < 0.5f) {\n\t\t\tret.mantissa *= 2.0f;\n\t\t\tret.exponent -= 1;\n\t\t}\n\t\twhile (ret.mantissa >= 1.0f) {\n\t\t\tret.mantissa *= 0.5f;\n\t\t\tret.exponent++;\n\t\t}\n\t\tret.mantissa *= sign;\n\t\treturn ret;\n\t}",
  "explanation": "code_hardening: none; the original computational logic and edge-case behavior were preserved exactly without adding new checks or modifiers.\nresolve_compilation_errors: updated the method to be static and replaced the FRexPHolder return/holder type with MathUtils.ExponentAndMantissa, updating the local variable declaration and field assignments to use the existing exponent and mantissa fields.\nexception_handling: none; no try-catch or throws clauses were introduced, matching the original behavior.\nlogic_customization: none; normalization loops, sign handling, and NaN/infinity/zero handling remain unchanged from the source snippet.\nrefactoring: converted the method to a class-level static utility method and refactored only the holder type name as required, without altering constants, control flow, or arithmetic.\nmisc: added descriptive Javadoc documenting the purpose of the method, its parameter, and its return value; no new custom API calls were introduced."
}