{
  "code": "public static String getRelativePath(String targetPath, String basePath, String pathSeparator) {\n        // Normalize the paths\n        String normalizedTargetPath = FilenameUtils.normalizeNoEndSeparator(targetPath);\n        String normalizedBasePath = FilenameUtils.normalizeNoEndSeparator(basePath);\n\n        // Undo the changes to the separators made by normalization\n        if (\"/\".equals(pathSeparator)) {\n            normalizedTargetPath = FilenameUtils.separatorsToUnix(normalizedTargetPath);\n            normalizedBasePath = FilenameUtils.separatorsToUnix(normalizedBasePath);\n        } else if (\"\\\\\".equals(pathSeparator)) {\n            normalizedTargetPath = FilenameUtils.separatorsToWindows(normalizedTargetPath);\n            normalizedBasePath = FilenameUtils.separatorsToWindows(normalizedBasePath);\n        } else {\n            throw new IllegalArgumentException(\"Unrecognised dir separator '\" + pathSeparator + \"'\");\n        }\n\n        String[] base = normalizedBasePath.split(Pattern.quote(pathSeparator));\n        String[] target = normalizedTargetPath.split(Pattern.quote(pathSeparator));\n\n        // First get all the common elements. Store them as a string,\n        // and also count how many of them there are.\n        StringBuffer common = new StringBuffer();\n        int commonIndex = 0;\n        while (commonIndex < target.length\n                && commonIndex < base.length\n                && target[commonIndex].equalsIgnoreCase(base[commonIndex])) {\n            common.append(target[commonIndex]).append(pathSeparator);\n            commonIndex++;\n        }\n\n        if (commonIndex == 0) {\n            // No single common path element. This most\n            // likely indicates differing drive letters, like C: and D:.\n            // These paths cannot be relativized.\n            throw new PathResolutionException(\n                    \"No common path element found for '\" + normalizedTargetPath + \"' and '\" + normalizedBasePath + \"'\");\n        }\n\n        // The number of directories we have to backtrack depends on whether the base is a file or a dir\n        boolean baseIsFile = true;\n        File baseResource = new File(normalizedBasePath);\n        if (baseResource.exists()) {\n            baseIsFile = baseResource.isFile();\n        } else if (basePath.endsWith(pathSeparator)) {\n            baseIsFile = false;\n        }\n\n        StringBuffer relative = new StringBuffer();\n        if (base.length != commonIndex) {\n            int numDirsUp = baseIsFile ? base.length - commonIndex - 1 : base.length - commonIndex;\n            for (int i = 0; i < numDirsUp; i++) {\n                relative.append(\"..\").append(pathSeparator);\n            }\n        }\n\n        relative.append(normalizedTargetPath.substring(common.length()));\n        return relative.toString();\n    }",
  "explanation": "code_hardening: none\nresolve_compilation_errors: Verified that PathResolutionException exists as an inner class of ResourceUtil and reused it directly; no replacement or new imports were needed.\nexception_handling: none\nlogic_customization: Changed the common-path detection loop to compare path segments using case-insensitive equality via String.equalsIgnoreCase, while keeping the accumulation of the common path and all subsequent relative-path logic unchanged.\nrefactoring: none\nmisc: none"
}