{
  "code": "public static String getRelativePath(String targetPath, String basePath, String pathSeparator) {\n\t// ---- code hardening: null/empty validation ----\n\tif (targetPath == null || basePath == null) {\n\t\tthrow new PathResolutionException(java.util.ResourceBundle.getBundle(\"net.rptools.maptool.launcher.Messages\")\n\t\t\t\t.getString(\"path.relative.null\"));\n\t}\n\tif (pathSeparator == null || pathSeparator.length() != 1) {\n\t\tthrow new PathResolutionException(java.util.ResourceBundle.getBundle(\"net.rptools.maptool.launcher.Messages\")\n\t\t\t\t.getString(\"path.relative.badSeparator\"));\n\t}\n\n\tfinal char separator = pathSeparator.charAt(0);\n\tif (separator != UNIX_SEPARATOR && separator != WINDOWS_SEPARATOR) {\n\t\tthrow new PathResolutionException(java.util.ResourceBundle.getBundle(\"net.rptools.maptool.launcher.Messages\")\n\t\t\t\t.getString(\"path.relative.badSeparator\"));\n\t}\n\n\t// ---- normalize paths (no end separator) ----\n\tString normalizedTargetPath = normalizeNoEndSeparator(targetPath, separator == UNIX_SEPARATOR);\n\tString normalizedBasePath = normalizeNoEndSeparator(basePath, separator == UNIX_SEPARATOR);\n\n\tif (normalizedTargetPath == null || normalizedBasePath == null) {\n\t\tthrow new PathResolutionException(java.util.ResourceBundle.getBundle(\"net.rptools.maptool.launcher.Messages\")\n\t\t\t\t.getString(\"path.relative.normalizeFailed\"));\n\t}\n\n\t// ---- unify separators explicitly ----\n\tif (separator == UNIX_SEPARATOR) {\n\t\tnormalizedTargetPath = separatorsToUnix(normalizedTargetPath);\n\t\tnormalizedBasePath = separatorsToUnix(normalizedBasePath);\n\t} else {\n\t\tnormalizedTargetPath = separatorsToWindows(normalizedTargetPath);\n\t\tnormalizedBasePath = separatorsToWindows(normalizedBasePath);\n\t}\n\n\t// ---- identical paths edge case ----\n\tif (normalizedTargetPath.equals(normalizedBasePath)) {\n\t\treturn \".\";\n\t}\n\n\tfinal String sepRegex = java.util.regex.Pattern.quote(String.valueOf(separator));\n\tfinal String[] targetSegments = normalizedTargetPath.split(sepRegex);\n\tfinal String[] baseSegments = normalizedBasePath.split(sepRegex);\n\n\t// ---- find common prefix ----\n\tStringBuilder commonBuilder = new StringBuilder();\n\tint commonIndex = 0;\n\twhile (commonIndex < targetSegments.length && commonIndex < baseSegments.length\n\t\t\t&& targetSegments[commonIndex].equals(baseSegments[commonIndex])) {\n\t\tcommonBuilder.append(targetSegments[commonIndex]).append(separator);\n\t\tcommonIndex++;\n\t}\n\n\tif (commonIndex == 0) {\n\t\tthrow new PathResolutionException(java.util.ResourceBundle.getBundle(\"net.rptools.maptool.launcher.Messages\")\n\t\t\t\t.getString(\"path.relative.noCommon\"));\n\t}\n\n\t// ---- determine if base is file or directory (new precedence rules) ----\n\tboolean baseIsFile;\n\tif (basePath.endsWith(String.valueOf(separator))) {\n\t\tbaseIsFile = false;\n\t} else {\n\t\tjava.io.File baseFile = new java.io.File(normalizedBasePath);\n\t\tbaseIsFile = baseFile.exists() ? baseFile.isFile() : true;\n\t}\n\n\t// ---- backtracking ----\n\tStringBuilder relativeBuilder = new StringBuilder();\n\tif (baseSegments.length != commonIndex) {\n\t\tint numDirsUp = baseIsFile ? (baseSegments.length - commonIndex - 1)\n\t\t\t\t\t\t\t: (baseSegments.length - commonIndex);\n\t\tfor (int i = 0; i < numDirsUp; i++) {\n\t\t\trelativeBuilder.append(\"..\").append(separator);\n\t\t}\n\t}\n\n\t// ---- append target remainder with separator correction ----\n\tint sliceStart = commonBuilder.length();\n\tif (sliceStart > 0 && sliceStart < normalizedTargetPath.length()\n\t\t\t&& normalizedTargetPath.charAt(sliceStart) == separator) {\n\t\tsliceStart++;\n\t}\n\tif (sliceStart < normalizedTargetPath.length()) {\n\t\trelativeBuilder.append(normalizedTargetPath.substring(sliceStart));\n\t}\n\n\tString result = relativeBuilder.toString();\n\n\t// ---- trim trailing separator for backtracking-only results ----\n\tif (result.endsWith(String.valueOf(separator)) && result.startsWith(\"..\")) {\n\t\tresult = result.substring(0, result.length() - 1);\n\t}\n\n\treturn result;\n}",
  "explanation": "code_hardening: Added null and empty validation for inputs, enforced single-character separator validation, switched to StringBuilder, centralized separator handling, and trimmed trailing separators for backtracking-only outputs.\nresolve_compilation_errors: Used existing PathUtils methods (normalizeNoEndSeparator, separatorsToUnix, separatorsToWindows) and fully qualified java.util.regex.Pattern, java.io.File, and java.util.ResourceBundle to avoid import issues.\nexception_handling: Replaced hard-coded messages with ResourceBundle-based lookups and standardized failures to PathResolutionException for invalid separators, normalization failure, and no-common-path cases.\nlogic_customization: Implemented identical-path handling returning \".\"; changed base path type detection precedence to prefer trailing-separator directory inference before filesystem checks; fixed substring index logic to avoid extra leading separators.\nrefactoring: Renamed locals for clarity (commonIndex, normalizedTargetPath), simplified separator logic to char-based handling, and restructured the function for readability without altering the core algorithm.\nmisc: Updated inline comments to document new edge-case handling and precedence rules; formatting adjusted for consistency. New custom API usage: java.util.ResourceBundle.getBundle(String) for localized messages."
}