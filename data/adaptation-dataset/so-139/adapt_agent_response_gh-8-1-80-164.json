{
  "code": "public static String getRelativePath(String basePath, String targetPath, String pathSeparator) {\n    // Normalize inputs using project utility; handle nulls per contract\n    String normalizedTarget = normalizeNoEndSeparator(targetPath, pathSeparator);\n    if (normalizedTarget == null) {\n      return \"\";\n    }\n\n    String normalizedBase = normalizeNoEndSeparator(basePath, pathSeparator);\n    if (normalizedBase == null) {\n      return targetPath;\n    }\n\n    // Split paths into segments\n    String[] baseParts = normalizedBase.split(Pattern.quote(pathSeparator));\n    String[] targetParts = normalizedTarget.split(Pattern.quote(pathSeparator));\n\n    // Find common prefix\n    StringBuilder common = new StringBuilder();\n    int commonIndex = 0;\n    while (commonIndex < targetParts.length && commonIndex < baseParts.length\n        && targetParts[commonIndex].equals(baseParts[commonIndex])) {\n      common.append(targetParts[commonIndex]).append(pathSeparator);\n      commonIndex++;\n    }\n\n    // If there is no common prefix, return normalized target as a safe fallback\n    if (commonIndex == 0) {\n      return normalizedTarget;\n    }\n\n    // Heuristic to determine whether base refers to a file or directory\n    boolean baseIsFile = true;\n    try {\n      java.io.File baseResource = new java.io.File(normalizedBase);\n      if (baseResource.exists()) {\n        baseIsFile = baseResource.isFile();\n      } else if (basePath != null && basePath.endsWith(pathSeparator)) {\n        baseIsFile = false;\n      }\n    } catch (Exception ignore) {\n      // Fallback to default heuristic without throwing\n    }\n\n    StringBuilder relative = new StringBuilder();\n\n    if (baseParts.length != commonIndex) {\n      int numDirsUp = baseIsFile ? baseParts.length - commonIndex - 1 : baseParts.length - commonIndex;\n      for (int i = 0; i < numDirsUp; i++) {\n        relative.append(\"..\").append(pathSeparator);\n      }\n    }\n\n    // Append the remaining target path safely\n    relative.append(safeSubstring(normalizedTarget, common.length()));\n    return relative.toString();\n  }",
  "explanation": "code_hardening: Added null checks for inputs via normalization results, defined safe fallbacks for null normalized paths, guarded filesystem checks with try/catch, and used safeSubstring to avoid out-of-bounds errors.\nresolve_compilation_errors: Updated the method signature to (basePath, targetPath, pathSeparator), removed all FilenameUtils usage from this function, replaced StringBuffer with StringBuilder, avoided PathResolutionException, and used fully qualified java.io.File where needed.\nexception_handling: Eliminated IllegalArgumentException for unknown separators and removed exceptions for no common path elements; all edge cases now return valid strings instead of throwing.\nlogic_customization: Normalization now relies on the projectâ€™s normalizeNoEndSeparator(path, separator), respects the provided separator directly, applies new null-handling rules, swaps base/target logic, and returns the normalized target when no common prefix exists.\nrefactoring: Renamed parameters and locals to reflect new parameter order, simplified builder appends, and streamlined conditional branches around common-prefix and directory traversal logic.\nmisc: Updated inline comments to reflect new behavior and ensured formatting and style consistency with the surrounding utility methods. New custom API calls used: normalizeNoEndSeparator(String, String) and safeSubstring(String, int) from the same class."
}