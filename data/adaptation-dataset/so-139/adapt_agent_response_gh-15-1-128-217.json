{
  "code": "public static String getRelativePath(String targetPath, String basePath) throws PathResolutionException {\n        // Null-safety\n        if (targetPath == null || basePath == null) {\n            return null;\n        }\n\n        final String separator = java.io.File.separator;\n\n        // Normalize paths without trailing separators\n        String normalizedTargetPath = FilenameUtils.normalizeNoEndSeparator(targetPath);\n        String normalizedBasePath = FilenameUtils.normalizeNoEndSeparator(basePath);\n\n        if (normalizedTargetPath == null || normalizedBasePath == null) {\n            return null;\n        }\n\n        // Identical-path handling (ignore trailing separators via normalization)\n        if (FilenameUtils.equalsNormalizedOnSystem(normalizedTargetPath, normalizedBasePath)) {\n            return \"\";\n        }\n\n        String[] baseParts = normalizedBasePath.split(java.util.regex.Pattern.quote(separator));\n        String[] targetParts = normalizedTargetPath.split(java.util.regex.Pattern.quote(separator));\n\n        // Find common path prefix\n        StringBuilder commonBuilder = new StringBuilder();\n        int commonIndex = 0;\n        while (commonIndex < targetParts.length && commonIndex < baseParts.length\n                && targetParts[commonIndex].equals(baseParts[commonIndex])) {\n            commonBuilder.append(targetParts[commonIndex]).append(separator);\n            commonIndex++;\n        }\n\n        if (commonIndex == 0) {\n            // Likely different roots (e.g., different drive letters)\n            throw new PathResolutionException(\n                    \"No common path element for '\" + normalizedTargetPath + \"' and '\" + normalizedBasePath + \"'\");\n        }\n\n        // Heuristic to determine whether base is a file or directory\n        boolean baseIsFile = true;\n        java.io.File baseResource = new java.io.File(normalizedBasePath);\n        if (baseResource.exists()) {\n            baseIsFile = baseResource.isFile();\n        } else if (basePath.endsWith(separator)) {\n            baseIsFile = false;\n        }\n\n        StringBuilder relativeBuilder = new StringBuilder();\n\n        if (baseParts.length != commonIndex) {\n            int numDirsUp = baseIsFile\n                    ? baseParts.length - commonIndex - 1\n                    : baseParts.length - commonIndex;\n\n            for (int i = 0; i < numDirsUp; i++) {\n                relativeBuilder.append(\"..\").append(separator);\n            }\n        }\n\n        int commonLength = commonBuilder.length();\n        if (commonLength < normalizedTargetPath.length()) {\n            relativeBuilder.append(normalizedTargetPath.substring(commonLength));\n        }\n\n        return relativeBuilder.toString();\n    }",
  "explanation": "code_hardening: Added explicit null checks for targetPath and basePath and returned null early; validated normalized results; guarded substring usage by checking lengths; relied consistently on File.separator to avoid platform mismatches.\nresolve_compilation_errors: Removed the pathSeparator parameter and all related branching; updated the method signature to declare throws PathResolutionException; replaced StringBuffer with StringBuilder; used fully qualified names where helpful (java.io.File, java.util.regex.Pattern).\nexception_handling: Declared throws PathResolutionException in the signature and preserved the existing behavior of throwing it when no common path element exists, with slightly clarified message wording.\nlogic_customization: Added identical-path detection using normalized, system-aware comparison and returned an empty string in that case; simplified separator handling to use the platform default; ensured the base-is-file heuristic still works with the new separator logic.\nrefactoring: Renamed locals for clarity (e.g., *Parts, *Builder); simplified common-prefix accumulation and relative-path construction; replaced StringBuffer with StringBuilder.\nmisc: Updated inline comments to reflect new behavior (no injected separator, identical-path handling). New custom API calls used: none."
}