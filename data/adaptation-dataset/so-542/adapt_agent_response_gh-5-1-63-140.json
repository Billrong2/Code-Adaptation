{
  "code": "private void init() {\n\tsetClickable(true);\n\tmScaleDetector = new ScaleGestureDetector(getContext(), new ScaleListener());\n\tm = new float[9];\n\tsetScaleType(ScaleType.MATRIX);\n\n\tsetOnTouchListener(new OnTouchListener() {\n\t\t@Override\n\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\tif (event == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Always let the scale detector inspect the event first\n\t\t\tmScaleDetector.onTouchEvent(event);\n\n\t\t\tmatrix.getValues(m);\n\t\t\tfloat x = m[Matrix.MTRANS_X];\n\t\t\tfloat y = m[Matrix.MTRANS_Y];\n\t\t\tPointF curr = new PointF(event.getX(), event.getY());\n\n\t\t\tswitch (event.getActionMasked()) {\n\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\tlast.set(curr);\n\t\t\t\tstart.set(curr);\n\t\t\t\tmode = DRAG;\n\t\t\t\tbreak;\n\n\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\tif (mode == DRAG) {\n\t\t\t\t\tfloat deltaX = curr.x - last.x;\n\t\t\t\t\tfloat deltaY = curr.y - last.y;\n\n\t\t\t\t\tfloat scaleWidth = Math.round(origWidth * saveScale);\n\t\t\t\t\tfloat scaleHeight = Math.round(origHeight * saveScale);\n\n\t\t\t\t\tif (scaleWidth < width) {\n\t\t\t\t\t\tdeltaX = 0;\n\t\t\t\t\t\tif (y + deltaY > 0)\n\t\t\t\t\t\t\tdeltaY = -y;\n\t\t\t\t\t\telse if (y + deltaY < -bottom)\n\t\t\t\t\t\t\tdeltaY = -(y + bottom);\n\t\t\t\t\t} else if (scaleHeight < height) {\n\t\t\t\t\t\tdeltaY = 0;\n\t\t\t\t\t\tif (x + deltaX > 0)\n\t\t\t\t\t\t\tdeltaX = -x;\n\t\t\t\t\t\telse if (x + deltaX < -right)\n\t\t\t\t\t\t\tdeltaX = -(x + right);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (x + deltaX > 0)\n\t\t\t\t\t\t\tdeltaX = -x;\n\t\t\t\t\t\telse if (x + deltaX < -right)\n\t\t\t\t\t\t\tdeltaX = -(x + right);\n\n\t\t\t\t\t\tif (y + deltaY > 0)\n\t\t\t\t\t\t\tdeltaY = -y;\n\t\t\t\t\t\telse if (y + deltaY < -bottom)\n\t\t\t\t\t\t\tdeltaY = -(y + bottom);\n\t\t\t\t\t}\n\n\t\t\t\t\tmatrix.postTranslate(deltaX, deltaY);\n\t\t\t\t\tlast.set(curr);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\tmode = NONE;\n\t\t\t\tint xDiff = (int) Math.abs(curr.x - start.x);\n\t\t\t\tint yDiff = (int) Math.abs(curr.y - start.y);\n\t\t\t\tif (xDiff < CLICK && yDiff < CLICK) {\n\t\t\t\t\tperformClick();\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase MotionEvent.ACTION_POINTER_UP:\n\t\t\t\tmode = NONE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsetImageMatrix(matrix);\n\t\t\tinvalidate();\n\t\t\treturn true;\n\t\t}\n\t});\n}",
  "explanation": "code_hardening: Added a null check for MotionEvent and used getActionMasked() to safely handle multi-pointer scenarios; avoided any assumptions about pointer count while keeping logic minimal.\nresolve_compilation_errors: Removed all GestureDetector/double-tap references and initialized ScaleGestureDetector using getContext(); ensured required fields (m array, scale type, clickability) are set within init().\nexception_handling: none.\nlogic_customization: Eliminated all double-tap reset behavior and ensured mScaleDetector.onTouchEvent(event) is invoked at the start of onTouch while preserving drag, bounds checking, matrix updates, invalidate(), and click detection on ACTION_UP.\nrefactoring: Moved constructor setup into a reusable init() method and simplified the touch flow by removing the double-tap branch and any matrix/scale reinitialization during runtime.\nmisc: Removed now-unused double-tap related setup and kept formatting/comments consistent with the surrounding class style; no new custom API calls were introduced."
}