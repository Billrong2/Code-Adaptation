{
  "code": "private void updatePredecessorsWithCheckMode(javax.swing.tree.TreePath tp, boolean checkMode) {\n        if (tp == null) {\n            return;\n        }\n        javax.swing.tree.TreePath parentPath = tp.getParentPath();\n        if (parentPath == null) {\n            // reached root, stop propagation\n            return;\n        }\n        CheckedNode parentCheckedNode = nodesCheckingState.get(parentPath);\n        if (parentCheckedNode == null) {\n            return;\n        }\n        javax.swing.tree.DefaultMutableTreeNode parentNode = (javax.swing.tree.DefaultMutableTreeNode) parentPath.getLastPathComponent();\n        if (parentNode == null || parentNode.getChildCount() == 0) {\n            parentCheckedNode.hasChildren = false;\n            parentCheckedNode.allChildrenSelected = parentCheckedNode.isSelected;\n        } else {\n            boolean anyChildSelected = false;\n            boolean allChildrenFullySelected = true;\n            parentCheckedNode.hasChildren = true;\n            for (int i = 0; i < parentNode.getChildCount(); i++) {\n                javax.swing.tree.TreePath childPath = parentPath.pathByAddingChild(parentNode.getChildAt(i));\n                CheckedNode childCheckedNode = nodesCheckingState.get(childPath);\n                if (childCheckedNode == null) {\n                    continue;\n                }\n                if (childCheckedNode.isSelected) {\n                    anyChildSelected = true;\n                }\n                if (!allSelected(childCheckedNode)) {\n                    allChildrenFullySelected = false;\n                }\n            }\n            parentCheckedNode.isSelected = anyChildSelected;\n            parentCheckedNode.allChildrenSelected = allChildrenFullySelected;\n        }\n        if (parentCheckedNode.isSelected) {\n            checkedPaths.add(parentPath);\n        } else {\n            checkedPaths.remove(parentPath);\n        }\n        // propagate further up the tree\n        updatePredecessorsWithCheckMode(parentPath, parentCheckedNode.isSelected);\n    }",
  "explanation": "code_hardening: Added null checks for the incoming TreePath, parent path, parent node, and child nodes; guarded against empty child collections; ensured recursion stops cleanly at the root to avoid infinite loops.\nresolve_compilation_errors: Implemented the missing updatePredecessorsWithCheckMode(TreePath, boolean) method referenced by mouseClicked; used existing fields (nodesCheckingState, checkedPaths) and the existing allSelected(CheckedNode) helper without introducing new types.\nexception_handling: none.\nlogic_customization: Replaced logging-only behavior by recomputing parent selection state based on all children: parent is fully selected only if all child subtrees are fully selected, and selected if any child is selected; updated checkedPaths accordingly; recursively propagated the recomputed state up to the root.\nrefactoring: Structured the logic to clearly separate child aggregation (any vs. all) from state assignment, improving readability and maintainability within the single function.\nmisc: Removed any logging concerns and added brief inline comments documenting upward propagation behavior; no new custom API calls were introduced."
}