{
  "code": "@Override\npublic void onMeasure(RecyclerView.Recycler recycler, RecyclerView.State state,\n                      int widthSpec, int heightSpec) {\n  // Guard against invalid inputs or empty adapter\n  if (recycler == null || state == null || getItemCount() == 0) {\n    super.onMeasure(recycler, state, widthSpec, heightSpec);\n    return;\n  }\n\n  final int widthMode = View.MeasureSpec.getMode(widthSpec);\n  final int heightMode = View.MeasureSpec.getMode(heightSpec);\n  final int widthSize = View.MeasureSpec.getSize(widthSpec);\n  final int heightSize = View.MeasureSpec.getSize(heightSpec);\n\n  int totalWidth = 0;\n  int totalHeight = 0;\n\n  // Use a clearer local alias for the temp measurement array\n  final int[] childDimensions = measuredDimension;\n\n  // Measure each child to accumulate required size\n  for (int i = 0; i < getItemCount(); i++) {\n    // Use UNSPECIFIED specs with zero size to avoid invalid MeasureSpecs\n    measureScrapChild(\n        recycler,\n        i,\n        View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED),\n        View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED),\n        childDimensions);\n\n    if (getOrientation() == HORIZONTAL) {\n      totalWidth += childDimensions[0];\n      if (i == 0) {\n        totalHeight = childDimensions[1];\n      }\n    } else {\n      totalHeight += childDimensions[1];\n      if (i == 0) {\n        totalWidth = childDimensions[0];\n      }\n    }\n  }\n\n  // Decide whether to apply custom wrap-content sizing or fall back\n  boolean fitsInAvailableSpace =\n      (widthMode != View.MeasureSpec.EXACTLY || totalWidth <= widthSize)\n          && (heightMode != View.MeasureSpec.EXACTLY || totalHeight <= heightSize);\n\n  if (!fitsInAvailableSpace) {\n    // Content exceeds available space; allow normal measurement/scrolling\n    super.onMeasure(recycler, state, widthSpec, heightSpec);\n    return;\n  }\n\n  // Apply custom wrap-content sizing, relying on MeasureSpec modes\n  int measuredWidth = totalWidth;\n  int measuredHeight = totalHeight;\n\n  if (widthMode == View.MeasureSpec.EXACTLY) {\n    measuredWidth = widthSize;\n  } else if (widthMode == View.MeasureSpec.AT_MOST) {\n    measuredWidth = Math.min(totalWidth, widthSize);\n  }\n\n  if (heightMode == View.MeasureSpec.EXACTLY) {\n    measuredHeight = heightSize;\n  } else if (heightMode == View.MeasureSpec.AT_MOST) {\n    measuredHeight = Math.min(totalHeight, heightSize);\n  }\n\n  setMeasuredDimension(measuredWidth, measuredHeight);\n}",
  "explanation": "code_hardening: Added guards for null recycler/state and empty adapters to avoid unnecessary or unsafe measuring, and ensured valid UNSPECIFIED MeasureSpecs are used when measuring scrap children.\nresolve_compilation_errors: Implemented a proper onMeasure override compatible with RecyclerView.LayoutManager, reused the existing measuredDimension field via a local alias, and ensured the measureScrapChild call matches its declared signature.\nexception_handling: none.\nlogic_customization: Introduced a conditional check comparing total measured width/height against available sizes; applied the custom wrap-content path only when both fit, otherwise delegated to super.onMeasure to allow normal scrolling behavior; removed the manual min-clamp on width in favor of MeasureSpec handling.\nrefactoring: Renamed the temporary measurement array usage to a clearer local name (childDimensions), simplified orientation-based accumulation, and separated measurement, decision, and sizing logic for readability.\nmisc: Reformatted code for consistency and updated inline comments to reflect the conditional wrap-content measurement behavior."
}