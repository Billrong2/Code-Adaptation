package com.n1analytics.paillier;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;
import java.math.RoundingMode;

import com.n1analytics.paillier.util.BigIntegerUtil;
import com.n1analytics.paillier.util.HashChain;

public class StandardEncodingScheme implements EncodingScheme{
  
  
  private static final int DOUBLE_MANTISSA_BITS = 53;
  
  
  private final double log2Base;
   
  
  private final boolean signed;

  
  private final int precision;

  
  private final BigInteger maxEncoded;

  
  private final BigInteger minEncoded;

  
  private final BigInteger maxSignificand;

  
  private final BigInteger minSignificand;

  
  private final int base;
  
  private final PaillierContext context;
  
  public StandardEncodingScheme(PaillierContext context, boolean signed, int precision, int base){
    this.context = context;
    this.signed = signed;
    if (base < 2) {
      throw new IllegalArgumentException("Base must be at least equals to 2.");
    }
    this.base =base;
    this.log2Base = Math.log((double) base)/ Math.log(2.0);
    BigInteger modulus = context.getPublicKey().getModulus();
    if(modulus.bitLength() < precision || precision < 1) {
      throw new IllegalArgumentException("Precision must be greater than zero and less than or equal to the number of bits in the modulus");
    }
    if (signed && precision < 2) {
      throw new IllegalArgumentException(
              "Precision must be greater than one when signed is true");
    }
    this.precision = precision;
    BigInteger encSpace = modulus.bitLength() == precision ? modulus : BigInteger.ONE.shiftLeft(precision);
    if (signed) {
      maxEncoded = encSpace.add(BigInteger.ONE).shiftRight(1).subtract(BigInteger.ONE);   
      minEncoded = modulus.subtract(maxEncoded);
      maxSignificand = maxEncoded;
      minSignificand = maxEncoded.negate();
    } else {
      maxEncoded = encSpace.subtract(BigInteger.ONE);
      minEncoded = BigInteger.ZERO;
      maxSignificand = maxEncoded;
      minSignificand = BigInteger.ZERO;
    }
  }
  
  
  public EncodedNumber encode(BigInteger value) throws EncodeException {
    if (value == null) {
      throw new EncodeException("cannot encode 'null'");
    }
    if(value.compareTo(BigInteger.ZERO) < 0 && isUnsigned()) {
      throw new EncodeException("Input value cannot be encoded using this EncodingScheme.");
    }
    int exponent = 0;
    if (!value.equals(BigInteger.ZERO)) {
      while (value.mod(BigInteger.valueOf(base)).equals(BigInteger.ZERO)) {
        value = value.divide(BigInteger.valueOf(base));
        exponent++;
      }
    }
    if (BigIntegerUtil.greater(value, maxSignificand) || BigIntegerUtil.less(value, minSignificand)) {
      throw new EncodeException("Input value cannot be encoded.");
    }
    if(value.signum() < 0)
      value = value.add(context.getPublicKey().getModulus()); 
    return new EncodedNumber(context, value, exponent);
  }

  
  public EncodedNumber encode(double value) throws EncodeException {
    if(Double.isInfinite(value) || Double.isNaN(value))
      throw new EncodeException("Input value cannot be encoded.");

    if(value < 0 && isUnsigned())
      throw new EncodeException("Input value cannot be encoded using this EncodingScheme.");

    int exponent = value == 0 ? 0 : getDoublePrecExponent(value);
    return new EncodedNumber(context, innerEncode(new BigDecimal(value), exponent), exponent);
  }

  
  public EncodedNumber encode(double value, int maxExponent) throws EncodeException {
    if(Double.isInfinite(value) || Double.isNaN(value))
      throw new EncodeException("Input value cannot be encoded.");

    if(value < 0 && isUnsigned())
      throw new EncodeException("Input value is not valid for this Paillier context.");

    int exponent = getExponent(getDoublePrecExponent(value), maxExponent);
    return new EncodedNumber(context, innerEncode(new BigDecimal(value),
            getExponent(getDoublePrecExponent(value), maxExponent)), exponent);
  }

  
  public EncodedNumber encode(double value, double precision) throws EncodeException{
    if(Double.isInfinite(value) || Double.isNaN(value))
      throw new EncodeException("Input value cannot be encoded.");

    if(value < 0 && isUnsigned())
      throw new EncodeException("Input value is not valid for this Paillier context.");

    if (precision > 1 || precision <= 0)
      throw new EncodeException("Precision must be 10^-i where i > 0.");

    int exponent = getPrecExponent(precision);
    return new EncodedNumber(context, innerEncode(new BigDecimal(value), exponent), exponent);
  }

  
  public EncodedNumber encode(long value) throws EncodeException {
    return encode(BigInteger.valueOf(value));
  }
  
  public EncodedNumber encode(BigDecimal value) throws EncodeException {
    return encode(value, BIG_DECIMAL_ENCODING_PRECISION);
  }
  
  public EncodedNumber encode(BigDecimal value, int precision) throws EncodeException {
    if (value == null) {
      throw new EncodeException("cannot encode 'null'");
    }
    if(value.compareTo(BigDecimal.ZERO) < 0 && isUnsigned()) {
      throw new EncodeException("Input value cannot be encoded using this EncodingScheme.");
    }
    if (base == 10) {
      BigInteger significant;
      int exp = -value.scale();
      if (value.scale() > 0) {
        significant = value.scaleByPowerOfTen(value.scale()).toBigInteger();
      } else {
        significant = value.unscaledValue();
      }
      if (BigIntegerUtil.greater(significant, maxSignificand) || BigIntegerUtil.less(significant, minSignificand)) {
        throw new EncodeException("Input value cannot be encoded.");
      }
      if (significant.signum() < 0) {
        significant = context.getPublicKey().getModulus().add(significant);
      }
      return new EncodedNumber(context, significant, exp);
    } else {
      if (value.scale() > 0) { 
        BigDecimal EPSILON = new BigDecimal(BigInteger.ONE, precision); 
        MathContext mc = new MathContext(precision + 1, RoundingMode.HALF_EVEN);
        int newExponent = (int)Math.floor(logBigDecimal(value.multiply(EPSILON, mc), base));
        BigDecimal newValue = newExponent < 0 ? value.multiply(BigDecimal.valueOf(base).pow(-newExponent, mc), mc) : value.divide(BigDecimal.valueOf(base).pow(newExponent, mc), mc);
        BigInteger significant = newValue.setScale(0, RoundingMode.HALF_EVEN).unscaledValue();
        if (BigIntegerUtil.greater(significant, maxSignificand) || BigIntegerUtil.less(significant, minSignificand)) {
          throw new EncodeException("Input value cannot be encoded.");
        }
        if (significant.signum() < 0) {
          significant = context.getPublicKey().getModulus().add(significant);
        }
        return new EncodedNumber(context, significant, newExponent);
      } else {
        
        return encode(value.toBigInteger());
      }
    }
  }
  
  
  public boolean isSigned() {
    return signed;
  }

  
  public boolean isUnsigned() {
    return !signed;
  }
  
  
  private int getDoublePrecExponent(double value) {
    int binFltExponent = Math.getExponent(value) + 1;
    int binLsbExponent = binFltExponent - DOUBLE_MANTISSA_BITS;
    return (int) Math.floor((double) binLsbExponent / log2Base);
  }
  
  
  private BigInteger innerEncode(BigDecimal value, int exponent) {
    
    BigDecimal bigDecBaseExponent = (new BigDecimal(base)).pow(-exponent, MathContext.DECIMAL128);

    
    BigInteger bigIntRep =
            ((value.multiply(bigDecBaseExponent)).setScale(0, BigDecimal.ROUND_HALF_UP)).toBigInteger();

    if(BigIntegerUtil.greater(bigIntRep, maxSignificand) ||
            (value.signum() < 0 && BigIntegerUtil.less(bigIntRep, minSignificand))) {
      throw new EncodeException("Input value cannot be encoded.");
    }

    if (bigIntRep.signum() < 0) {
      bigIntRep = bigIntRep.add(context.getPublicKey().getModulus());
    }

    return bigIntRep;
  }
  
  
  private int getExponent(int precExponent, int maxExponent){
    return Math.min(precExponent, maxExponent);
  }
  
  
  private int getPrecExponent(double precision) {
    return (int) Math.floor(Math.log(precision) / Math.log((double) base));
  }
  
  
  public int signum(EncodedNumber number){
    if(number.value.equals(BigInteger.ZERO)){
      return 0;
    }
    if(isUnsigned()){
      return 1;
    }
    
    
    BigInteger halfModulus = context.getPublicKey().modulus.shiftRight(1);
    return number.value.compareTo(halfModulus) > 0 ? -1 : 1;
  }
  
  public int getBase() {
    return base;
  }
  
  public int getPrecision() {
    return precision;
  }
  
  public BigInteger getMaxEncoded() {
    return maxEncoded;
  }

  public BigInteger getMinEncoded() {
    return minEncoded;
  }

  public BigInteger getMaxSignificand() {
    return maxSignificand;
  }

  public BigInteger getMinSignificand() {
    return minSignificand;
  }
  
  public boolean isValid(EncodedNumber encoded) {
    
    if (!context.equals(encoded.getContext())) {
      return false;
    }
    if (encoded.getValue().compareTo(maxEncoded) <= 0) {
      return true;
    }
    if (signed && encoded.getValue().compareTo(minEncoded) >= 0) {
      return true;
    }
    return false;
  }
  
  
  public BigInteger decodeBigInteger(EncodedNumber encoded) throws DecodeException {
    BigInteger significand = getSignificand(encoded);
    return significand.multiply(BigInteger.valueOf(base).pow(encoded.getExponent()));
  }

  
  public double decodeDouble(EncodedNumber encoded) throws DecodeException {
    BigInteger significand = getSignificand(encoded);
    BigDecimal exp = BigDecimal.valueOf(base).pow(Math.abs(encoded.getExponent()));
    BigDecimal bigDecoded;
    if (encoded.getExponent() < 0) {
      bigDecoded = new BigDecimal(significand).divide(exp, MathContext.DECIMAL128);
    } else {
      bigDecoded = new BigDecimal(significand).multiply(exp, MathContext.DECIMAL128);
    }
    
    double decoded = bigDecoded.doubleValue();
    if(Double.isInfinite(decoded) || Double.isNaN(decoded)) {
      throw new DecodeException("Decoded value cannot be represented as double.");
    }
    return decoded;
  }

  
  public long decodeLong(EncodedNumber encoded) throws DecodeException {
    BigInteger decoded = decodeBigInteger(encoded);
    if(BigIntegerUtil.less(decoded, BigIntegerUtil.LONG_MIN_VALUE) ||
            BigIntegerUtil.greater(decoded, BigIntegerUtil.LONG_MAX_VALUE)) {
      throw new DecodeException("Decoded value cannot be represented as long.");
    }
    return decoded.longValue();
  }
  
  public BigDecimal decodeBigDecimal(EncodedNumber encoded) throws DecodeException {
    return decodeBigDecimal(encoded, BIG_DECIMAL_ENCODING_PRECISION);
  }
  
  public BigDecimal decodeBigDecimal(EncodedNumber encoded, int precision) throws DecodeException {
    BigInteger significant = getSignificand(encoded);
    if (base == 10) {
      return new BigDecimal(significant, -encoded.getExponent());
    }
    MathContext mc = new MathContext(precision + 1, RoundingMode.HALF_EVEN);
    BigDecimal exp = BigDecimal.valueOf(base).pow(encoded.getExponent(), mc);
    return exp.multiply(new BigDecimal(significant), mc);
  }
  
  
  private BigInteger getSignificand(EncodedNumber encoded) {
    context.checkSameContext(encoded);
    final BigInteger value = encoded.getValue();

    if(value.compareTo(context.getPublicKey().getModulus()) > 0)
      throw new DecodeException("The significand of the encoded number is corrupted");

    
    if (value.compareTo(maxEncoded) <= 0) {
      return value;
    }

    
    
    if (signed && value.compareTo(minEncoded) >= 0) {
      final BigInteger modulus = context.getPublicKey().getModulus();
      return value.subtract(modulus);
    }
    throw new DecodeException("Detected overflow");
  }
  
  public BigInteger getRescalingFactor(int expDiff) {
    return (BigInteger.valueOf(base)).pow(expDiff);
  }
  
  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o == null || o.getClass() != StandardEncodingScheme.class) {
      return false;
    }
    StandardEncodingScheme encoding = (StandardEncodingScheme) o;
    return signed == encoding.signed &&
            precision == encoding.precision && 
            base == encoding.base;
  }

  public boolean equals(StandardEncodingScheme o) {
    return o == this || (o != null &&
            base == o.base &&
            signed == o.signed &&
            precision == o.precision);
  }
  
  @Override
  public int hashCode() {
    return new HashChain().chain(base).chain(signed).chain(precision).hashCode();
  }
  
    // TODO

  
  private static final double LOG10 = Math.log(10.0);
  private static final double LOG2 = Math.log(2.0);

  private static double logBigDecimal(BigDecimal val, int base) {
      return (log2(val.unscaledValue()) * LOG2 - val.scale() * LOG10) / Math.log(base);
  }

}
