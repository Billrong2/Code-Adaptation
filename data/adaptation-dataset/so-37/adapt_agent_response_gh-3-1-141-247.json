{
  "code": "/**\n * Converts a standard POSIX Shell globbing pattern into a regular expression\n * pattern. The result can be used with the standard {@link java.util.regex} API to\n * recognize strings which match the glob pattern.\n * <p/>\n * When {@code matchWholeString} is {@code true}, the generated regular expression\n * is anchored at the start (^) and end ($) so that it matches the entire input.\n * When {@code false}, the behavior matches the original implementation and the\n * regex may match a substring.\n * <p/>\n * See also, the POSIX Shell language:\n * http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_13_01\n *\n * @param globPattern A glob pattern.\n * @param matchWholeString whether the resulting regex should match the entire input\n * @return A regex pattern string corresponding to the given glob pattern.\n * @throws IllegalArgumentException if {@code globPattern} is null\n */\npublic static final String convertGlobToRegex(final String globPattern, final boolean matchWholeString) {\n    if (globPattern == null) {\n        throw new IllegalArgumentException(\"Glob pattern must not be null\");\n    }\n\n    final StringBuilder sb = new StringBuilder(globPattern.length());\n    int inGroup = 0;\n    int inClass = 0;\n    int firstIndexInClass = -1;\n    final char[] arr = globPattern.toCharArray();\n\n    for (int i = 0; i < arr.length; i++) {\n        final char ch = arr[i];\n        switch (ch) {\n            case '\\\\':\n                if (++i >= arr.length) {\n                    sb.append('\\\\');\n                } else {\n                    final char next = arr[i];\n                    switch (next) {\n                        case ',':\n                            // escape not needed\n                            break;\n                        case 'Q':\n                        case 'E':\n                            // extra escape needed\n                            sb.append('\\\\');\n                        default:\n                            sb.append('\\\\');\n                    }\n                    sb.append(next);\n                }\n                break;\n            case '*':\n                if (inClass == 0) {\n                    sb.append(\".*\");\n                } else {\n                    sb.append('*');\n                }\n                break;\n            case '?':\n                if (inClass == 0) {\n                    sb.append('.');\n                } else {\n                    sb.append('?');\n                }\n                break;\n            case '[':\n                inClass++;\n                firstIndexInClass = i + 1;\n                sb.append('[');\n                break;\n            case ']':\n                inClass--;\n                sb.append(']');\n                break;\n            case '.':\n            case '(':\n            case ')':\n            case '+':\n            case '|':\n            case '^':\n            case '$':\n            case '@':\n            case '%':\n                if (inClass == 0 || (firstIndexInClass == i && ch == '^')) {\n                    sb.append('\\\\');\n                }\n                sb.append(ch);\n                break;\n            case '!':\n                if (firstIndexInClass == i) {\n                    sb.append('^');\n                } else {\n                    sb.append('!');\n                }\n                break;\n            case '{':\n                inGroup++;\n                sb.append('(');\n                break;\n            case '}':\n                inGroup--;\n                sb.append(')');\n                break;\n            case ',':\n                if (inGroup > 0) {\n                    sb.append('|');\n                } else {\n                    sb.append(',');\n                }\n                break;\n            default:\n                sb.append(ch);\n        }\n    }\n\n    final String coreRegex = sb.toString();\n    return matchWholeString ? \"^\" + coreRegex + \"$\" : coreRegex;\n}",
  "explanation": "code_hardening: Added a null check for the glob pattern and throw IllegalArgumentException; marked parameters and key locals as final to reduce accidental mutation.\nresolve_compilation_errors: Updated the method signature to include the boolean matchWholeString parameter so that existing callers (main) compile without mismatch; no additional imports required.\nexception_handling: Introduced an IllegalArgumentException for null input; otherwise left behavior unchanged.\nlogic_customization: Added the matchWholeString flag and applied anchoring (^) and ($) outside the core glob-to-regex translation to preserve original logic.\nrefactoring: Renamed the parameter to globPattern for clarity and separated the core regex generation from the optional anchoring step via a local variable.\nmisc: Updated Javadoc to document the new parameter and anchored vs. unanchored behavior; no new custom API calls were introduced."
}