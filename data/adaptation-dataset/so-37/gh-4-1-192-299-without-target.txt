

package dk.dma.ais.packet;

import java.util.Arrays;


public abstract class AisPacketFiltersBase implements FilterPredicateFactory {

    @SafeVarargs
    static <T> T[] check(T... elements) {
        T[] s = elements.clone();
        Arrays.sort(s);
        for (int i = 0; i < s.length; i++) {
            if (s[i] == null) {
                throw new NullPointerException("Array is null at position " + i);
            }
        }
        
        return s;
    }

    static String skipBrackets(String s) {
        return s.length() < 2 ? "" : s.substring(1, s.length() - 1);
    }

    
    protected static final String preprocessAisString(String aisString) {
        return aisString != null ? aisString.replace('@', ' ').trim() : null;
    }

    
    protected static final String preprocessExpressionString(String string) {
        String preprocessedString = string;
        if (preprocessedString.startsWith("'") && preprocessedString.endsWith("'") && preprocessedString.length() > 2) {
            preprocessedString = preprocessedString.substring(1, preprocessedString.length() - 1);
        }
        return preprocessedString;
    }

    
    protected static final String[] preprocessExpressionStrings(String[] strings) {
        String[] preprocessedStrings = new String[strings.length];
        for (int i = 0; i < preprocessedStrings.length; i++) {
            preprocessedStrings[i] = preprocessExpressionString(strings[i]);
        }
        return preprocessedStrings;
    }

    
    protected static final boolean compare(String lhs, String rhs, CompareToOperator operator) {
        lhs = preprocessAisString(lhs);
        rhs = preprocessAisString(rhs);

        switch (operator) {
            case EQUALS:
                return lhs.equalsIgnoreCase(rhs);
            case NOT_EQUALS:
                return !lhs.equalsIgnoreCase(rhs);
            case GREATER_THAN:
                return lhs.compareToIgnoreCase(rhs) > 0;
            case GREATER_THAN_OR_EQUALS:
                return lhs.compareToIgnoreCase(rhs) >= 0;
            case LESS_THAN:
                return lhs.compareToIgnoreCase(rhs) < 0;
            case LESS_THAN_OR_EQUALS:
                return lhs.compareToIgnoreCase(rhs) <= 0;
            default:
                throw new IllegalArgumentException("CompareToOperator " + operator + " not implemented.");
        }
    }

    
    protected static final boolean compare(int lhs, int rhs, CompareToOperator operator) {
        switch (operator) {
            case EQUALS:
                return lhs == rhs;
            case NOT_EQUALS:
                return lhs != rhs;
            case GREATER_THAN:
                return lhs > rhs;
            case GREATER_THAN_OR_EQUALS:
                return lhs >= rhs;
            case LESS_THAN:
                return lhs < rhs;
            case LESS_THAN_OR_EQUALS:
                return lhs <= rhs;
            default:
                throw new IllegalArgumentException("CompareToOperator " + operator + " not implemented.");
        }
    }

    
    protected static final boolean compare(float lhs, float rhs, CompareToOperator operator) {
        switch (operator) {
            case EQUALS:
                return lhs == rhs;
            case NOT_EQUALS:
                return lhs != rhs;
            case GREATER_THAN:
                return lhs > rhs;
            case GREATER_THAN_OR_EQUALS:
                return lhs >= rhs;
            case LESS_THAN:
                return lhs < rhs;
            case LESS_THAN_OR_EQUALS:
                return lhs <= rhs;
            default:
                throw new IllegalArgumentException("CompareToOperator " + operator + " not implemented.");
        }
    }

    
    protected static final boolean inRange(int min, int max, int value) {
        return value >= min && value <= max;
    }

    
    protected static final boolean inRange(float min, float max, float value) {
        return value >= min && value <= max;
    }

    
    protected static final <T> boolean matchesGlob(T value, String glob) {
        return value.toString().matches(convertGlobToRegex(glob));
    }

        // TODO

}
