{
  "code": "@SuppressWarnings(\"fallthrough\")\nstatic String globToRegex(String pattern) {\n    if (pattern == null)\n        throw new IllegalArgumentException(\"pattern must not be null\");\n\n    final StringBuilder sb = new StringBuilder(pattern.length());\n    int inGroup = 0;\n    int inClass = 0;\n    int firstIndexInClass = -1;\n    final char[] arr = pattern.toCharArray();\n\n    for (int i = 0; i < arr.length; i++) {\n        final char ch = arr[i];\n        switch (ch) {\n            case '\\\\':\n                if (++i >= arr.length) {\n                    sb.append('\\\\');\n                } else {\n                    final char next = arr[i];\n                    switch (next) {\n                        case ',':\n                            // escape not needed\n                            break;\n                        case 'Q':\n                        case 'E':\n                            // extra escape needed\n                            sb.append('\\\\');\n                        default:\n                            sb.append('\\\\');\n                    }\n                    sb.append(next);\n                }\n                break;\n            case '*':\n                if (inClass == 0)\n                    // path-aware: do not match directory separators\n                    sb.append(\"[^/]*\");\n                else\n                    sb.append('*');\n                break;\n            case '?':\n                if (inClass == 0)\n                    // path-aware: match exactly one non-separator\n                    sb.append(\"[^/]\");\n                else\n                    sb.append('?');\n                break;\n            case '[':\n                inClass++;\n                firstIndexInClass = i + 1;\n                sb.append('[');\n                break;\n            case ']':\n                inClass--;\n                sb.append(']');\n                break;\n            case '.':\n            case '(':\n            case ')':\n            case '+':\n            case '|':\n            case '^':\n            case '$':\n            case '@':\n            case '%':\n                if (inClass == 0 || (firstIndexInClass == i && ch == '^'))\n                    sb.append('\\\\');\n                sb.append(ch);\n                break;\n            case '!':\n                if (firstIndexInClass == i)\n                    sb.append('^');\n                else\n                    sb.append('!');\n                break;\n            case '{':\n                inGroup++;\n                sb.append('(');\n                break;\n            case '}':\n                inGroup--;\n                sb.append(')');\n                break;\n            case ',':\n                if (inGroup > 0)\n                    sb.append('|');\n                else\n                    sb.append(',');\n                break;\n            default:\n                sb.append(ch);\n        }\n    }\n    return sb.toString();\n}",
  "explanation": "code_hardening: Added a null check for the input pattern to fail fast and applied @SuppressWarnings(\"fallthrough\") to acknowledge intentional switch fallthrough. Ensured path-aware substitutions do not introduce malformed regex constructs.\nresolve_compilation_errors: Renamed the method to globToRegex, removed public and final to make it package-private static, and kept the signature compatible with existing callers such as listJar.\nexception_handling: none.\nlogic_customization: Modified glob handling so '*' becomes \"[^/]*\" and '?' becomes \"[^/]\" when not inside a character class, making matching path-aware while leaving all other glob semantics unchanged.\nrefactoring: Updated method name and minimal inline comments to reflect path-aware behavior without altering overall structure.\nmisc: Minor comment updates for clarity; no new custom API calls introduced."
}