{
  "code": "public static final java.util.regex.Pattern convertGlobToRegex(final String pattern) {\n    if (pattern == null) {\n        throw new IllegalArgumentException(\"pattern must not be null\");\n    }\n    final StringBuilder sb = new StringBuilder(pattern.length());\n    int inGroup = 0;\n    int inClass = 0;\n    int firstIndexInClass = -1;\n    final char[] arr = pattern.toCharArray();\n    for (int i = 0; i < arr.length; i++) {\n        final char ch = arr[i];\n        switch (ch) {\n            case '\\\\':\n                if (++i >= arr.length) {\n                    sb.append('\\\\');\n                } else {\n                    final char next = arr[i];\n                    switch (next) {\n                        case ',':\n                            // escape not needed\n                            break;\n                        case 'Q':\n                        case 'E':\n                            // extra escape needed\n                            sb.append('\\\\');\n                        default:\n                            sb.append('\\\\');\n                    }\n                    sb.append(next);\n                }\n                break;\n            case '*':\n                if (inClass == 0)\n                    sb.append(\".*\");\n                else\n                    sb.append('*');\n                break;\n            case '?':\n                if (inClass == 0)\n                    sb.append('.');\n                else\n                    sb.append('?');\n                break;\n            case '[':\n                inClass++;\n                firstIndexInClass = i + 1;\n                sb.append('[');\n                break;\n            case ']':\n                inClass--;\n                sb.append(']');\n                break;\n            case '.':\n            case '(':\n            case ')':\n            case '+':\n            case '|':\n            case '^':\n            case '$':\n            case '@':\n            case '%':\n                if (inClass == 0 || (firstIndexInClass == i && ch == '^'))\n                    sb.append('\\\\');\n                sb.append(ch);\n                break;\n            case '!':\n                if (firstIndexInClass == i)\n                    sb.append('^');\n                else\n                    sb.append('!');\n                break;\n            case '{':\n                inGroup++;\n                sb.append('(');\n                break;\n            case '}':\n                inGroup--;\n                sb.append(')');\n                break;\n            case ',':\n                if (inGroup > 0)\n                    sb.append('|');\n                else\n                    sb.append(',');\n                break;\n            default:\n                sb.append(ch);\n        }\n    }\n    return java.util.regex.Pattern.compile(sb.toString());\n}",
  "explanation": "code_hardening: Added a null check for the input pattern and throw IllegalArgumentException; marked parameters and key locals as final to reduce accidental mutation.\nresolve_compilation_errors: Changed the return type to java.util.regex.Pattern and return a compiled pattern using the fully qualified java.util.regex.Pattern.compile(...) without adding imports.\nexception_handling: Did not catch PatternSyntaxException explicitly, allowing it to propagate unchanged as per plan.\nlogic_customization: Preserved the glob-to-regex transformation logic exactly and only adapted the final step to compile and return a Pattern instead of a String.\nrefactoring: Kept the existing method name to avoid breaking callers while updating the return type; performed minor local variable finalization.\nmisc: No additional custom API calls beyond java.util.regex.Pattern.compile(String); no other adjustments needed."
}