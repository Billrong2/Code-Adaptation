package com.lucidworks.dq.util;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class StringUtils {

  public static String NL = System.getProperty("line.separator");

  public static String parseAndCatchGroupAsStringOrNull( String patternStr, String sourceText, int groupNumber ) {
    
    Pattern pattern = Pattern.compile( patternStr );
    Matcher matcher = pattern.matcher( sourceText );   
    if ( matcher.find() ) {
      return matcher.group( groupNumber );
    }
    else {
      return null;
    }
  }

  public static Long parseAndCatchGroupAsLongOrNull( String patternStr, String sourceText, int groupNumber ) {
    String matchStr = parseAndCatchGroupAsStringOrNull( patternStr, sourceText, groupNumber );
    if ( null!=matchStr ) {
      
      return Long.valueOf( matchStr );
    }
    else {
      return null;
    }
  }

  
  public static Map<String,Collection<String>> parseCgiParameters( String rawText ) {

    
    boolean maintainInsertionOrder = false;
    boolean isCaseSensitiveKeys = true;
    boolean trimKeys = true;
    String defaultParamName = "content";
    String encoding = "UTF-8";
    
    
    

    
    Map<String,Collection<String>> outMap = null;
    if ( maintainInsertionOrder ) {
      outMap = new LinkedHashMap<>();
    }
    else {
      outMap = new TreeMap<>();
    }

    
    String [] args = rawText.split( "[?&]" );
    for ( int i=0; i<args.length; i++ ) {

      String arg = args[i];
      
      if ( arg.isEmpty() ) {
        continue;
      }

      
      int equalsAt = arg.indexOf( '=' );
      String key = "";
      String value = "";
      if ( equalsAt >= 0 ) {
        if ( equalsAt > 0 ) {
          key = arg.substring( 0, equalsAt );
        }
        if ( equalsAt < arg.length() ) {
          value = arg.substring( equalsAt + 1 );
        }
      }
      else {
        key = arg;
      }

      
      try {
        key = URLDecoder.decode( key, encoding );
      } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
      }
      if ( trimKeys ) {
        key = key.trim();
      }
      if ( key.isEmpty() ) {
        key = defaultParamName;
      }
      if ( ! isCaseSensitiveKeys ) {
        key = key.toLowerCase();
      }
      
      try {
        value = URLDecoder.decode( value, encoding );
      } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
      }

      
      Collection<String> values = null;
      if ( outMap.containsKey(key) ) {
        values = outMap.get(key);
      }
      else {
        values = new ArrayList<>();
        outMap.put( key, values );
      }
      values.add( value );
      
    }
  
    return outMap;
  }

  
  
  public static String repeatString( String s, int n ) {
    if ( n <= 0 ) { return ""; }
    
    return new String(new char[n]).replace("\0", s);
    
  }

  public static String join( Collection<String> strings ) {
    return join( strings, ", " );
  }
  public static String join( Collection<String> strings, String delimiter ) {
    StringBuffer out = new StringBuffer();
    boolean isFirst = true;
    for ( String s : strings ) {
      if ( ! isFirst ) {
        out.append( delimiter );
      }
      else {
        isFirst = false;
      }
      out.append( s );
    }
    return new String( out );
  }

  
  public static Set<String> splitCsv( String inStr ) {
    String[] fieldsAry = inStr.split( ",\\s*" );
    
    Set<String> out = new LinkedHashSet<>();
    for ( String f : fieldsAry ) {
      if ( ! f.trim().isEmpty() ) {
        out.add( f.trim() );
      }
    }
    return out;
  }

  public static String escapeSpaces( String inStr ) {
    if ( null==inStr ) {
      return null;
    }
    return inStr.replaceAll( "[ ]", "\\\\ " );
  }
  public static String escapeColons( String inStr ) {
    if ( null==inStr ) {
      return null;
    }
    return inStr.replaceAll( "[:]", "\\\\:" );
  }

    // TODO


  
  public static boolean checkPatternsInList( Collection<Pattern> patterns, String targetString ) {
    for ( Pattern p : patterns ) {
      Matcher m = p.matcher( targetString );
      if ( m.matches() ) {
        return true;
      }
    }
    return false;
  }


}
