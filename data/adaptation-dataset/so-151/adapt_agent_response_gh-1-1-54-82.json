{
  "code": "private File resourceToFile(final String resourcePath) {\n    if (resourcePath == null || resourcePath.isEmpty()) {\n        throw new IllegalArgumentException(\"resourcePath must not be null or empty\");\n    }\n\n    File file = null;\n    final URL res = getClass().getResource(resourcePath.startsWith(\"/\") ? resourcePath : \"/\" + resourcePath);\n    if (res == null) {\n        throw new RuntimeException(\"Error: Resource \" + resourcePath + \" not found!\");\n    }\n\n    try {\n        if (\"jar\".equals(res.getProtocol())) {\n            try (InputStream input = getClass().getResourceAsStream(resourcePath.startsWith(\"/\") ? resourcePath : \"/\" + resourcePath)) {\n                if (input == null) {\n                    throw new RuntimeException(\"Error: Resource stream \" + resourcePath + \" not found!\");\n                }\n                file = File.createTempFile(\"tempfile\", \".tmp\");\n                try (OutputStream out = new FileOutputStream(file)) {\n                    final byte[] buffer = new byte[1024];\n                    int read;\n                    while ((read = input.read(buffer)) != -1) {\n                        out.write(buffer, 0, read);\n                    }\n                }\n                file.deleteOnExit();\n            }\n        } else {\n            file = new File(res.getFile());\n        }\n    } catch (IOException ex) {\n        ex.printStackTrace(System.err);\n        throw new RuntimeException(ex);\n    }\n\n    if (file == null || !file.exists()) {\n        throw new RuntimeException(\"Error: File \" + file + \" not found!\");\n    }\n\n    return file;\n}",
  "explanation": "code_hardening: Added null/empty validation for the resource path, null checks for URL and InputStream, used try-with-resources for InputStream and OutputStream, and marked locals final where appropriate.\nresolve_compilation_errors: Removed the dependency on the custom Exceptions utility and relied on standard Java types already available in the file (java.io, java.net), avoiding any unresolved symbols.\nexception_handling: Replaced custom exception handling with ex.printStackTrace(System.err) and wrapped IO failures in a RuntimeException, while preserving the explicit RuntimeException when the resulting file does not exist.\nlogic_customization: Parameterized the resource path, preserved JAR vs non-JAR resolution behavior using the URL protocol, and ensured compatibility with calls from testAll via resourceToFile.\nrefactoring: Extracted the logic into a reusable private helper method returning File, renamed variables for clarity, and removed the constructor-like misuse from the original snippet.\nmisc: Minor formatting cleanup and minimal comments via clearer structure; no new custom API calls were introduced."
}