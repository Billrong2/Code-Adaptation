{
  "code": "protected String[] getCipherList() {\n        // Ordered preference: ChaCha20/ECDHE first, then AES-GCM, AES-CBC, RSA as last resort\n        final String[] preferredCiphers = new String[] {\n                \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\",\n                \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n                \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\",\n                \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\",\n                \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\n                \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\",\n                \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\",\n                \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\",\n                \"TLS_RSA_WITH_AES_128_GCM_SHA256\",\n                \"TLS_RSA_WITH_AES_256_GCM_SHA384\"\n        };\n\n        final String scsv = \"TLS_EMPTY_RENEGOTIATION_INFO_SCSV\";\n\n        try {\n            final javax.net.ssl.SSLSocketFactory factory = mCtx.getSocketFactory();\n            String[] availableCiphers = factory.getSupportedCipherSuites();\n            if (availableCiphers == null || availableCiphers.length == 0) {\n                throw new IllegalStateException(\"No supported cipher suites\");\n            }\n\n            java.util.Arrays.sort(availableCiphers);\n            final java.util.List<String> selected = new java.util.ArrayList<String>();\n\n            for (int i = 0; i < preferredCiphers.length; i++) {\n                if (java.util.Arrays.binarySearch(availableCiphers, preferredCiphers[i]) >= 0) {\n                    selected.add(preferredCiphers[i]);\n                }\n            }\n\n            // Ensure non-empty result by falling back to a minimal safe set if needed\n            if (selected.isEmpty()) {\n                for (int i = 0; i < availableCiphers.length; i++) {\n                    selected.add(availableCiphers[i]);\n                }\n            }\n\n            // Always append SCSV defensively\n            if (!selected.contains(scsv)) {\n                selected.add(scsv);\n            }\n\n            return selected.toArray(new String[0]);\n        } catch (Exception e) {\n            // Sensible fallback cipher list on error\n            return new String[] {\n                    \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\",\n                    \"TLS_RSA_WITH_AES_128_GCM_SHA256\",\n                    scsv\n            };\n        }\n    }",
  "explanation": "code_hardening: Removed socket creation entirely, validated available cipher suites, ensured the returned list is non-empty, used final locals where applicable, and always appended TLS_EMPTY_RENEGOTIATION_INFO_SCSV defensively.\nresolve_compilation_errors: Replaced socket-based calls with javax.net.ssl.SSLSocketFactory.getSupportedCipherSuites(), referenced the correct context field mCtx, and introduced the new getCipherList method expected by initSSLSocketFactoryEx.\nexception_handling: Wrapped only the factory and query logic in a tryâ€“catch, removed any finally/resource cleanup, and returned a safe fallback cipher list plus SCSV on any exception.\nlogic_customization: Implemented an ordered preferred cipher suite list favoring ChaCha20/ECDHE and GCM, intersected it with sorted available suites using binary search while preserving preference order, and always appended TLS_EMPTY_RENEGOTIATION_INFO_SCSV.\nrefactoring: Renamed protocol-oriented variables to cipher-oriented ones, used camelCase naming, and removed protocol-specific logic and comments.\nmisc: Minor reformatting for readability and updated comments to reflect cipher-suite selection. New API used: javax.net.ssl.SSLSocketFactory.getSupportedCipherSuites()."}