{
  "code": "  @Override\n  public void onMeasure(android.support.v7.widget.RecyclerView.Recycler recycler,\n      android.support.v7.widget.RecyclerView.State state, int widthSpec, int heightSpec) {\n\n    // Code hardening: validate inputs\n    if (recycler == null || state == null) {\n      super.onMeasure(recycler, state, widthSpec, heightSpec);\n      return;\n    }\n\n    final int itemCount = getItemCount();\n    if (itemCount == 0) {\n      super.onMeasure(recycler, state, widthSpec, heightSpec);\n      return;\n    }\n\n    final int widthMode = android.view.View.MeasureSpec.getMode(widthSpec);\n    final int heightMode = android.view.View.MeasureSpec.getMode(heightSpec);\n    final int widthSize = android.view.View.MeasureSpec.getSize(widthSpec);\n    final int heightSize = android.view.View.MeasureSpec.getSize(heightSpec);\n\n    int accumulatedWidth = 0;\n    int accumulatedHeight = 0;\n\n    // Refactoring: clearer local alias for measurement buffer\n    final int[] childMeasuredSize = (measuredDimension != null && measuredDimension.length >= 2)\n        ? measuredDimension\n        : new int[2];\n\n    final int unspecified = android.view.View.MeasureSpec.makeMeasureSpec(0,\n        android.view.View.MeasureSpec.UNSPECIFIED);\n\n    for (int i = 0; i < itemCount; i++) {\n      // Logic customization: always measure with UNSPECIFIED for both dimensions\n      measureScrapChild(recycler, i, unspecified, unspecified, childMeasuredSize);\n\n      if (getOrientation() == HORIZONTAL) {\n        accumulatedWidth += childMeasuredSize[0];\n        if (i == 0) {\n          accumulatedHeight = childMeasuredSize[1];\n        }\n      } else {\n        accumulatedHeight += childMeasuredSize[1];\n        if (i == 0) {\n          accumulatedWidth = childMeasuredSize[0];\n        }\n      }\n    }\n\n    // Logic customization: only wrap when both dimensions fit; otherwise defer to super\n    if (accumulatedWidth < widthSize && accumulatedHeight < heightSize) {\n\n      int measuredWidth = accumulatedWidth;\n      int measuredHeight = accumulatedHeight;\n\n      // Preserve EXACTLY handling and fall-through behavior\n      switch (widthMode) {\n        case android.view.View.MeasureSpec.EXACTLY:\n          measuredWidth = widthSize;\n        case android.view.View.MeasureSpec.AT_MOST:\n        case android.view.View.MeasureSpec.UNSPECIFIED:\n      }\n\n      switch (heightMode) {\n        case android.view.View.MeasureSpec.EXACTLY:\n          measuredHeight = heightSize;\n        case android.view.View.MeasureSpec.AT_MOST:\n        case android.view.View.MeasureSpec.UNSPECIFIED:\n      }\n\n      setMeasuredDimension(measuredWidth, measuredHeight);\n    } else {\n      super.onMeasure(recycler, state, widthSpec, heightSpec);\n    }\n  }",
  "explanation": "code_hardening: Added null checks for recycler and state, guarded against zero item count to avoid unnecessary measurement work, and ensured the measurement buffer is safely initialized or reused.\nresolve_compilation_errors: Matched the onMeasure override signature used by LinearLayoutManager, kept measureScrapChild usage consistent with its existing signature, and used fully qualified View.MeasureSpec references to avoid import issues.\nexception_handling: none.\nlogic_customization: Unified measurement so each scrap child is always measured with both width and height set to UNSPECIFIED, moved the single measureScrapChild call outside the orientation branch, kept only accumulation logic orientation-dependent, and updated the wrap-content decision to set a custom measured dimension only when both accumulated width and height are smaller than the available sizes; otherwise delegated to super.onMeasure. EXACTLY handling and AT_MOST/UNSPECIFIED fall-through behavior were preserved.\nrefactoring: Introduced clearer local variable names (accumulatedWidth/accumulatedHeight and childMeasuredSize) and reduced duplicated branching by unifying the measurement call.\nmisc: none."
}