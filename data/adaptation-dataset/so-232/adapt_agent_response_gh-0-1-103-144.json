{
  "code": "public static String getTimeDiffString(long timestampMillis) {\n        // Defensive checks\n        if (sCtx == null\n                || sTimestampLabelHourAgo == null\n                || sTimestampLabelHoursAgo == null\n                || sTimestampLabelMinutesAgo == null\n                || sTimestampLabelJustNow == null\n                || sTimestampLabelToday == null\n                || sTimestampLabelYesterday == null\n                || sWeekdays == null) {\n            return \"\";\n        }\n\n        final long nowMillis = System.currentTimeMillis();\n        final long safeTimestamp = Math.min(timestampMillis, nowMillis);\n        final long diffMillis = Math.max(0L, nowMillis - safeTimestamp);\n\n        final long totalMinutes = diffMillis / (60L * 1000L);\n        final long hours = totalMinutes / 60L;\n        final long minutes = totalMinutes % 60L;\n\n        // 0â€“11 hours: minutes/hours ago logic\n        if (hours <= 11L) {\n            if (hours <= 0L) {\n                if (minutes > 0L) {\n                    return String.format(sTimestampLabelMinutesAgo, minutes);\n                }\n                return sTimestampLabelJustNow;\n            }\n            if (hours == 1L) {\n                return String.format(sTimestampLabelHourAgo, hours);\n            }\n            return String.format(sTimestampLabelHoursAgo, hours);\n        }\n\n        // Day-based logic\n        if (DateTimeUtils.isToday(safeTimestamp)) {\n            return sTimestampLabelToday;\n        }\n        if (DateTimeUtils.isYesterday(safeTimestamp)) {\n            return sTimestampLabelYesterday;\n        }\n\n        // Within last 6 days: weekday name\n        if (diffMillis < 6L * millisInADay) {\n            final java.util.Calendar cal = java.util.Calendar.getInstance();\n            cal.setTimeInMillis(safeTimestamp);\n            final int dayOfWeek = cal.get(java.util.Calendar.DAY_OF_WEEK);\n            if (dayOfWeek >= 0 && dayOfWeek < sWeekdays.length) {\n                return sWeekdays[dayOfWeek];\n            }\n        }\n\n        // Older: numeric date\n        return android.text.format.DateUtils.formatDateTime(\n                sCtx,\n                safeTimestamp,\n                android.text.format.DateUtils.FORMAT_NUMERIC_DATE);\n    }",
  "explanation": "code_hardening: Added null checks for static context and all string templates/weekday data, clamped future timestamps to now, ensured non-negative diffs, and used final locals for time calculations. Calendar usage relies on system default locale/timezone consistently.\nresolve_compilation_errors: Removed any singleton/accessor dependency by introducing a static formatter method signature. Used fully qualified references where imports are not shown (android.text.format.DateUtils, java.util.Calendar). Ensured usage of existing statics (sCtx, sWeekdays, millisInADay, label strings) and existing helpers (DateTimeUtils.isToday/isYesterday).\nexception_handling: none.\nlogic_customization: Implemented tiered recency rules: minutes/hours ago (with singular/plural templates), just now, today, yesterday, weekday for last 6 days, and numeric date fallback via DateUtils.formatDateTime with FORMAT_NUMERIC_DATE. Time difference is computed from now using millis, deriving hours and remaining minutes.\nrefactoring: Replaced singleton behavior with a stateless formatter method getTimeDiffString(long). Centralized all output through existing static string templates and simplified control flow with clear thresholds.\nmisc: Updated inline comments to reflect formatter behavior and kept formatting consistent with the surrounding utility style. New custom API calls used: android.text.format.DateUtils.formatDateTime(Context,long,int) (absent from the SO snippet but present/appropriate in the project context)."}