{
  "code": "public static void main(final String[] args) {\n    try {\n        // Generate RSA key pair at runtime\n        final java.security.KeyPairGenerator keyGen = java.security.KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        final java.security.KeyPair keyPair = keyGen.generateKeyPair();\n        final java.security.PublicKey publicKey = keyPair.getPublic();\n        final java.security.PrivateKey privateKey = keyPair.getPrivate();\n\n        // Default message if no arguments are supplied\n        final String[] messageParts = (args == null || args.length == 0)\n                ? new String[]{\"Hello\", \"from\", \"SignatureOutputStream\", \"demo\"}\n                : args;\n\n        // Sign data while capturing the exact bytes that are signed\n        final byte[] signature;\n        final byte[] dataBytes;\n        try (final java.io.ByteArrayOutputStream dataBuffer = new java.io.ByteArrayOutputStream()) {\n            signature = signData(dataBuffer, privateKey, messageParts);\n            dataBytes = dataBuffer.toByteArray();\n        }\n\n        if (publicKey == null || signature == null || dataBytes == null) {\n            throw new IllegalStateException(\"Key, signature, or data must not be null\");\n        }\n\n        // Successful verification\n        System.err.println(\"== Verification with original data/signature ==\");\n        verify(publicKey, signature, dataBytes);\n\n        // Mutate data bytes to demonstrate failure\n        System.err.println(\"== Verification after mutating data bytes ==\");\n        final byte[] mutatedData = dataBytes.clone();\n        if (mutatedData.length > 0) {\n            mutatedData[0] ^= 0x01;\n        }\n        verify(publicKey, signature, mutatedData);\n\n        // Restore data and verify again\n        System.err.println(\"== Verification after restoring data bytes ==\");\n        verify(publicKey, signature, dataBytes);\n\n        // Mutate signature bytes to demonstrate failure\n        System.err.println(\"== Verification after mutating signature bytes ==\");\n        final byte[] mutatedSignature = signature.clone();\n        if (mutatedSignature.length > 0) {\n            mutatedSignature[0] ^= 0x01;\n        }\n        verify(publicKey, mutatedSignature, dataBytes);\n\n    } catch (Exception ex) {\n        // Demo-friendly error reporting\n        System.err.println(\"Demo failed: \" + ex.getMessage());\n        ex.printStackTrace(System.err);\n    }\n}",
  "explanation": "code_hardening: Added null checks for key, signature, and data before verification, used try-with-resources for ByteArrayOutputStream, and marked locals as final where appropriate.\nresolve_compilation_errors: Introduced a public static main(String[] args) entry point, relied on existing signData and verify methods with compatible signatures, and used fully qualified class names where clarity was helpful.\nexception_handling: Wrapped key generation, signing, and verification in a single try/catch block in main to provide demo-friendly error reporting without changing verifyâ€™s exception behavior.\nlogic_customization: Generated an RSA KeyPair at runtime via java.security.KeyPairGenerator, invoked signData to capture the exact signed bytes, fed those bytes and the signature into verify, mutated data and signature bytes to demonstrate failures, restored originals, and provided a default message when no command-line arguments are supplied.\nrefactoring: Used clearer local variable names (dataBuffer, dataBytes, mutatedData, mutatedSignature) to improve readability within the demo flow; no class-level refactoring was possible within a single-function change.\nmisc: Added clear System.err messages to indicate each verification attempt and outcome; no new custom API calls beyond standard JCA/JDK classes were introduced."
}