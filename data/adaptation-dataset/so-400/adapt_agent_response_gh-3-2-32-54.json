{
  "code": "/**\n     * Encrypts a string using a device-scoped key derived from the Android ID.\n     * <p>\n     * This encryption is intended for obfuscating locally stored values (e.g., preferences)\n     * on the same device. Encrypted values are not portable across devices because the salt\n     * is derived from {@link android.provider.Settings.Secure#ANDROID_ID}.\n     * </p>\n     *\n     * @param context a non-null {@link android.content.Context} used to access the Android ID\n     * @param value   the plain text value to encrypt; if {@code null}, this method returns {@code null}\n     * @return the Base64-encoded encrypted value, or {@code null} if {@code value} is {@code null}\n     */\n    public String encrypt(Context context, String value) {\n        if (value == null) {\n            return null;\n        }\n        if (context == null) {\n            throw new IllegalArgumentException(\"Context must not be null\");\n        }\n\n        try {\n            final String algorithm = \"PBEWithMD5AndDES\";\n            final int iterationCount = 20;\n\n            final String androidId = Settings.Secure.getString(\n                    context.getContentResolver(), Settings.Secure.ANDROID_ID);\n            if (androidId == null || androidId.length() == 0) {\n                throw new IllegalStateException(\"ANDROID_ID is not available for encryption salt\");\n            }\n\n            final byte[] bytes = value.getBytes(UTF8);\n            final SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(algorithm);\n            final SecretKey secretKey = keyFactory.generateSecret(new PBEKeySpec(mSerkit));\n            final Cipher pbeCipher = Cipher.getInstance(algorithm);\n            pbeCipher.init(\n                    Cipher.ENCRYPT_MODE,\n                    secretKey,\n                    new PBEParameterSpec(androidId.getBytes(UTF8), iterationCount)\n            );\n\n            return new String(\n                    Base64.encode(pbeCipher.doFinal(bytes), Base64.NO_WRAP),\n                    UTF8\n            );\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }",
  "explanation": "code_hardening: Added early return for null value, explicit validation of non-null Context, use of final local variables, and a guard that checks for null/empty ANDROID_ID with a clear failure mode.\nresolve_compilation_errors: Updated the method signature to accept Context as a parameter, removed any reliance on a member context, reused existing project constants (UTF8) and fields (mSerkit), and referenced required Android/crypto APIs directly already present in the file.\nexception_handling: Preserved the existing pattern of wrapping all exceptions in RuntimeException for behavioral consistency with decrypt, while adding explicit IllegalArgumentException/IllegalStateException for invalid inputs and environment.\nlogic_customization: Changed behavior to return null when value is null instead of encrypting an empty byte array, while keeping the same algorithm (PBEWithMD5AndDES), iteration count, salt derivation from ANDROID_ID, and Base64.NO_WRAP encoding.\nrefactoring: Changed visibility to public, renamed the local key variable to secretKey for clarity, introduced named local constants for the algorithm and iteration count, and aligned structure with the existing decrypt method.\nmisc: Added JavaDoc documenting the device-scoped nature, intended use case, and portability limitations of the encryption. No new custom API calls were introduced."}