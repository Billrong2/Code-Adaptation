{
  "code": "    @Override\n    public void handleResourceRequest(FacesContext context) throws IOException {\n        ExternalContext externalContext = context.getExternalContext();\n        String resourceName = externalContext.getRequestPathInfo();\n        String libraryName = externalContext.getRequestParameterMap().get(\"ln\");\n        Resource resource = createResource(resourceName, libraryName);\n\n        if (resource == null) {\n            super.handleResourceRequest(context);\n            return;\n        }\n\n        if (!resource.userAgentNeedsUpdate(context)) {\n            externalContext.setResponseStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            return;\n        }\n\n        externalContext.setResponseContentType(resource.getContentType());\n\n        for (Entry<String, String> header : resource.getResponseHeaders().entrySet()) {\n            externalContext.setResponseHeader(header.getKey(), header.getValue());\n        }\n\n        ReadableByteChannel input = null;\n        WritableByteChannel output = null;\n\n        try {\n            input = Channels.newChannel(resource.getInputStream());\n            output = Channels.newChannel(externalContext.getResponseOutputStream());\n\n            for (ByteBuffer buffer = ByteBuffer.allocateDirect(10240); input.read(buffer) != -1; buffer.clear()) {\n                output.write((ByteBuffer) buffer.flip());\n            }\n        }\n        finally {\n            if (output != null) try { output.close(); } catch (IOException ignore) {}\n            if (input != null) try { input.close(); } catch (IOException ignore) {}\n        }\n    }",
  "explanation": "code_hardening: No additional null checks or structural changes were introduced; the function preserves the original logic and resource-handling pattern as-is.\nresolve_compilation_errors: Adjusted resource creation to call the local createResource(String, String) method of the ResourceHandlerWrapper, which is available in the target codebase; no new APIs were added.\nexception_handling: Kept the original try/finally pattern with silent IOException handling on channel close, matching the SO snippet and existing project style.\nlogic_customization: Logic is identical to the SO answer; resource resolution, 304 handling, header propagation, and streaming behavior are unchanged.\nrefactoring: No renaming or restructuring was applied; buffer size and loop structure remain unchanged to avoid behavioral differences.\nmisc: Formatting is consistent with the surrounding codebase; no additional annotations, comments, or logging were added. No new custom API calls were introduced."
}