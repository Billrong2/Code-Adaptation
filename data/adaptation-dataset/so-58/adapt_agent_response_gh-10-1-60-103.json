{
  "code": "private static void addFile(File source, JarOutputStream target, CompilerOptions options) throws IOException {\n\tif (source == null || target == null || options == null || options.tempDirectory == null)\n\t\treturn;\n\n\t// Compute path relative to the temp directory\n\tString basePath = options.tempDirectory.getCanonicalPath();\n\tString sourcePath = source.getCanonicalPath();\n\tString relativePath = \"\";\n\tif (sourcePath.startsWith(basePath)) {\n\t\trelativePath = sourcePath.substring(basePath.length());\n\t\tif (relativePath.startsWith(File.separator))\n\t\t\trelativePath = relativePath.substring(1);\n\t}\n\t// Normalize separators for jar entries\n\trelativePath = relativePath.replace(File.separatorChar, '/');\n\n\tif (source.isDirectory()) {\n\t\t// Do not add the top-level base directory itself\n\t\tif (!relativePath.isEmpty()) {\n\t\t\tif (!relativePath.endsWith(\"/\"))\n\t\t\t\trelativePath += \"/\";\n\t\t\tJarEntry entry = new JarEntry(relativePath);\n\t\t\tentry.setTime(source.lastModified());\n\t\t\ttarget.putNextEntry(entry);\n\t\t\ttarget.closeEntry();\n\t\t}\n\t\tFile[] children = source.listFiles();\n\t\tif (children != null) {\n\t\t\tfor (File nestedFile : children) {\n\t\t\t\taddFile(nestedFile, target, options);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t// Skip Java source files\n\tif (source.getName().endsWith(\".java\"))\n\t\treturn;\n\n\t// Add file entry\n\tJarEntry entry = new JarEntry(relativePath);\n\tentry.setTime(source.lastModified());\n\ttarget.putNextEntry(entry);\n\n\tfinal int BUFFER_SIZE = 1024;\n\ttry (BufferedInputStream in = new BufferedInputStream(new FileInputStream(source))) {\n\t\tbyte[] buffer = new byte[BUFFER_SIZE];\n\t\tint count;\n\t\twhile ((count = in.read(buffer)) != -1) {\n\t\t\ttarget.write(buffer, 0, count);\n\t\t}\n\t}\n\tfinally {\n\t\ttarget.closeEntry();\n\t}\n}",
  "explanation": "code_hardening: Added null checks for source, target, options, and options.tempDirectory; guarded against source.listFiles() returning null; used try-with-resources for the input stream to ensure proper cleanup while preserving streaming behavior.\nresolve_compilation_errors: Made the method static, named it addFile, added the CompilerOptions parameter, and ensured recursive calls propagate options; relied on existing project imports and fully resolved types already present.\nexception_handling: Kept IOException in the method signature and ensured JarOutputStream entries are closed in a finally block even when stream reading fails; no new checked exceptions introduced.\nlogic_customization: Built JarEntry names as paths relative to options.tempDirectory by stripping the base path and normalizing separators to '/'; skipped adding the top-level base directory when the relative path is empty while still processing children; ensured directory entries end with '/'; skipped .java files while including directories and other files; preserved timestamps and the original byte-copy loop.\nrefactoring: Renamed the method to reflect its purpose (addFile), clarified variable names (basePath, sourcePath, relativePath), and replaced the magic buffer size with a named local constant.\nmisc: Minor formatting and brief inline comments added to reflect relative-path handling and .java exclusion; no new custom API calls beyond existing project types (org.coreasm.compiler.CompilerOptions)."
}