{
  "code": "public static String decrypt(byte[] headerSaltAndCipherText, String password) {\n        final int HEADER_LENGTH = 8; // \"Salted__\"\n        if (headerSaltAndCipherText == null)\n            throw new IllegalStateException(\"Encrypted payload is null\");\n        if (password == null)\n            throw new IllegalStateException(\"Password is null\");\n        if (headerSaltAndCipherText.length < CIPHERTEXT_OFFSET + 1)\n            throw new IllegalStateException(\"Encrypted payload too short\");\n        try {\n            // validate header\n            for (int i = 0; i < HEADER_LENGTH; i++) {\n                if (headerSaltAndCipherText[i] != \"Salted__\".getBytes(\"ASCII\")[i])\n                    throw new IllegalStateException(\"Missing OpenSSL Salted__ header\");\n            }\n\n            final byte[] salt = copyOfRange(headerSaltAndCipherText, SALT_OFFSET, SALT_OFFSET + SALT_SIZE);\n            final byte[] cipherText = copyOfRange(headerSaltAndCipherText, CIPHERTEXT_OFFSET,\n                    headerSaltAndCipherText.length);\n            if (cipherText.length == 0)\n                throw new IllegalStateException(\"No ciphertext present\");\n\n            final byte[] passwordBytes = password.getBytes(\"ASCII\");\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n            final int keySizeBytes = KEY_SIZE_BITS / 8;\n            final int ivSizeBytes = cipher.getBlockSize();\n            final byte[][] keyAndIv = EVP_BytesToKey(keySizeBytes, ivSizeBytes, md, salt, passwordBytes,\n                    ITERATIONS);\n            if (keyAndIv == null || keyAndIv.length < 2)\n                throw new IllegalStateException(\"Key derivation failed\");\n\n            final byte[] key = keyAndIv[INDEX_KEY];\n            final byte[] iv = keyAndIv[INDEX_IV];\n            if (key == null || iv == null)\n                throw new IllegalStateException(\"Derived key or IV is null\");\n\n            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"), new IvParameterSpec(iv));\n            final byte[] plainBytes = cipher.doFinal(cipherText);\n            final String plaintext = new String(plainBytes, \"ASCII\");\n\n            // zero sensitive data\n            for (int i = 0; i < passwordBytes.length; i++) passwordBytes[i] = 0;\n            for (int i = 0; i < key.length; i++) key[i] = 0;\n            for (int i = 0; i < iv.length; i++) iv[i] = 0;\n            for (int i = 0; i < plainBytes.length; i++) plainBytes[i] = 0;\n\n            return plaintext;\n        } catch (BadPaddingException e) {\n            throw new IllegalStateException(\"Bad padding: likely wrong password or corrupted data\", e);\n        } catch (IllegalBlockSizeException e) {\n            throw new IllegalStateException(\"Illegal block size: corrupted ciphertext\", e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"ASCII encoding not supported\", e);\n        } catch (GeneralSecurityException e) {\n            throw new IllegalStateException(\"Cryptographic failure during OpenSSL-compatible decryption\", e);\n        }\n    }",
  "explanation": "code_hardening: Added null checks for payload and password, validated minimum length and presence of the OpenSSL “Salted__” header, ensured ciphertext is non-empty, and zeroed sensitive byte arrays (password bytes, key, IV, plaintext) after use. Used final locals for offsets and sizes.\nresolve_compilation_errors: Aligned with existing class constants (KEY_SIZE_BITS, INDEX_KEY, INDEX_IV, SALT_OFFSET, SALT_SIZE, CIPHERTEXT_OFFSET, ITERATIONS) and used existing copyOfRange. Relied on already-imported crypto classes and fully qualified behavior without adding new helpers.\nexception_handling: Wrapped cryptographic and encoding exceptions in IllegalStateException with clear diagnostics. Differentiated BadPaddingException and IllegalBlockSizeException to signal wrong password or corrupted data.\nlogic_customization: Implemented a decrypt API that accepts an OpenSSL-formatted byte[] payload and password, extracts salt and ciphertext using fixed offsets, derives key/IV via EVP_BytesToKey (MD5, configured iterations, key size, cipher block size), initializes AES/CBC/PKCS5Padding for decryption, and returns ASCII plaintext.\nrefactoring: Named the function to reflect high-level decryption semantics, replaced magic numbers with named constants, and used INDEX_KEY/INDEX_IV for clarity when selecting derived materials.\nmisc: Added brief inline comments describing OpenSSL compatibility and processing steps; no new custom API calls were introduced beyond existing project utilities."
}