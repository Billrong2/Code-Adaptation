{
  "code": "private static BufferedImage bufferedImageFromBitmap( final HDC dc, final HBITMAP bitmap, final BITMAPINFO bi ) {\n\t// Validate inputs\n\tif ( dc == null || bitmap == null || bi == null || bi.bmiHeader == null )\n\t\treturn null;\n\n\tfinal BITMAPINFOHEADER bih = bi.bmiHeader;\n\tfinal int bitCount = bih.biBitCount;\n\tif ( bitCount != 16 && bitCount != 32 )\n\t\tthrow new IllegalArgumentException( \"Unsupported bit depth: \" + bitCount );\n\n\tfinal int width = bih.biWidth;\n\tfinal int height = Math.abs( bih.biHeight ); // orientation is controlled by the sign in biHeight\n\tif ( width <= 0 || height <= 0 )\n\t\treturn null;\n\n\tfinal int bytesPerPixel = bitCount / 8;\n\n\t// Compute 32-bit aligned stride (in bytes)\n\tlong rowBits = (long) width * (long) bitCount;\t\t// may overflow int\n\tlong alignedRowBits = ( rowBits + 31L ) & ~31L; // align to 32 bits\n\tlong strideBytesLong = alignedRowBits / 8L;\n\tif ( strideBytesLong <= 0 || strideBytesLong > Integer.MAX_VALUE )\n\t\treturn null;\n\tfinal int strideBytes = (int) strideBytesLong;\n\n\t// Compute scanline stride in pixels\n\tif ( strideBytes % bytesPerPixel != 0 )\n\t\treturn null;\n\tfinal int scanlineStride = strideBytes / bytesPerPixel;\n\n\t// Allocate buffer sized to aligned stride * height\n\tlong totalElementsLong = (long) scanlineStride * (long) height;\n\tif ( totalElementsLong <= 0 || totalElementsLong > Integer.MAX_VALUE )\n\t\treturn null;\n\n\tfinal ColorModel colorModel;\n\tfinal WritableRaster raster;\n\tfinal boolean ok;\n\n\tif ( bitCount == 32 ) {\n\t\tfinal int[] pixels = new int[ (int) totalElementsLong ];\n\t\tok = GDI.GetDIBits( dc, bitmap, 0, height, pixels, bi, 0 /* DIB_RGB_COLORS */ );\n\t\tif ( !ok )\n\t\t\treturn null;\n\n\t\t// 8-8-8 RGB, ignore alpha\n\t\tcolorModel = new DirectColorModel( 24, 0x00FF0000, 0x0000FF00, 0x000000FF );\n\t\traster = Raster.createPackedRaster( new DataBufferInt( pixels, pixels.length ), width, height, scanlineStride,\n\t\t\t\tnew int[] { 0x00FF0000, 0x0000FF00, 0x000000FF }, null );\n\t}\n\telse {\n\t\tfinal short[] pixels = new short[ (int) totalElementsLong ];\n\t\tok = GDI.GetDIBits( dc, bitmap, 0, height, pixels, bi, 0 /* DIB_RGB_COLORS */ );\n\t\tif ( !ok )\n\t\t\treturn null;\n\n\t\t// 5-5-5 RGB\n\t\tcolorModel = new DirectColorModel( 15, 0x7C00, 0x03E0, 0x001F );\n\t\traster = Raster.createPackedRaster( new DataBufferUShort( pixels, pixels.length ), width, height, scanlineStride,\n\t\t\t\tnew int[] { 0x7C00, 0x03E0, 0x001F }, null );\n\t}\n\n\treturn new BufferedImage( colorModel, raster, false, null );\n}",
  "explanation": "code_hardening: Validated all inputs for null and ensured width/height are positive. Explicitly checked supported bit depths (16 and 32) and verified stride and buffer-size calculations with overflow guards before allocation. Returned null consistently on GetDIBits failure.\nresolve_compilation_errors: Removed any dependency on DC acquisition, BitBlt, object selection/restoration, and cleanup. Used existing JNA WinGDI types already present in the codebase and replaced the DIB color table constant with the numeric value (0). No undefined helpers or constants remain.\nexception_handling: Eliminated try/finally blocks related to native resource management. Threw a clear IllegalArgumentException for unsupported bit depths and otherwise relied on controlled null returns for native call failures.\nlogic_customization: Implemented a focused helper that converts only an HBITMAP + BITMAPINFO to a BufferedImage. Computed a 32-bit–aligned DIB stride, allocated buffers sized to aligned stride × height, and created packed rasters honoring that stride. Used DirectColorModel and WritableRaster for 32-bit (8-8-8) and 16-bit (5-5-5) formats only. Read pixels directly into the DataBuffer-backed primitive arrays via GDI32.GetDIBits without modifying biHeight or compression.\nrefactoring: Renamed locals to reflect bitmap-to-image semantics (width, height, strideBytes, scanlineStride). Centralized bit masks within the color model and raster creation to avoid magic numbers scattered through the code.\nmisc: Reformatted for clarity and added brief comments documenting supported formats, stride alignment, and orientation assumptions. No new custom API calls were introduced beyond existing GDI32.GetDIBits overloads."
}