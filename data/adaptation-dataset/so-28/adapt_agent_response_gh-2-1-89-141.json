{
  "code": "private BufferedImage bufferedImageFromBitmap(final HDC dc, final HBITMAP bmp) {\n\t// Assumes dc, bmp and bi are managed/owned by the caller; no GDI lifecycle here.\n\tif (dc == null || bmp == null || bi == null || bi.bmiHeader == null)\n\t\treturn null;\n\n\tfinal BITMAPINFOHEADER bih = bi.bmiHeader;\n\tfinal int width  = bih.biWidth;\n\tfinal int height = Math.abs(bih.biHeight);\n\tfinal int bitCount = bih.biBitCount;\n\n\tif (width <= 0 || height <= 0)\n\t\treturn null;\n\n\t// Support only 16-bit and 32-bit formats\n\tfinal boolean is32 = bitCount == 32;\n\tfinal boolean is16 = bitCount == 16;\n\tif (!is32 && !is16)\n\t\tthrow new IllegalArgumentException(\"Unsupported bit depth: \" + bitCount);\n\n\t// DWORD-aligned stride (bytes per row)\n\tfinal int bytesPerPixel = is32 ? 4 : 2;\n\tfinal int strideBytes = ((width * bytesPerPixel + 3) / 4) * 4;\n\n\t// (Re)initialize cached objects if needed\n\tfinal boolean recreate = resultBufferedImage == null\n\t\t\t|| resultBufferedImage.getWidth() != width\n\t\t\t|| resultBufferedImage.getHeight() != height\n\t\t\t|| (is32 && !(buffer instanceof DataBufferInt))\n\t\t\t|| (is16 && !(buffer instanceof DataBufferUShort));\n\n\tif (recreate) {\n\t\t// Color masks\n\t\tfinal int rMask, gMask, bMask;\n\t\tif (is32) {\n\t\t\trMask = 0x00FF0000;\n\t\t\tgMask = 0x0000FF00;\n\t\t\tbMask = 0x000000FF;\n\t\t\tcm = new DirectColorModel(32, rMask, gMask, bMask);\n\t\t\tfinal int[] data = new int[(strideBytes / 4) * height];\n\t\t\tbuffer = new DataBufferInt(data, data.length);\n\t\t} else {\n\t\t\t// 16-bit: assume 5-6-5\n\t\t\trMask = 0xF800;\n\t\t\tgMask = 0x07E0;\n\t\t\tbMask = 0x001F;\n\t\t\tcm = new DirectColorModel(16, rMask, gMask, bMask);\n\t\t\tfinal short[] data = new short[(strideBytes / 2) * height];\n\t\t\tbuffer = new DataBufferUShort(data, data.length);\n\t\t}\n\n\t\tfinal int[] bandMasks = new int[] { rMask, gMask, bMask };\n\t\traster = Raster.createPackedRaster(buffer, width, height, strideBytes / bytesPerPixel, bandMasks, null);\n\t\tresultBufferedImage = new BufferedImage(cm, raster, false, null);\n\t}\n\n\t// Fill pixel buffer directly via GetDIBits\n\tfinal boolean ok;\n\tif (is32) {\n\t\tok = GDI.GetDIBits(dc, bmp, 0, height, ((DataBufferInt) buffer).getData(), bi, WinGDI.DIB_RGB_COLORS);\n\t} else {\n\t\tok = GDI.GetDIBits(dc, bmp, 0, height, ((DataBufferUShort) buffer).getData(), bi, WinGDI.DIB_RGB_COLORS);\n\t}\n\n\treturn ok ? resultBufferedImage : null;\n}",
  "explanation": "code_hardening: Validated dc/bmp/bi presence and width/height positivity; explicitly restricts formats to 16/32 bpp and throws on unsupported depths; lazily initializes and safely reuses cached ColorModel/DataBuffer/Raster/BufferedImage with invalidation on size or format change; documents that native resources are not owned here.\nresolve_compilation_errors: Removed all DC acquisition, BitBlt, and BITMAPINFO initialization responsibilities; used existing project fields and JNA types; relied on fully qualified WinGDI.DIB_RGB_COLORS where needed; aligned the method to a conversion-only signature.\nexception_handling: Returns null on GetDIBits failure as specified; allows IllegalArgumentException to propagate for unsupported bit depths; avoids broad try/finally since no GDI lifecycle is managed here.\nlogic_customization: Computes DWORD-aligned row stride from BITMAPINFOHEADER; derives absolute height without modifying biHeight; removes header tweaks (compression/top-down); implements explicit DirectColorModel masks for 16-bit (5-6-5) and 32-bit; performs a single GetDIBits call directly into typed primitive arrays backing the DataBuffer.\nrefactoring: Focused and renamed logic to conversion-only behavior; replaced magic numbers with named masks and computed stride; simplified control flow; centralized cache creation and reuse.\nmisc: Updated comments to reflect assumptions and limitations; minimal formatting consistent with surrounding code. New custom API calls used: none."
}