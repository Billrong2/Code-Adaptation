{
  "code": "private List<UUID> parseUuids(final byte[] advertisedData) {\n    // Workaround for Android 4.3/4.4 BLE scan filtering bug:\n    // Some Android versions fail to correctly filter devices by advertised services,\n    // so we manually parse the raw scan record to extract UUIDs.\n\n    final List<UUID> uuids = new ArrayList<>();\n\n    if (advertisedData == null || advertisedData.length < 2) {\n        return uuids;\n    }\n\n    final String BASE_UUID_FORMAT = \"%08x-0000-1000-8000-00805f9b34fb\";\n\n    final ByteBuffer buffer = ByteBuffer.wrap(advertisedData).order(ByteOrder.LITTLE_ENDIAN);\n    try {\n        while (buffer.remaining() > 2) {\n            int length = buffer.get() & 0xFF;\n            if (length == 0) {\n                break;\n            }\n\n            // Length includes the type byte; ensure it does not exceed remaining bytes\n            if (length > buffer.remaining()) {\n                break; // malformed record, stop parsing\n            }\n\n            final byte type = buffer.get();\n            switch (type) {\n                case 0x02: // Partial list of 16-bit UUIDs\n                case 0x03: // Complete list of 16-bit UUIDs\n                    while (length >= 2 && buffer.remaining() >= 2) {\n                        uuids.add(UUID.fromString(String.format(BASE_UUID_FORMAT, buffer.getShort())));\n                        length -= 2;\n                    }\n                    break;\n\n                case 0x06: // Partial list of 128-bit UUIDs\n                case 0x07: // Complete list of 128-bit UUIDs\n                    while (length >= 16 && buffer.remaining() >= 16) {\n                        final long lsb = buffer.getLong();\n                        final long msb = buffer.getLong();\n                        uuids.add(new UUID(msb, lsb));\n                        length -= 16;\n                    }\n                    break;\n\n                default:\n                    // Skip the remaining bytes for this record (length minus type byte)\n                    buffer.position(buffer.position() + length - 1);\n                    break;\n            }\n        }\n    } catch (java.nio.BufferUnderflowException e) {\n        // Defensive: ignore malformed scan records and return what we have parsed so far\n    }\n\n    return uuids;\n}",
  "explanation": "code_hardening: Added null and minimal-length checks for the advertisedData array, validated record length against remaining buffer bytes, guarded buffer position advancement, and marked parameters/locals as final where appropriate.\nresolve_compilation_errors: none.\nexception_handling: Wrapped parsing loop in a try/catch for java.nio.BufferUnderflowException to defensively handle malformed scan records without crashing, returning any UUIDs parsed so far.\nlogic_customization: none.\nrefactoring: Replaced ArrayList instantiation with the diamond operator, introduced a named BASE_UUID_FORMAT constant for readability, and applied minor formatting and whitespace cleanup.\nmisc: Added explanatory comments documenting the Android 4.3/4.4 BLE scan filtering bug and clarifying that this method manually parses scan records as a workaround. No new custom API calls were introduced."
}