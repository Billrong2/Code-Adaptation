{
  "code": "  /**\n   * Returns an {@link java.net.InetAddress} object encapsulating what is most likely the machine's LAN IP address.\n   * <p>\n   * This method is intended as a safer replacement for {@link java.net.InetAddress#getLocalHost()}, which can be\n   * ambiguous on some systems (notably Linux) where loopback interfaces may be selected.\n   * <p>\n   * Selection algorithm:\n   * <ol>\n   *   <li>Fast-path: return {@code InetAddress.getLocalHost()} if it is non-loopback and site-local.</li>\n   *   <li>Otherwise, scan all network interfaces and prefer the first non-loopback site-local address.</li>\n   *   <li>If none found, return the first non-loopback address as a candidate.</li>\n   *   <li>Final fallback to {@code InetAddress.getLocalHost()}.</li>\n   * </ol>\n   * <p>\n   * See also: https://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4665037\n   *\n   * @throws java.net.UnknownHostException if the LAN address of the machine cannot be determined\n   */\n  static InetAddress discoverLANAddress() throws UnknownHostException {\n    // Fast-path: let UnknownHostException propagate directly\n    final InetAddress localHost = InetAddress.getLocalHost();\n    if (localHost != null && !localHost.isLoopbackAddress() && localHost.isSiteLocalAddress()) {\n      return localHost;\n    }\n\n    try {\n      InetAddress candidateAddress = null;\n\n      final Enumeration<NetworkInterface> ifaces = NetworkInterface.getNetworkInterfaces();\n      if (ifaces != null) {\n        // Iterate all NICs (network interface cards)...\n        while (ifaces.hasMoreElements()) {\n          final NetworkInterface iface = ifaces.nextElement();\n          if (iface == null) {\n            continue;\n          }\n          try {\n            if (!iface.isUp()) {\n              continue;\n            }\n          } catch (Exception ignored) {\n            // Preserve original behavior if interface state cannot be determined\n          }\n\n          final Enumeration<InetAddress> inetAddrs = iface.getInetAddresses();\n          if (inetAddrs == null) {\n            continue;\n          }\n          // Iterate all IP addresses assigned to each card...\n          while (inetAddrs.hasMoreElements()) {\n            final InetAddress inetAddr = inetAddrs.nextElement();\n            if (inetAddr == null || inetAddr.isLoopbackAddress()) {\n              continue;\n            }\n\n            if (inetAddr.isSiteLocalAddress()) {\n              // Found non-loopback site-local address. Return it immediately...\n              return inetAddr;\n            } else if (candidateAddress == null) {\n              // Found non-loopback address, but not necessarily site-local.\n              candidateAddress = inetAddr;\n            }\n          }\n        }\n      }\n\n      if (candidateAddress != null) {\n        // We did not find a site-local address, but we found some other non-loopback address.\n        return candidateAddress;\n      }\n\n      // Final fallback to whatever InetAddress.getLocalHost() returns...\n      final InetAddress jdkSuppliedAddress = InetAddress.getLocalHost();\n      if (jdkSuppliedAddress == null) {\n        throw new UnknownHostException(\"The JDK InetAddress.getLocalHost() method unexpectedly returned null.\");\n      }\n      return jdkSuppliedAddress;\n    } catch (Exception e) {\n      final UnknownHostException unknownHostException =\n          new UnknownHostException(\"Failed to determine LAN address: \" + e);\n      unknownHostException.initCause(e);\n      throw unknownHostException;\n    }\n  }",
  "explanation": "code_hardening: Added null checks for network interface and address enumerations, skipped null elements, optionally filtered out interfaces that are not up while preserving original behavior if state cannot be determined, and marked local variables as final where appropriate.\nresolve_compilation_errors: Renamed the method to package-private static discoverLANAddress() to match callers in the codebase; relied on existing imports (java.net.InetAddress, java.net.NetworkInterface, java.util.Enumeration, java.net.UnknownHostException) without introducing new dependencies.\nexception_handling: Moved the initial InetAddress.getLocalHost() fast-path outside the try/catch so its UnknownHostException propagates directly; retained a try/catch around interface scanning and final fallback, wrapping unexpected exceptions in a new UnknownHostException with a custom message and cause.\nlogic_customization: Implemented the fast-path returning InetAddress.getLocalHost() when it is non-loopback and site-local; preserved the original NIC scanning logic with candidate selection and preference rules; kept the final fallback to InetAddress.getLocalHost() if no suitable address is found.\nrefactoring: Renamed the method, updated and reformatted the Javadoc to reflect the new behavior, separated fast-path logic from scanning logic for clarity, and removed raw types in favor of generics within the function.\nmisc: Added a reference link in the Javadoc and adjusted formatting and comments to align with the surrounding code style; no new custom API calls were introduced."
}