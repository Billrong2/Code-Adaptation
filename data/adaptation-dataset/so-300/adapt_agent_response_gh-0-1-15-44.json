{
"code":"protected static String fastDoubleToString(double value, int precision) {\n\t/**\n\t * Fast double-to-string conversion optimized for JSON serialization.\n\t * <p>\n\t * Precision is treated as a <em>maximum</em> fractional length: rounding is applied at the given\n\t * precision, but trailing zeros are trimmed after the decimal point while ensuring at least one\n\t * fractional digit remains (e.g. \"x.0\"). This avoids fixed-width padding and reduces output size.\n\t * <p>\n\t * This method avoids BigDecimal for performance reasons and is intended for finite doubles only.\n\t */\n\t// Guard against NaN/Infinity; fall back to default string form\n\tif (Double.isNaN(value) || Double.isInfinite(value)) {\n\t\treturn String.valueOf(value);\n\t}\n\n\t// Validate precision: non-negative and within POW10 bounds\n\tif (precision < 0) {\n\t\tprecision = 0;\n\t} else if (precision >= POW10.length) {\n\t\tprecision = POW10.length - 1;\n\t}\n\n\tStringBuilder sb = new StringBuilder();\n\n\t// Handle sign\n\tif (value < 0d) {\n\t\tsb.append('-');\n\t\tvalue = -value;\n\t}\n\n\t// Use long scale factor to avoid overflow for higher precisions\n\tfinal long scale = POW10[precision];\n\tfinal long rounded = (long) (value * scale + 0.5d);\n\n\tfinal long integerPart = (scale == 0L) ? rounded : (rounded / scale);\n\tsb.append(integerPart);\n\n\t// Fractional handling\n\tif (precision > 0) {\n\t\tsb.append('.');\n\t\tlong fraction = (scale == 0L) ? 0L : (rounded % scale);\n\n\t\tif (fraction == 0L) {\n\t\t\t// Ensure at least one fractional digit\n\t\t\tsb.append('0');\n\t\t} else {\n\t\t\t// Zero-pad up to precision, then trim trailing zeros\n\t\t\tlong divisor = scale / 10L;\n\t\t\twhile (divisor > 0 && fraction < divisor) {\n\t\t\t\tsb.append('0');\n\t\t\t\tdivisor /= 10L;\n\t\t\t}\n\t\t\tint start = sb.length();\n\t\t\tsb.append(fraction);\n\t\t\t// Trim trailing zeros but keep at least one fractional digit\n\t\t\tint end = sb.length() - 1;\n\t\t\twhile (end > start && sb.charAt(end) == '0') {\n\t\t\t\tend--;\n\t\t\t}\n\t\t\tsb.setLength(end + 1);\n\t\t}\n\t}\n\n\treturn sb.toString();\n}",
"explanation":"code_hardening: Added validation for precision (non-negative and capped to POW10 bounds) and guards for NaN/Infinity to safely fall back to String.valueOf. Used final local variables and avoided shared mutable state.\nresolve_compilation_errors: Renamed and restricted the method to protected static fastDoubleToString(double, int) to match callers. Switched the scale/exponent to long and adjusted arithmetic accordingly, relying on the existing long POW10 array.\nexception_handling: none.\nlogic_customization: Implemented precision as a maximum fractional length with rounding preserved. Stopped fixed-width zero-padding when the fractional part is zero, trimmed trailing zeros after the decimal, and ensured at least one fractional digit remains (e.g., \"x.0\") to align with JSON serialization expectations.\nrefactoring: Replaced the original format method with fastDoubleToString, clarified variable names (value, scale, rounded, integerPart, fraction), and simplified control flow for readability within a single function.\nmisc: Added Javadoc explaining intent, performance motivation, precision semantics, and limitations; minor formatting and inline comments for clarity. No new custom API calls were introduced."}