{
"code":"public static void unzip(File zipfile, File directory) throws IOException {\n    if (zipfile == null || directory == null) {\n        throw new IllegalArgumentException(\"zipfile and directory must not be null\");\n    }\n    if (!zipfile.exists() || !zipfile.isFile()) {\n        throw new FileNotFoundException(\"Zip file does not exist or is not a file: \" + zipfile);\n    }\n    if (!directory.exists()) {\n        if (!directory.mkdirs()) {\n            throw new IOException(\"Could not create target directory: \" + directory);\n        }\n    }\n    File canonicalTargetDir = directory.getCanonicalFile();\n    try (ZipFile zipFile = new ZipFile(zipfile)) {\n        Enumeration<? extends ZipEntry> entries = zipFile.entries();\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = entries.nextElement();\n            File outFile = new File(directory, entry.getName());\n            File canonicalOutFile = outFile.getCanonicalFile();\n            if (!canonicalOutFile.getPath().startsWith(canonicalTargetDir.getPath() + File.separator)) {\n                throw new IOException(\"Blocked Zip Slip attempt: \" + entry.getName());\n            }\n            if (entry.isDirectory()) {\n                if (!canonicalOutFile.exists() && !canonicalOutFile.mkdirs()) {\n                    throw new IOException(\"Could not create directory: \" + canonicalOutFile);\n                }\n            } else {\n                File parent = canonicalOutFile.getParentFile();\n                if (parent != null && !parent.exists() && !parent.mkdirs()) {\n                    throw new IOException(\"Could not create parent directory: \" + parent);\n                }\n                try (InputStream in = zipFile.getInputStream(entry)) {\n                    copy(in, canonicalOutFile);\n                }\n            }\n        }\n    }\n}",
"explanation":"code_hardening: Added null and existence checks for inputs, ensured target directories are created with mkdirs() checks, used try-with-resources for ZipFile and per-entry InputStreams, and implemented Zip Slip protection by validating canonical paths against the target directory.\nresolve_compilation_errors: Renamed the method to unzip with signature (File zipfile, File directory), replaced ZipOutputStream usage with ZipFile and Enumeration<ZipEntry>, removed directory traversal locals, and reused the existing copy(InputStream, File) helper to avoid signature mismatches.\nexception_handling: Declared IOException on the method, converted manual close logic to try-with-resources, and allowed IOExceptions to propagate when directory creation, Zip Slip detection, or stream operations fail.\nlogic_customization: Replaced directory traversal with iteration over ZipEntry objects from ZipFile, branched on entry.isDirectory() to create directories or extract files, swapped parameter roles to match unzip semantics, and streamed data from entry InputStream to destination files.\nrefactoring: Renamed locals to zipFile, entry, outFile, and target-related names to reflect extraction behavior, removed obsolete queue/URI logic, and simplified control flow within a single loop.\nmisc: Updated behavior implicitly documents extraction semantics through method name and logic; no additional custom API calls beyond java.util.zip.ZipFile/ZipEntry were introduced."}