{
"code":"static int fromFloat(float value) {\n    // Convert 32-bit float to IEEE-754 half-precision stored in lower 16 bits of int\n    final int HALF_SIGN_MASK = 0x8000;\n    final int HALF_EXP_MASK = 0x7C00;\n    final int HALF_MANT_MASK = 0x03FF;\n    final int HALF_EXP_BIAS = 15;\n    final int FLOAT_EXP_BIAS = 127;\n    final int HALF_MAX_EXP = 0x1F;\n    final int HALF_MAX_FINITE = 0x7BFF;\n\n    int fbits = Float.floatToRawIntBits(value);\n    int sign = (fbits >>> 16) & HALF_SIGN_MASK; // isolate sign once\n    int fexp = (fbits >>> 23) & 0xFF;\n    int fmant = fbits & 0x7FFFFF;\n\n    // Handle NaN / Inf\n    if (fexp == 0xFF) {\n        if (fmant != 0) {\n            // NaN: propagate payload into half mantissa (truncate)\n            int payload = (fmant >>> 13) & HALF_MANT_MASK;\n            if (payload == 0) {\n                payload = 1; // ensure NaN mantissa is non-zero\n            }\n            return sign | HALF_EXP_MASK | payload;\n        }\n        // Infinity\n        return sign | HALF_EXP_MASK;\n    }\n\n    // Handle zero (both +0 and -0)\n    if (fexp == 0 && fmant == 0) {\n        return sign;\n    }\n\n    // Unbias float exponent\n    int exp = fexp - FLOAT_EXP_BIAS;\n\n    // Normalized half range\n    if (exp >= -14 && exp <= 15) {\n        // Add implicit leading 1 for normalized float\n        int mant = fmant | 0x00800000;\n        // Shift mantissa from 23 to 10 bits with round-to-nearest-even\n        int shift = 23 - 10;\n        int mantRounded = mant >>> shift;\n        int remainder = mant & ((1 << shift) - 1);\n        int halfway = 1 << (shift - 1);\n        if (remainder > halfway || (remainder == halfway && (mantRounded & 1) != 0)) {\n            mantRounded++;\n            if (mantRounded == (1 << 11)) { // mantissa overflow (11 bits incl implicit)\n                mantRounded >>>= 1;\n                exp++;\n                if (exp > 15) {\n                    // Overflow after rounding: clamp to max finite half\n                    return sign | HALF_MAX_FINITE;\n                }\n            }\n        }\n        int halfExp = (exp + HALF_EXP_BIAS) << 10;\n        int halfMant = mantRounded & HALF_MANT_MASK;\n        return sign | halfExp | halfMant;\n    }\n\n    // Subnormal half range\n    if (exp >= -24 && exp < -14) {\n        // Build mantissa with implicit leading 1\n        int mant = fmant | 0x00800000;\n        int shift = (-exp - 14) + (23 - 10);\n        if (shift > 31) {\n            return sign; // underflow to zero\n        }\n        int mantRounded = mant >>> shift;\n        int remainder = mant & ((1 << shift) - 1);\n        int halfway = 1 << (shift - 1);\n        if (remainder > halfway || (remainder == halfway && (mantRounded & 1) != 0)) {\n            mantRounded++;\n        }\n        return sign | (mantRounded & HALF_MANT_MASK);\n    }\n\n    // Overflow: too large for half\n    if (exp > 15) {\n        return sign | HALF_EXP_MASK;\n    }\n\n    // Underflow: too small even for subnormal\n    return sign;\n}",
"explanation":"code_hardening: Added explicit handling for NaN, ±Inf, ±0, overflow, normalized, subnormal, and underflow cases; isolated and reused the sign bit; guarded exponent ranges with clear thresholds and clamped results where required.\nresolve_compilation_errors: Replaced the half→float logic with a new static method accepting a float and returning an int; used Float.floatToRawIntBits(float) to extract sign/exponent/mantissa and declared all required locals and constants within the function.\nexception_handling: none.\nlogic_customization: Reversed the conversion direction to float→half, adjusted exponent bias (127→15), implemented round-to-nearest-even when reducing mantissa precision, generated normalized and subnormal halves with correct rounding, propagated NaN payload bits, produced signed infinities on overflow, clamped rounding overflow to 0x7bff, and returned signed zero on full underflow; removed any smooth-transition behavior in favor of explicit range checks.\nrefactoring: Renamed semantics to fromFloat with clear variable names (sign, fexp, fmant, exp); replaced magic numbers with named constants; structured the function into extract → classify → round → pack phases.\nmisc: Added concise comments documenting IEEE-754 half-precision encoding rules and rounding behavior; no new custom API calls beyond Float.floatToRawIntBits(float)."}