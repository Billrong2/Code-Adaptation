{
  "code": "public static boolean isPortAvailable(InetAddress localAddress, int port) {\n        // Validate port range\n        if (port < MIN_PORT_NUMBER || port > MAX_PORT_NUMBER) {\n            throw new IllegalArgumentException(\"Invalid start port: \" + port);\n        }\n        // Validate address (null means wildcard / any NIC)\n        InetAddress bindAddress = localAddress;\n        \n        // Preliminary active check: try connecting as a client\n        try (Socket client = new Socket()) {\n            if (bindAddress != null) {\n                client.connect(new java.net.InetSocketAddress(bindAddress, port), 200);\n            } else {\n                client.connect(new java.net.InetSocketAddress(port), 200);\n            }\n            // Connection succeeded, port is in use\n            return false;\n        } catch (IOException e) {\n            // Expected when nothing is listening; proceed to bind-based check\n            if (log.isTraceEnabled()) {\n                log.trace(\"Active connect check failed for {}:{}; proceeding to bind test\", bindAddress, port, e);\n            }\n        }\n\n        // Fallback to bind-based availability check\n        try (ServerSocket ss = (bindAddress != null ? new ServerSocket(port, 50, bindAddress) : new ServerSocket(port));\n             DatagramSocket ds = (bindAddress != null ? new DatagramSocket(port, bindAddress) : new DatagramSocket(port))) {\n            ss.setReuseAddress(true);\n            ds.setReuseAddress(true);\n            return true;\n        } catch (IOException e) {\n            // Bind failed; port not available\n            if (log.isTraceEnabled()) {\n                log.trace(\"Bind-based port availability check failed for {}:{}\", bindAddress, port, e);\n            }\n            return false;\n        }\n    }",
  "explanation": "code_hardening: Added strict port range validation, null-safe handling of the InetAddress parameter (treating null as wildcard), and used try-with-resources to ensure Socket, ServerSocket, and DatagramSocket are always closed.\nresolve_compilation_errors: Implemented the missing overloaded method isPortAvailable(InetAddress,int) with the correct static signature and fully qualified InetSocketAddress where needed; no new imports required beyond existing ones.\nexception_handling: Explicitly handled IOExceptions from the client connection attempt to distinguish expected connection failures from successful connects, and immediately returned false on any bind-related IOException, with optional trace logging.\nlogic_customization: Added a preliminary TCP client connection attempt to localAddress:port to detect an actively listening service; if that fails, performed interface-specific binding tests for both ServerSocket and DatagramSocket using the provided InetAddress.\nrefactoring: Renamed and clarified local variables (bindAddress, client) to reflect semantics and restructured logic into clear active-check then bind-check phases.\nmisc: Added brief comments and trace-level logging consistent with existing SLF4J usage to document interface-specific behavior; no new custom API calls beyond standard java.net classes."
}