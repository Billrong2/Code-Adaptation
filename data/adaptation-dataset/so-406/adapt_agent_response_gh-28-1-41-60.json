{
  "code": "public static <K, V extends Comparable<? super V>> Map<K, V> sortByDescendingValue(final Map<K, V> map)\n{\n\tif (map == null)\n\t{\n\t\treturn new LinkedHashMap<K, V>();\n\t}\n\n\tList<Map.Entry<K, V>> list =\n\t\t\tnew LinkedList<Map.Entry<K, V>>(map.entrySet());\n\tCollections.sort(list, new Comparator<Map.Entry<K, V>>()\n\t{\n\t\tpublic int compare(Map.Entry<K, V> o1, Map.Entry<K, V> o2)\n\t\t{\n\t\t\t// descending order by value\n\t\t\treturn o2.getValue().compareTo(o1.getValue());\n\t\t}\n\t});\n\n\tMap<K, V> result = new LinkedHashMap<K, V>();\n\tfor (Map.Entry<K, V> entry : list)\n\t{\n\t\tresult.put(entry.getKey(), entry.getValue());\n\t}\n\treturn result;\n}",
  "explanation": "code_hardening: Added a null-check for the input map and return an empty LinkedHashMap when null to avoid NullPointerException; marked the parameter as final to prevent reassignment.\nresolve_compilation_errors: Updated the method signature to public static with generic bounds declared at the static level; relied on existing project imports (Map, List, LinkedList, LinkedHashMap, Collections, Comparator) so no unresolved symbols remain.\nexception_handling: none.\nlogic_customization: Inverted the comparator to sort values in descending order and materialized the sorted entries into a LinkedHashMap to preserve insertion (sorted) order; changed the return type to Map<K,V> accordingly.\nrefactoring: Renamed the method to sortByDescendingValue and used clearer variable naming (list, result) consistent with the existing MapUtil style.\nmisc: Added a brief inline comment documenting the descending sort behavior; no new custom API calls were introduced."
}