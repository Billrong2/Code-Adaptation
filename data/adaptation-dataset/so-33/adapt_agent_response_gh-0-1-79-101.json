{
  "code": "public void fetchDrawableAsync(final String urlString, final android.widget.ImageView target) {\n        if (target == null || urlString == null || urlString.length() == 0) {\n            return;\n        }\n\n        // Mark the ImageView with the requested URL to guard against recycling\n        target.setTag(urlString);\n\n        final android.os.Handler mainHandler = new android.os.Handler(android.os.Looper.getMainLooper());\n\n        // If cached, immediately update on UI thread\n        Drawable cached;\n        synchronized (drawableMap) {\n            cached = drawableMap.get(urlString);\n        }\n        if (cached != null) {\n            final Drawable cachedDrawable = cached;\n            mainHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    Object tag = target.getTag();\n                    if (urlString.equals(tag)) {\n                        target.setImageDrawable(cachedDrawable);\n                    }\n                }\n            });\n        }\n\n        // TODO: hook for setting a placeholder drawable while loading\n\n        // Always start background fetch\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                InputStream is = null;\n                Drawable drawable = null;\n                try {\n                    is = fetch(urlString);\n                    drawable = Drawable.createFromStream(is, \"src\");\n                    if (drawable != null) {\n                        synchronized (drawableMap) {\n                            drawableMap.put(urlString, drawable);\n                        }\n                    }\n                } catch (Exception e) {\n                    // Suppress exceptions per async wrapper policy\n                } finally {\n                    if (is != null) {\n                        try {\n                            is.close();\n                        } catch (IOException ignore) {\n                        }\n                    }\n                }\n\n                final Drawable result = drawable;\n                if (result != null) {\n                    mainHandler.post(new Runnable() {\n                        @Override\n                        public void run() {\n                            Object tag = target.getTag();\n                            if (urlString.equals(tag)) {\n                                target.setImageDrawable(result);\n                            }\n                        }\n                    });\n                }\n            }\n        }).start();\n    }",
  "explanation": "code_hardening: Added null/empty checks for urlString and ImageView, ensured InputStream is closed in a finally block, synchronized access to drawableMap, and guarded UI updates by comparing the ImageView tag to avoid setting images on recycled views.\nresolve_compilation_errors: Introduced async-related Android classes via fully qualified names (android.os.Handler, android.os.Looper, java.lang.Thread, android.widget.ImageView) and avoided reliance on any return value by switching to a void method; ensured thread-safe access to drawableMap.\nexception_handling: Moved try/catch handling entirely into the background thread, suppressed logging and propagated no exceptions from this wrapper, and left the ImageView unchanged on failures.\nlogic_customization: Changed the API to void fetchDrawableAsync(String, ImageView), immediately applied cached drawables on the UI thread, always spawned a background thread to call existing fetch(String) logic, and posted results back to the main thread using a Handler.\nrefactoring: Renamed and restructured logic to reflect asynchronous, side-effect-based behavior and separated cache check, background fetch, and UI update responsibilities within the single method.\nmisc: Removed logging from the async wrapper and added a TODO comment as a placeholder hook for showing a pending/placeholder image while loading; new custom API calls used include android.os.Handler(android.os.Looper.getMainLooper()) and Thread(Runnable)."}