{
"code":"public static ECPoint scalarMult(final ECPoint P, final BigInteger k, final EllipticCurve curve) {\n    if (P == null || k == null || curve == null)\n        throw new IllegalArgumentException(\"Null parameter\");\n    if (P.equals(ECPoint.POINT_INFINITY))\n        return ECPoint.POINT_INFINITY;\n    if (!(curve.getField() instanceof java.security.spec.ECFieldFp))\n        throw new IllegalArgumentException(\"Only prime fields supported\");\n    final java.security.spec.ECFieldFp field = (java.security.spec.ECFieldFp) curve.getField();\n    final BigInteger prime = field.getP();\n    // validate that P is on the curve: y^2 = x^3 + ax + b (mod p)\n    final BigInteger x = P.getAffineX();\n    final BigInteger y = P.getAffineY();\n    if (x == null || y == null)\n        throw new IllegalArgumentException(\"Point has no affine coordinates\");\n    BigInteger lhs = y.modPow(TWO, prime);\n    BigInteger rhs = x.modPow(THREE, prime).add(curve.getA().multiply(x)).add(curve.getB()).mod(prime);\n    if (!lhs.equals(rhs))\n        throw new IllegalArgumentException(\"Point is not on the given curve\");\n    // reduce scalar modulo field prime as required\n    BigInteger scalar = k.mod(prime);\n    if (scalar.signum() == 0)\n        return ECPoint.POINT_INFINITY;\n    if (scalar.equals(BigInteger.ONE))\n        return P;\n    int length = scalar.bitLength();\n    byte[] bits = new byte[length];\n    BigInteger tmpK = scalar;\n    for (int i = 0; i <= length - 1; i++) {\n        bits[i] = tmpK.mod(TWO).byteValue();\n        tmpK = tmpK.divide(TWO);\n    }\n    ECPoint R = ECPoint.POINT_INFINITY;\n    for (int i = length - 1; i >= 0; i--) {\n        R = doublePoint(R, curve);\n        if (bits[i] == 1)\n            R = addPoint(R, P, curve);\n    }\n    return R;\n}",
"explanation":"code_hardening: Added null checks for ECPoint, BigInteger, and EllipticCurve; verified prime-field curves only; validated that the input point lies on the curve; handled edge cases for POINT_INFINITY, scalar 0, and scalar 1; marked parameters final.\nresolve_compilation_errors: Renamed scalmult to scalarMult; introduced the EllipticCurve parameter; derived the field prime from ECFieldFp instead of a global p; updated calls to addPoint and doublePoint to pass the curve; relied on existing constants TWO and THREE.\nexception_handling: Threw IllegalArgumentException for nulls, unsupported fields, and invalid points; arithmetic exceptions from modInverse are allowed to propagate consistently with existing helpers.\nlogic_customization: Reduced the scalar modulo the field prime from the provided curve; removed the temporary S variable and used the input point P directly in additions; preserved the original double-and-add bit-processing order and POINT_INFINITY initialization.\nrefactoring: Standardized parameter and local names (k, scalar, bits); clarified and updated comments; kept logic confined to this function.\nmisc: Formatting aligned with existing style; no new custom API calls beyond existing addPoint/doublePoint and standard JCA types."}