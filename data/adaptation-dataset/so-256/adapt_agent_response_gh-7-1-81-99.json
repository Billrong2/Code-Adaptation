{
  "code": "public void add(HttpUrl uri, Cookie cookie) {\n        if (uri == null || cookie == null || cookiePrefs == null) {\n            return;\n        }\n        String host = uri.host();\n        if (host == null || host.length() == 0) {\n            return;\n        }\n\n        // Determine persistence/expiry\n        boolean isExpired = cookie.expiresAt() < System.currentTimeMillis();\n        boolean shouldKeep = cookie.persistent() && !isExpired;\n\n        // Ensure host map\n        if (!cookies.containsKey(host)) {\n            cookies.put(host, new ConcurrentHashMap<String, Cookie>());\n        }\n\n        // Generate a unique token per cookie\n        String token = java.util.UUID.randomUUID().toString();\n\n        SharedPreferences.Editor editor = cookiePrefs.edit();\n        try {\n            if (shouldKeep) {\n                // Upsert in-memory\n                cookies.get(host).put(token, cookie);\n\n                // Update index for this host\n                String index = cookiePrefs.getString(host, \"\");\n                java.util.ArrayList<String> tokens = new java.util.ArrayList<String>();\n                if (!TextUtils.isEmpty(index)) {\n                    try {\n                        for (String t : TextUtils.split(index, \",\")) {\n                            if (!TextUtils.isEmpty(t)) {\n                                tokens.add(t);\n                            }\n                        }\n                    } catch (Exception e) {\n                        Log.d(LOG_TAG, \"Corrupted cookie index for host: \" + host, e);\n                        tokens.clear();\n                    }\n                }\n                if (!tokens.contains(token)) {\n                    tokens.add(token);\n                }\n\n                // Persist index and cookie value\n                editor.putString(host, TextUtils.join(\",\", tokens));\n                String encoded = encodeCookie(new SerializableHttpCookie(cookie));\n                if (encoded != null) {\n                    editor.putString(COOKIE_NAME_PREFIX + token, encoded);\n                }\n            } else {\n                // Remove expired/non-persistent cookie\n                if (cookies.containsKey(host)) {\n                    cookies.get(host).remove(token);\n                }\n                editor.remove(COOKIE_NAME_PREFIX + token);\n\n                String index = cookiePrefs.getString(host, \"\");\n                if (!TextUtils.isEmpty(index)) {\n                    java.util.ArrayList<String> tokens = new java.util.ArrayList<String>();\n                    for (String t : TextUtils.split(index, \",\")) {\n                        if (!token.equals(t)) {\n                            tokens.add(t);\n                        }\n                    }\n                    editor.putString(host, TextUtils.join(\",\", tokens));\n                }\n            }\n        } catch (ClassCastException e) {\n            Log.d(LOG_TAG, \"ClassCastException while adding cookie\", e);\n        } finally {\n            editor.commit();\n        }\n    }",
  "explanation": "code_hardening: Added null checks for HttpUrl, Cookie, SharedPreferences, and guarded against empty/malformed host names. Validated cookie persistence and expiry before storing and ensured editor commit in a finally block.\nresolve_compilation_errors: Implemented the missing single-cookie add(HttpUrl, Cookie) mutator using okhttp3.HttpUrl and okhttp3.Cookie, aligning with existing fields and helpers in the class.\nexception_handling: Wrapped index parsing and persistence logic in try/catch blocks to handle ClassCastException and corrupted stored data, logging issues without crashing.\nlogic_customization: Shifted behavior to immediate persistence on add. Generated a unique token per cookie using java.util.UUID, maintained per-host in-memory maps, updated a comma-separated token index per host in SharedPreferences, conditionally added or removed cookies based on persistence/expiry, and avoided any full SharedPreferences scans.\nrefactoring: Used clear local variable names (host, token, shouldKeep), removed reliance on cookie name/domain tokens, and centralized index management logic within this mutator.\nmisc: Updated logging messages to reflect the new add flow and OkHttp-based persistence strategy. New custom API used: java.util.UUID#randomUUID()."
}