{
"code":"public static List<String> getSourcePaths() throws PackageManager.NameNotFoundException {\n    List<String> sourcePaths = new ArrayList<>();\n\n    // Resolve application info via application-level accessors\n    PackageManager pm = getPackageManager();\n    String packageName = getPackageName();\n    if (pm == null || packageName == null) {\n        return sourcePaths;\n    }\n\n    ApplicationInfo applicationInfo = pm.getApplicationInfo(packageName, 0);\n    if (applicationInfo == null || applicationInfo.sourceDir == null) {\n        return sourcePaths;\n    }\n\n    // Always include base APK path first\n    sourcePaths.add(applicationInfo.sourceDir);\n\n    // Prepare secondary dex directory\n    File dataDir = applicationInfo.dataDir != null ? new File(applicationInfo.dataDir) : null;\n    File dexDir = dataDir != null ? new File(dataDir, SECONDARY_FOLDER_NAME) : null;\n\n    // the prefix of extracted file, ie: app.apk.classes\n    File sourceApk = new File(applicationInfo.sourceDir);\n    String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;\n\n    // the total dex numbers (be tolerant of gaps)\n    int totalDexNumber = 1;\n    try {\n        SharedPreferences prefs = getMultiDexPreferences();\n        if (prefs != null) {\n            totalDexNumber = prefs.getInt(KEY_DEX_NUMBER, 1);\n        }\n    } catch (Throwable ignored) {\n        // ignore preference access issues\n    }\n\n    if (dexDir != null && dexDir.exists() && dexDir.isDirectory()) {\n        for (int secondaryNumber = 2; secondaryNumber <= totalDexNumber; secondaryNumber++) {\n            String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;\n            File extractedFile = new File(dexDir, fileName);\n            if (extractedFile.isFile() && extractedFile.canRead()) {\n                sourcePaths.add(extractedFile.getAbsolutePath());\n            }\n            // missing secondary dex files are skipped intentionally\n        }\n    }\n\n    // Instant Run support: append all dex/jar files under instant-run dex directory\n    if (dataDir != null) {\n        File instantRunDexDir = new File(dataDir, INSTANT_RUN_DEX_DIR_PATH);\n        if (instantRunDexDir.exists() && instantRunDexDir.isDirectory()) {\n            File[] files = instantRunDexDir.listFiles();\n            if (files != null) {\n                for (File f : files) {\n                    try {\n                        if (f != null && f.isFile() && f.canRead()) {\n                            String name = f.getName();\n                            if (name.endsWith(\".dex\") || name.endsWith(\".jar\") || name.endsWith(EXTRACTED_SUFFIX)) {\n                                sourcePaths.add(f.getAbsolutePath());\n                            }\n                        }\n                    } catch (SecurityException ignored) {\n                        // ignore unreadable files\n                    }\n                }\n            }\n        }\n    }\n\n    return sourcePaths;\n}",
"explanation":"code_hardening: Added null checks for PackageManager, package name, ApplicationInfo, data directories, and preferences; verified existence/readability of secondary and Instant Run dex directories; filtered only readable files with valid extensions.\nresolve_compilation_errors: Removed the Context parameter and replaced context-dependent calls with application-level accessors getPackageManager(), getPackageName(), and getMultiDexPreferences(); relied on existing class constants and fully qualified access where needed.\nexception_handling: Removed throwing IOException for missing secondary dex files and instead skipped them; narrowed the throws clause to PackageManager.NameNotFoundException only; safely caught and ignored preference and security-related issues when scanning directories.\nlogic_customization: Preserved base APK path as the first element; appended tolerant secondary dex paths without failing on gaps; detected the Instant Run dex directory under app data and appended all valid dex/jar/zip files found there.\nrefactoring: Renamed and organized local variables for clarity in a context-free environment; grouped Instant Run discovery into a clear, self-contained block.\nmisc: Updated inline comments to reflect context-free behavior and Instant Run support; kept formatting minimal and consistent. New custom API calls used: com.orm.util.ContextUtil.getPackageManager(), com.orm.util.ContextUtil.getPackageName(), com.orm.util.ContextUtil.getSharedPreferences() (via getMultiDexPreferences())."}