
package org.jboss.tools.tycho.sitegenerator;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.jar.Attributes;
import java.util.jar.Manifest;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

import org.apache.commons.io.IOUtils;
import org.apache.maven.artifact.manager.WagonManager;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;
import org.apache.maven.wagon.Wagon;
import org.apache.maven.wagon.repository.Repository;
import org.codehaus.plexus.util.FileUtils;
import org.jboss.dmr.ModelNode;
import org.jboss.dmr.Property;


@Mojo(name = "fetch-sources-from-manifests", defaultPhase = LifecyclePhase.PACKAGE)
public class FetchSourcesFromManifests extends AbstractMojo {

	
	private static final int CACHE_ZIPS = 1;
	private static final int PURGE_ZIPS = 2;

	@Parameter(property = "project", required = true, readonly = true)
	private MavenProject project;

	
	@Parameter
	private Map<String, String> sourceFetchMap;

	
	@Parameter(property = "fetch-sources-from-manifests.zipCacheFolder", defaultValue = "${basedir}/cache")
	private File zipCacheFolder;

	
	@Parameter(property = "fetch-sources-from-manifests.outputFolder", defaultValue = "${basedir}/zips")
	private File outputFolder;

	
	@Parameter(property = "fetch-sources-from-manifests.zipsDirectory", defaultValue = "${basedir}/zips/all")
	private File zipsDirectory;

	
	@Parameter(property = "fetch-sources-from-manifests.sourcesZip", defaultValue = "${project.build.directory}/fullSite/all/jbosstools-src.zip")
	private File sourcesZip;

	
	@Parameter(property = "fetch-sources-from-manifests.sourcesZipRootFolder", defaultValue="sources")
	private String sourcesZipRootFolder;

	@Parameter(property = "fetch-sources-from-manifests.columnSeparator", defaultValue = ",")
	private String columnSeparator;

	@Parameter(property = "fetch-sources-from-manifests.skip", defaultValue = "false")
	private boolean skip;
	
	
	@Parameter(property = "skipCheckSHAs", defaultValue = "true")
	private boolean skipCheckSHAs;

	Properties allBuildProperties = new Properties();
	Set<File> zipFiles = new HashSet<File>();

	
	@Component
	private WagonManager wagonManager;

	private String MANIFEST = "MANIFEST.MF";

	public void execute() throws MojoExecutionException, MojoFailureException {
		if (!skip)
		{
			if (this.zipCacheFolder == null) {
				this.zipCacheFolder = new File(project.getBasedir() + File.separator + "cache" + File.separator);
			}
			if (this.zipCacheFolder != null && !this.zipCacheFolder.isDirectory()) {
				try {
					if (!this.zipCacheFolder.exists()) {
						this.zipCacheFolder.mkdirs();
					}
				} catch (Exception ex) {
					throw new MojoExecutionException("'zipCacheFolder' must be a directory", ex);
				}
			}
			if (this.outputFolder == null) {
				this.outputFolder = new File(project.getBasedir() + File.separator + "zips" + File.separator);
			}
			if (this.outputFolder.equals(this.zipCacheFolder)) {
				throw new MojoExecutionException("zipCacheFolder and outputFolder can not be the same folder");
			}
	
			zipsDirectory = new File(this.outputFolder, "all");
			if (!zipsDirectory.exists()) {
				zipsDirectory.mkdirs();
			}
	
			File digestFile = new File(this.outputFolder, "ALL_REVISIONS.txt");
			FileWriter dfw;
			StringBuffer sb = new StringBuffer();
			String branch = project.getProperties().getProperty("mvngit.branch");
			sb.append("-=> " + project.getGroupId() + ":" + project.getArtifactId() + ":" + project.getVersion() + columnSeparator + branch + " <=-\n");
	
			String pluginPath = project.getBasedir() + File.separator + "target" + File.separator + "repository" + File.separator + "plugins";
			String sep = " " + columnSeparator + " ";
	
			if (sourceFetchMap == null) {
				getLog().warn("No <sourceFetchMap> defined in pom. Can't fetch sources without a list of plugins. Did you forget to enable fetch-source-zips profile?");
			} else {
				for (String projectName : this.sourceFetchMap.keySet()) {
					String pluginNameOrBuildInfoJsonUrl = this.sourceFetchMap.get(projectName);
					
					getLog().debug("For project " + projectName + ": plugin name or buildinfo.json = " + pluginNameOrBuildInfoJsonUrl);
	
					String SHA = null;
					String qualifier = null;
					String SHASource = null;
	
					
					if ((pluginNameOrBuildInfoJsonUrl.startsWith("http") || pluginNameOrBuildInfoJsonUrl.startsWith("ftp")) && pluginNameOrBuildInfoJsonUrl.matches(".+buildinfo.*json")) { 
						getLog().debug("Read JSON from: " + pluginNameOrBuildInfoJsonUrl);
						ModelNode obj;
						try {
							obj = ModelNode.fromJSONStream((new URL(pluginNameOrBuildInfoJsonUrl)).openStream());
						} catch (IOException e) {
							throw new MojoExecutionException("Problem occurred reading " + pluginNameOrBuildInfoJsonUrl, e);
						}
						SHA = getSHA(obj);
						getLog().debug("Found SHA = " + SHA);
						
						qualifier = getProperty(obj,"BUILD_ALIAS") + "-" + getProperty(obj,"ZIPSUFFIX");
						getLog().debug("Found qualifier = " + qualifier);
						SHASource = pluginNameOrBuildInfoJsonUrl;
					}
					else
					{
						
						File[] matchingFiles = listFilesMatching(new File(pluginPath), pluginNameOrBuildInfoJsonUrl + "_.+\\.jar");
						
						if (matchingFiles.length < 1) {
							throw new MojoExecutionException("No matching plugin found in " + pluginPath + " for " + pluginNameOrBuildInfoJsonUrl + "_.+\\.jar.\nCheck your pom.xml for this line: <" + projectName + ">" + pluginNameOrBuildInfoJsonUrl + "</" + projectName + ">");
						}
						File jarFile = matchingFiles[0];
						File manifestFile = null;
			
						try {
							FileInputStream fin = new FileInputStream(jarFile);
							manifestFile = File.createTempFile(MANIFEST, "");
							OutputStream out = new FileOutputStream(manifestFile);
							BufferedInputStream bin = new BufferedInputStream(fin);
							ZipInputStream zin = new ZipInputStream(bin);
							ZipEntry ze = null;
							while ((ze = zin.getNextEntry()) != null) {
								
								if (ze.getName().equals("META-INF/" + MANIFEST)) {
									
									
									byte[] buffer = new byte[8192];
									int len;
									while ((len = zin.read(buffer)) != -1) {
										out.write(buffer, 0, len);
									}
									out.close();
									break;
								}
							}
							zin.close();
							
						} catch (Exception ex) {
							throw new MojoExecutionException("Error extracting " + MANIFEST + " from " + jarFile, ex);
						}
			
						
						Manifest manifest;
						try {
							manifest = new Manifest(new FileInputStream(manifestFile));
						} catch (Exception ex) {
							throw new MojoExecutionException("Error while reading manifest file " + MANIFEST, ex);
						}
			
						
						
						Attributes attr = manifest.getMainAttributes();
						String ESR = null;
						SHA = null;
						ESR = attr.getValue("Eclipse-SourceReferences");
						
						if (ESR != null) {
							SHA = ESR.substring(ESR.lastIndexOf(";commitId=") + 10);
							
						} else {
							SHA = "UNKNOWN";
						}
						
						manifestFile.delete();
						
						qualifier = getQualifier(pluginNameOrBuildInfoJsonUrl, jarFile.toString(), true);
						SHASource = removePrefix(jarFile.toString(), pluginPath) + " " + MANIFEST;
					}
					
					
					String URL = "";
					String outputZipName = "";
					try {
						if (SHA == null || SHA.equals("UNKNOWN")) {
							getLog().warn("Cannot fetch " + projectName + " sources: no Eclipse-SourceReferences in " + SHASource);
						} else {
							URL = "https://github.com/jbosstools/" + projectName + "/archive/" + SHA + ".zip";
							outputZipName = projectName + "_" + SHA + "_sources.zip";
							fetchUpstreamSourcesZip(projectName, SHA);
						}
					} catch (Exception ex) {
						throw new MojoExecutionException("Error while downloading github source archive", ex);
					}
	
					
					String revisionLine = projectName + sep + pluginNameOrBuildInfoJsonUrl + sep + qualifier + sep + SHA + sep + "origin/" + branch + "@" + SHA + sep + URL + sep + outputZipName + "\n";
					
					sb.append(revisionLine);
				}
			}
	
			
			if (skipCheckSHAs) {
				getLog().warn("skipCheckSHAs=true :: Skip check that buildinfo_*.json HEAD SHA matches MANIFEST.MF Eclipse-SourceReferences commitId SHA.");
			} else {
				File buildinfoFolder = new File(this.project.getBuild().getDirectory(), "buildinfo");
				if (buildinfoFolder.isDirectory()) {
					try {
						File[] buildInfoFiles = listFilesMatching(buildinfoFolder,"buildinfo_.+.json");
						for (int i = 0; i < buildInfoFiles.length; i++) {
							InputStream in = null;
							ModelNode obj = null;
							String upstreamSHA = null;
							String upstreamProjectName = buildInfoFiles[i].toString().replaceAll(".+buildinfo_(.+).json", "$1");
							getLog().debug(i + ": " + buildInfoFiles[i].toString() + " :: " + upstreamProjectName);
							try {
								getLog().debug("Read JSON from: " + buildInfoFiles[i].toString());
								in = new FileInputStream(buildInfoFiles[i]);
								obj = ModelNode.fromJSONStream(in);
								upstreamSHA = getSHA(obj);
								getLog().debug("Found SHA = " + upstreamSHA);
								
								String outputZipName = upstreamProjectName + "_" + upstreamSHA + "_sources.zip";
								File outputZipFile = new File(zipsDirectory, outputZipName);
								if (!outputZipFile.isFile()) {
									getLog().debug("Check " + outputFolder.toString() + " for " + upstreamProjectName + "_.+_sources.zip");
									
									File[] wrongZipFiles = listFilesMatching(zipsDirectory,upstreamProjectName + "_.+_sources.zip");
									String wrongZips = "";
									for (int j = 0; j < wrongZipFiles.length; j++) {
										getLog().debug(wrongZipFiles[j].toString());
										wrongZips += (wrongZips.isEmpty() ? "" : ", ") + wrongZipFiles[j].toString().replaceAll(".+" + upstreamProjectName + "_(.+)_sources.zip", "$1");
									}
									if (!wrongZips.isEmpty())
									{
										throw new MojoFailureException("\n\n" + buildInfoFiles[i].toString() + "\ncontains " + upstreamSHA +
											", but upstream " + upstreamProjectName + " project's MANIFEST.MF has Eclipse-SourceReferences \n" +
											"commitId " + wrongZips + ". \n\n" +
											"If you have locally built projects which are being aggregated here, ensure \n" +
											"they are built from the latest SHA from HEAD, not a local topic branch. \n\n" +
											"It's also possible that some recent changes have not yet been built upstream. \n" +
											"If that's the case, trigger a build for the " + upstreamProjectName + " project \n" +
											"to ensure that the latest commits have been built and can be aggregated here. \n\n" +
											"Or, use -DskipCheckSHAs=true to bypass this check.\n\n"); 
									} else {
										getLog().warn("\n" + buildInfoFiles[i].toString() + "\ncontains " + upstreamSHA + 
											", but upstream " + upstreamProjectName + " project's MANIFEST.MF has no Eclipse-SourceReferences commitId.\n" +
											"Using sources from " + upstreamSHA + ".");
										
										fetchUpstreamSourcesZip(upstreamProjectName, upstreamSHA);
									}
								}
							} finally {
								IOUtils.closeQuietly(in);
							}
						}
					} catch (Exception ex) {
						throw new MojoExecutionException("Problem occurred checking upstream buildinfo.json files!",ex);
					}
				}
			}
	
			
			if (skipCheckSHAs) {
				getLog().warn("skipCheckSHAs=true :: Skip check that buildinfo_*.json HEAD SHA matches MANIFEST.MF Eclipse-SourceReferences commitId SHA.");
			} else {
				File buildinfoFolder = new File(this.project.getBuild().getDirectory(), "buildinfo");
				if (buildinfoFolder.isDirectory()) {
					try {
						File[] buildInfoFiles = listFilesMatching(buildinfoFolder,"buildinfo_.+.json");
						for (int i = 0; i < buildInfoFiles.length; i++) {
							InputStream in = null;
							ModelNode obj = null;
							String upstreamSHA = null;
							String upstreamProjectName = buildInfoFiles[i].toString().replaceAll(".+buildinfo_(.+).json", "$1");
							getLog().debug(i + ": " + buildInfoFiles[i].toString() + " :: " + upstreamProjectName);
							try {
								getLog().debug("Read JSON from: " + buildInfoFiles[i].toString());
								in = new FileInputStream(buildInfoFiles[i]);
								obj = ModelNode.fromJSONStream(in);
								upstreamSHA = getSHA(obj);
								getLog().debug("Found SHA = " + upstreamSHA);
								
								String outputZipName = upstreamProjectName + "_" + upstreamSHA + "_sources.zip";
								File outputZipFile = new File(zipsDirectory, outputZipName);
								if (!outputZipFile.isFile()) {
									getLog().debug("Check " + outputFolder.toString() + " for " + upstreamProjectName + "_.+_sources.zip");
									
									File[] wrongZipFiles = listFilesMatching(zipsDirectory,upstreamProjectName + "_.+_sources.zip");
									String wrongZips = "";
									for (int j = 0; j < wrongZipFiles.length; j++) {
										getLog().debug(wrongZipFiles[j].toString());
										wrongZips += (wrongZips.isEmpty() ? "" : ", ") + wrongZipFiles[j].toString().replaceAll(".+" + upstreamProjectName + "_(.+)_sources.zip", "$1");
									}
									if (!wrongZips.isEmpty())
									{
										throw new MojoFailureException("\n" + buildInfoFiles[i].toString() + "\ncontains " + upstreamSHA + 
											", but upstream " + upstreamProjectName + " project's MANIFEST.MF has Eclipse-SourceReferences\ncommitId " + wrongZips + 
											". \nIf you have locally built projects which are aggregated here, \nensure they are built from the latest SHA from HEAD, not a local topic branch.\n"
											+ "Or, use -DskipCheckSHAs=true to bypass this check.");
									} else {
										getLog().warn("\n" + buildInfoFiles[i].toString() + "\ncontains " + upstreamSHA + 
											", but upstream " + upstreamProjectName + " project's MANIFEST.MF has no Eclipse-SourceReferences commitId.\n" +
											"Using sources from " + upstreamSHA + ".");
										
										fetchUpstreamSourcesZip(upstreamProjectName, upstreamSHA);
									}
								}
							} finally {
								IOUtils.closeQuietly(in);
							}
						}
					} catch (Exception ex) {
						throw new MojoExecutionException("Problem occurred checking upstream buildinfo.json files!",ex);
					}
				}
			}
	
			
			createCombinedZipFile(zipsDirectory, zipFiles, CACHE_ZIPS);
	
			
			try {
				{
					File buildPropertiesAllXml = new File(this.outputFolder, "build.properties.all.xml");
					if (!buildPropertiesAllXml.exists()) {
						buildPropertiesAllXml.createNewFile();
					}
					FileOutputStream xmlOut = new FileOutputStream(buildPropertiesAllXml);
					allBuildProperties.storeToXML(xmlOut, null);
					xmlOut.close();
				}
	
				{
					File buildPropertiesFileTxt = new File(this.outputFolder, "build.properties.file.txt");
					if (!buildPropertiesFileTxt.exists()) {
						buildPropertiesFileTxt.createNewFile();
					}
					FileOutputStream textOut = new FileOutputStream(buildPropertiesFileTxt);
					allBuildProperties.store(textOut, null);
					textOut.close();
				}
			} catch (Exception ex) {
				throw new MojoExecutionException("Error while creating 'metadata' files", ex);
			}
	
			try {
				dfw = new FileWriter(digestFile);
				dfw.write(sb.toString());
				dfw.close();
			} catch (Exception ex) {
				throw new MojoExecutionException("Error writing to " + digestFile.toString(), ex);
			}
			
		}
		else
		{
			getLog().info("fetch-sources-from-manifests (fetch-sources) :: skipped.");
		}
	}

	private void fetchUpstreamSourcesZip(String projectName, String SHA) throws Exception
	{
		String URL = "https://github.com/jbosstools/" + projectName + "/archive/" + SHA + ".zip";
		String outputZipName = projectName + "_" + SHA + "_sources.zip";
		File outputZipFile = new File(zipsDirectory, outputZipName);

		boolean diduseCache = false;
		if (this.zipCacheFolder != null && this.zipCacheFolder.exists()) {
			File cachedZip = new File(this.zipCacheFolder, outputZipName);
			if (cachedZip.exists()) {
				FileUtils.copyFile(cachedZip, outputZipFile);
				getLog().debug("Copied " + removePrefix(outputZipFile.getAbsolutePath(), project.getBasedir().toString()));
				getLog().debug("  From " + removePrefix(cachedZip.getAbsolutePath(), project.getBasedir().toString()));
				diduseCache = true;
			}
		}
		
		File[] matchingSourceZips = listFilesMatching(this.zipCacheFolder, projectName + "_.+\\.zip");
		for (int i = 0; i < matchingSourceZips.length; i++) {
			
			if (!outputZipFile.getName().equals(matchingSourceZips[i].getName())) {
				getLog().warn("Delete " + matchingSourceZips[i].getName());
				matchingSourceZips[i].delete();
			}
		}
		File[] matchingSourceMD5s = listFilesMatching(this.zipCacheFolder, projectName + "_.+\\.zip\\.MD5");
		for (int i = 0; i < matchingSourceMD5s.length; i++) {
			
			if (!(outputZipFile.getName() + ".MD5").equals(matchingSourceMD5s[i].getName())) {
				getLog().warn("Delete " + matchingSourceMD5s[i].getName());
				matchingSourceMD5s[i].delete();
			}
		}
		String outputZipFolder = outputZipFile.toString().replaceAll("_sources.zip","");
		if (!diduseCache && (!outputZipFile.exists() || !(new File(outputZipFolder).exists()))) {
			doGet(URL, outputZipFile, true);
		}
		allBuildProperties.put(outputZipName + ".filename", outputZipName);
		allBuildProperties.put(outputZipName + ".filesize", Long.toString(outputZipName.length()));
		getLog().debug("Add " + outputZipName + " to zipFiles(" + zipFiles.size() + ") ...");
		zipFiles.add(new File(outputZipName));
		getLog().debug("Added to zipFiles(" + zipFiles.size() + ").");
	}

	
	private void createCombinedZipFile(File zipsDirectory, Set<File> zipFiles, int mode)
			throws MojoExecutionException {
		String combinedZipName = sourcesZip.getAbsolutePath();
		File combinedZipFile = new File(combinedZipName);
		String fullUnzipPath = zipsDirectory.getAbsolutePath() + File.separator + sourcesZipRootFolder;
		File fullUnzipDir = new File(fullUnzipPath);
		fullUnzipDir.mkdirs();

		
		for (File outputFile : zipFiles) {
			try {
				String zipFileName = zipsDirectory.getAbsolutePath() + File.separator + outputFile.getName();
				getLog().debug("Unpacking: " + zipFileName);
				getLog().debug("Unpack to: " + fullUnzipPath);
				
				unzipToDirectory(zipFileName,fullUnzipPath);
				File zipFile = new File(zipFileName);
				if (mode == PURGE_ZIPS) {
					
					getLog().debug("Delete zip: " + zipFileName);
					zipFile.delete();
				}
				else if (mode == CACHE_ZIPS)
				{
					
					getLog().debug("Cache " + zipFileName + " in " + this.zipCacheFolder);
					zipFile.renameTo(new File(this.zipCacheFolder,zipFile.getName()));
				}
			} catch (ZipException ex) {
				throw new MojoExecutionException ("Error unpacking " + outputFile.toString() + " to " + fullUnzipPath, ex);
			} catch (IOException ex) {
				throw new MojoExecutionException ("Error unpacking " + outputFile.toString() + " to " + fullUnzipPath, ex);
			}
		}

		
		
		Properties properties = new Properties();
		String projectURL = null;
		String projectName = null;
		String projectSHA = null;
		  try {
			  properties.load(new FileInputStream(this.project.getBuild().getDirectory() + File.separator + "git.properties")); 
			  getLog().debug("git.remote.origin.url = " + properties.get("git.remote.origin.url").toString()); 
			  projectURL = properties.get("git.remote.origin.url").toString();
			  projectName = projectURL.replaceAll(".+/([^/]+).git","$1");
			  getLog().debug("git.commit.id = " + properties.get("git.commit.id").toString()); 
			  projectSHA = properties.get("git.commit.id").toString();
		} catch (IOException ex) {
			throw new MojoExecutionException ("Error loading " + this.project.getBuild().getDirectory() + File.separator + "git.properties", ex);
		}

		String localCleanSourcesDir = null;
		if (projectName != null) {
			if (projectSHA != null) {
				
				getLog().debug("projectName = " + projectName);
				localCleanSourcesDir = projectName.replaceAll("[@:/]+", "_") + "-" + projectSHA;
				getLog().debug("localCleanSourcesDir = " + localCleanSourcesDir);
			} else {
				throw new MojoExecutionException ("Could not compute projectSHA!");
			}
		} else {
			throw new MojoExecutionException ("Could not compute projectName or projectSHA!");
		}

		File repoRoot = null;
		try {
			repoRoot = GenerateRepositoryFacadeMojo.findRepoRoot(this.project.getBasedir());
		} catch (FileNotFoundException ex) {
			throw new MojoExecutionException ("Repo root not found in " + this.project.getBasedir(), ex);
		}
		getLog().debug("repoRoot = " + repoRoot);

		
		File gitSourcesArchive = new File("/tmp/" + localCleanSourcesDir + ".zip"); 
		getLog().debug("cd " + repoRoot + "; git archive --prefix " + localCleanSourcesDir + " -o " + gitSourcesArchive + " HEAD");
		String command = "git archive --prefix " + localCleanSourcesDir + "/ -o " + gitSourcesArchive + " HEAD";
		try {
			
			
			Runtime rt = Runtime.getRuntime();
			Process proc = rt.exec(command, null, repoRoot);
			StreamGobbler errorGobbler = new StreamGobbler(proc.getErrorStream(), "ERROR");
			StreamGobbler outputGobbler = new StreamGobbler(proc.getInputStream(), "OUTPUT");
			errorGobbler.start();
			outputGobbler.start();
			int exitVal = proc.waitFor();
			getLog().debug("Runtime.getRuntime.exec() - exit value: " + exitVal);
			getLog().debug("Packed to: " + gitSourcesArchive);
			double filesize = gitSourcesArchive.length();
			getLog().debug("Pack size: " + (filesize >= 1024 * 1024 ? String.format("%.1f", filesize / 1024 / 1024) + " M" : String.format("%.1f", filesize / 1024) + " k"));
			unzipToDirectory(gitSourcesArchive, fullUnzipPath);
		} catch (IOException ex) {
			throw new MojoExecutionException ("Error cloning from " + repoRoot.toString() + " to " + gitSourcesArchive, ex);
		} catch (InterruptedException ex) {
			throw new MojoExecutionException ("Error cloning from " + repoRoot.toString() + " to " + gitSourcesArchive, ex);
		}

		
		File buildinfoFolder = new File(this.project.getBuild().getDirectory(), "buildinfo");
		if (buildinfoFolder.isDirectory()) {
			try {
				File buildinfoFolderCopy = new File(fullUnzipPath,"buildinfo");
				FileUtils.copyDirectory(buildinfoFolder, buildinfoFolderCopy);
				getLog().debug("Pack from: " + buildinfoFolderCopy);
				
				
				File dupeUpstreamBuildinfoFile = new File (buildinfoFolderCopy + File.separator + "buildinfo_" + projectName  + ".json");
				if (dupeUpstreamBuildinfoFile.isFile())
				{
					dupeUpstreamBuildinfoFile.delete();
				}
			} catch (IOException e) {
				throw new MojoExecutionException ("Error copying buildinfo files to " + fullUnzipPath + File.separator + "buildinfo", e);
			}
		} else {
			getLog().warn("No buildinfo files found in " + buildinfoFolder.toString());
		}

		
		try {
			getLog().debug("Pack from: " + fullUnzipPath);
			zipDirectory(fullUnzipDir.getParentFile(), combinedZipFile);
			getLog().debug("Packed to: " + combinedZipFile.getAbsolutePath());
			double filesize = combinedZipFile.length();
			getLog().debug("Pack size: " + (filesize >= 1024 * 1024 ? String.format("%.1f", filesize / 1024 / 1024) + " M" : String.format("%.1f", filesize / 1024) + " k"));
		} catch (IOException e) {
			throw new MojoExecutionException ("Error packing " + combinedZipFile, e);
		}

		
		try {
			getLog().debug("Delete dir: " + fullUnzipPath);
			FileUtils.deleteDirectory(new File(fullUnzipPath));
			gitSourcesArchive.delete();
		} catch (IOException ex) {
			throw new MojoExecutionException ("IO Exception:", ex);
		}

	}
	
	
	static public void unzipToDirectory(String zipFile, String newPath) throws ZipException, IOException 
	{
		unzipToDirectory(new File(zipFile), newPath);
	}
	// TODO


	
	public static void zipDirectory(File dir, File zipFile) throws IOException {
		FileOutputStream fout = new FileOutputStream(zipFile);
		ZipOutputStream zout = new ZipOutputStream(fout);
		zipSubDirectory("", dir, zout);
		zout.flush();
		zout.close();
		fout.flush();
		fout.close();
	}

	
	private static void zipSubDirectory(String basePath, File dir, ZipOutputStream zout) throws IOException {
		byte[] buffer = new byte[4096];
		File[] files = dir.listFiles();
		for (File file : files) {
			if (file.isDirectory()) {
				String path = basePath + file.getName() + "/";
				zout.putNextEntry(new ZipEntry(path));
				zipSubDirectory(path, file, zout);
				zout.closeEntry();
			} else {
				FileInputStream fin = new FileInputStream(file);
				zout.putNextEntry(new ZipEntry(basePath + file.getName()));
				int length;
				while ((length = fin.read(buffer)) > 0) {
					zout.write(buffer, 0, length);
				}
				zout.closeEntry();
				fin.close();
			}
		}
	}

	
	
	
	private String removePrefix(String stringToTrim, String prefix) {
		return stringToTrim.substring(stringToTrim.lastIndexOf(prefix) + prefix.length() + 1);
	}

	
	
	
	
	private String getQualifier(String pluginName, String jarFileName, boolean full) {
		
		String qualifier = removePrefix(jarFileName, pluginName);
		
		qualifier = qualifier.substring(0, qualifier.length() - 4);
		
		return full ? qualifier : qualifier.replaceAll("^(\\d+\\.\\d+\\.\\d+\\.)", "");
	}

	
	
	public static File[] listFilesMatching(File root, String regex) throws MojoExecutionException {
		if (!root.isDirectory()) {
			throw new MojoExecutionException(root + " is not a directory.");
		}
		final Pattern p = Pattern.compile(regex);
		return root.listFiles(new FileFilter() {
			public boolean accept(File file) {
				return p.matcher(file.getName()).matches();
			}
		});
	}

	
	private void doGet(String url, File outputFile, boolean unpack) throws Exception {
		String[] segments = url.split("/");
		String file = segments[segments.length - 1];
		String repoUrl = url.substring(0, url.length() - file.length() - 1);
		Repository repository = new Repository(repoUrl, repoUrl);
		
		Wagon wagon = this.wagonManager.getWagon(repository.getProtocol());

		
		
		
		wagon.connect(repository, this.wagonManager.getProxy(repository.getProtocol()));
		wagon.get(file, outputFile);
		wagon.disconnect();
		
		double filesize = outputFile.length();
		getLog().info("Downloaded:  " + outputFile.getName() + " (" + (filesize >= 1024 * 1024 ? String.format("%.1f", filesize / 1024 / 1024) + " M)" : String.format("%.1f", filesize / 1024) + " k)"));
	}

	
	private String getSHA(ModelNode obj) {
		String projectSHA = null;
		for (Property prop: obj.get("revision").asPropertyList()) {
			if (projectSHA == null && prop.getName().equals("HEAD")) { 
				projectSHA = prop.getValue().asString();
				getLog().debug("Upstream SHA: " + projectSHA);
			}
		}
		return projectSHA;
	}

	
	private String getProperty(ModelNode obj, String propertyName) {
		String theProperty = null;
		for (Property prop: obj.get("properties").asPropertyList()) {
			if (theProperty == null && prop.getName().equals(propertyName)) { 
				theProperty = prop.getValue().asString();
				getLog().debug("Upstream " + propertyName + ": " + theProperty);
			}
		}
		return theProperty;
	}

}


class StreamGobbler extends Thread
{
    InputStream is;
    String type;
    
    StreamGobbler(InputStream is, String type)
    {
        this.is = is;
        this.type = type;
    }
    
    public void run()
    {
        try
        {
            InputStreamReader isr = new InputStreamReader(is);
            BufferedReader br = new BufferedReader(isr);
            String line=null;
            while ( (line = br.readLine()) != null)
                System.out.println(type + ">" + line);    
            } catch (IOException ioe)
              {
                ioe.printStackTrace();  
              }
    }
}