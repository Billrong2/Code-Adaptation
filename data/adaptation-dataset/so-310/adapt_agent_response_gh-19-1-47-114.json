{
"code": "/**\n     * Unzips the given ZIP file into its parent directory (\"unzip here\").\n     * <p>\n     * The internal directory structure of the ZIP is preserved. Nested ZIP files\n     * found during extraction are processed recursively using the same strategy.\n     * </p>\n     * <p>\n     * I/O errors on individual entries are logged and do not stop the overall\n     * extraction process.\n     * </p>\n     *\n     * @param zipFilePath absolute or relative path to a ZIP file\n     */\n    public static void unzip(final String zipFilePath) {\n        final int BUFFER_SIZE = 2048;\n\n        if (zipFilePath == null) {\n            LOG.warn(\"Zip file path is null, skipping unzip\");\n            return;\n        }\n\n        final File zipFile = new File(zipFilePath);\n        if (!zipFile.exists() || !zipFile.isFile()) {\n            LOG.warn(\"Zip file does not exist or is not a file: {}\", zipFilePath);\n            return;\n        }\n\n        final File targetDir = zipFile.getParentFile();\n        if (targetDir == null) {\n            LOG.warn(\"Cannot determine parent directory for zip: {}\", zipFilePath);\n            return;\n        }\n\n        ZipFile zip = null;\n        try {\n            zip = new ZipFile(zipFile);\n            final Enumeration<? extends ZipEntry> entries = zip.entries();\n\n            while (entries.hasMoreElements()) {\n                final ZipEntry entry = entries.nextElement();\n                final String entryName = entry.getName();\n\n                try {\n                    final File destFile = new File(targetDir, entryName);\n\n                    // Zip Slip protection\n                    final String destCanonicalPath = destFile.getCanonicalPath();\n                    final String targetCanonicalPath = targetDir.getCanonicalPath() + File.separator;\n                    if (!destCanonicalPath.startsWith(targetCanonicalPath)) {\n                        LOG.error(\"Blocked zip entry outside target dir: {}\", entryName);\n                        continue;\n                    }\n\n                    if (entry.isDirectory()) {\n                        if (!destFile.exists() && !destFile.mkdirs()) {\n                            LOG.warn(\"Unable to create directory: {}\", destFile.getAbsolutePath());\n                        }\n                        continue;\n                    }\n\n                    final File parentDir = destFile.getParentFile();\n                    if (parentDir != null && !parentDir.exists() && !parentDir.mkdirs()) {\n                        LOG.warn(\"Unable to create parent directory: {}\", parentDir.getAbsolutePath());\n                    }\n\n                    try (BufferedInputStream in = new BufferedInputStream(zip.getInputStream(entry));\n                         BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(destFile), BUFFER_SIZE)) {\n\n                        final byte[] buffer = new byte[BUFFER_SIZE];\n                        int read;\n                        while ((read = in.read(buffer)) != -1) {\n                            out.write(buffer, 0, read);\n                        }\n                        out.flush();\n                    }\n\n                    if (entryName.toLowerCase().endsWith(\".zip\")) {\n                        unzip(destFile.getAbsolutePath());\n                    }\n                } catch (IOException entryEx) {\n                    LOG.error(\"Error extracting zip entry: {}\", entryName, entryEx);\n                }\n            }\n        } catch (IOException e) {\n            LOG.error(\"Error opening zip file: {}\", zipFilePath, e);\n        } finally {\n            if (zip != null) {\n                try {\n                    zip.close();\n                } catch (IOException e) {\n                    LOG.warn(\"Error closing zip file: {}\", zipFilePath, e);\n                }\n            }\n        }\n    }",
"explanation": "code_hardening: Validated the input path for null, existence, and file type; introduced a named BUFFER_SIZE constant; ensured all streams and the ZipFile are reliably closed using try-with-resources and a finally block; added Zip Slip protection by validating canonical paths against the target parent directory.\nresolve_compilation_errors: Updated the zip entries enumeration to Enumeration<? extends ZipEntry>; made the method static and removed any console output; relied on existing SLF4J Logger already present in the class (org.slf4j.Logger, org.slf4j.LoggerFactory).\nexception_handling: Removed throws from the signature; wrapped per-entry extraction logic in its own try/catch to log IOException errors and continue processing remaining entries; handled ZipFile open/close errors separately with logging.\nlogic_customization: Changed the extraction target to the ZIP fileâ€™s parent directory; preserved the internal directory structure by using the full ZipEntry name; maintained recursive handling of nested .zip files using the same target-directory logic.\nrefactoring: Renamed parameters and locals for clarity (zipFilePath, targetDir, BUFFER_SIZE); simplified control flow and localized error handling within the loop; added comprehensive Javadoc describing behavior, recursion, and error-handling strategy.\nmisc: Replaced System.out.println with SLF4J logging at appropriate levels; formatted code to standard Java style; no new custom API calls beyond existing SLF4J logging were introduced."
}