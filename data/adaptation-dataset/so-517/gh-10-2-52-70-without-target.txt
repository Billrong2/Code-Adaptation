

package info.guardianproject.netcipher.proxy;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.pm.ResolveInfo;
import android.content.pm.Signature;
import android.util.Log;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.List;

public class SignatureUtils {
  public static String getOwnSignatureHash(Context ctxt)
                                                        throws
    NameNotFoundException,
    NoSuchAlgorithmException {
    return(getSignatureHash(ctxt, ctxt.getPackageName()));
  }

  public static String getSignatureHash(Context ctxt, String packageName)
                                                                         throws
    NameNotFoundException,
    NoSuchAlgorithmException {
    MessageDigest md=MessageDigest.getInstance("SHA-256");
    Signature sig=
        ctxt.getPackageManager()
            .getPackageInfo(packageName, PackageManager.GET_SIGNATURES).signatures[0];

    return(toHexStringWithColons(md.digest(sig.toByteArray())));
  }

  

  // TODO


  
  public static Intent validateBroadcastIntent(Context ctxt,
                                               Intent toValidate,
                                               String sigHash,
                                               boolean failIfHack) {
    ArrayList<String> sigHashes=new ArrayList<String>();

    sigHashes.add(sigHash);

    return(validateBroadcastIntent(ctxt, toValidate, sigHashes,
      failIfHack));
  }

  
  public static Intent validateBroadcastIntent(Context ctxt,
                                               Intent toValidate,
                                               List<String> sigHashes,
                                               boolean failIfHack) {
    PackageManager pm=ctxt.getPackageManager();
    Intent result=null;
    List<ResolveInfo> receivers=
      pm.queryBroadcastReceivers(toValidate, 0);

    if (receivers!=null) {
      for (ResolveInfo info : receivers) {
        try {
          if (sigHashes.contains(getSignatureHash(ctxt,
            info.activityInfo.packageName))) {
            ComponentName cn=
              new ComponentName(info.activityInfo.packageName,
                info.activityInfo.name);

            result=new Intent(toValidate).setComponent(cn);
            break;
          }
          else if (failIfHack) {
            throw new SecurityException(
              "Package has signature hash mismatch: "+
                info.activityInfo.packageName);
          }
        }
        catch (NoSuchAlgorithmException e) {
          Log.w("SignatureUtils",
            "Exception when computing signature hash", e);
        }
        catch (NameNotFoundException e) {
          Log.w("SignatureUtils",
            "Exception when computing signature hash", e);
        }
      }
    }

    return(result);
  }

  
  public static Intent validateActivityIntent(Context ctxt,
                                              Intent toValidate,
                                              String sigHash,
                                              boolean failIfHack) {
    ArrayList<String> sigHashes=new ArrayList<String>();

    sigHashes.add(sigHash);

    return(validateActivityIntent(ctxt, toValidate, sigHashes,
      failIfHack));
  }

  
  public static Intent validateActivityIntent(Context ctxt,
                                              Intent toValidate,
                                              List<String> sigHashes,
                                              boolean failIfHack) {
    PackageManager pm=ctxt.getPackageManager();
    Intent result=null;
    List<ResolveInfo> activities=
      pm.queryIntentActivities(toValidate, 0);

    if (activities!=null) {
      for (ResolveInfo info : activities) {
        try {
          if (sigHashes.contains(getSignatureHash(ctxt,
            info.activityInfo.packageName))) {
            ComponentName cn=
              new ComponentName(info.activityInfo.packageName,
                info.activityInfo.name);

            result=new Intent(toValidate).setComponent(cn);
            break;
          }
          else if (failIfHack) {
            throw new SecurityException(
              "Package has signature hash mismatch: "+
                info.activityInfo.packageName);
          }
        }
        catch (NoSuchAlgorithmException e) {
          Log.w("SignatureUtils",
            "Exception when computing signature hash", e);
        }
        catch (NameNotFoundException e) {
          Log.w("SignatureUtils",
            "Exception when computing signature hash", e);
        }
      }
    }

    return(result);
  }

  
  public static Intent validateServiceIntent(Context ctxt,
                                             Intent toValidate,
                                             String sigHash,
                                             boolean failIfHack) {
    ArrayList<String> sigHashes=new ArrayList<String>();

    sigHashes.add(sigHash);

    return(validateServiceIntent(ctxt, toValidate, sigHashes,
      failIfHack));
  }

  
  public static Intent validateServiceIntent(Context ctxt,
                                             Intent toValidate,
                                             List<String> sigHashes,
                                             boolean failIfHack) {
    PackageManager pm=ctxt.getPackageManager();
    Intent result=null;
    List<ResolveInfo> services=
      pm.queryIntentServices(toValidate, 0);

    if (services!=null) {
      for (ResolveInfo info : services) {
        try {
          if (sigHashes.contains(getSignatureHash(ctxt,
            info.serviceInfo.packageName))) {
            ComponentName cn=
              new ComponentName(info.serviceInfo.packageName,
                info.serviceInfo.name);

            result=new Intent(toValidate).setComponent(cn);
            break;
          }
          else if (failIfHack) {
            throw new SecurityException(
              "Package has signature hash mismatch: "+
                info.activityInfo.packageName);
          }
        }
        catch (NoSuchAlgorithmException e) {
          Log.w("SignatureUtils",
            "Exception when computing signature hash", e);
        }
        catch (NameNotFoundException e) {
          Log.w("SignatureUtils",
            "Exception when computing signature hash", e);
        }
      }
    }

    return(result);
  }
}
