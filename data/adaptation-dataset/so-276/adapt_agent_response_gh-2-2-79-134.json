{
  "code": "protected void parse(final WebAppContext context, final AnnotationParser parser) throws Exception\n{\n    if (context == null || parser == null)\n        return;\n\n    final ClassLoader webAppClassLoader = context.getClassLoader();\n    final java.util.Collection<Resource> resources = new java.util.LinkedHashSet<Resource>();\n\n    collectResources(resources, webAppClassLoader);\n\n    for (Resource resource : resources)\n    {\n        if (resource == null)\n            return; // early exit as requested\n\n        try\n        {\n            // Clear parser state for each resource\n            parser.clearHandlers();\n\n            // Re-register all handlers for this resource\n            for (DiscoverableAnnotationHandler h : _discoverableAnnotationHandlers)\n            {\n                if (h instanceof AbstractDiscoverableAnnotationHandler)\n                    ((AbstractDiscoverableAnnotationHandler)h).reset();\n                parser.registerHandler(h);\n            }\n\n            if (_classInheritanceHandler != null)\n                parser.registerHandler(_classInheritanceHandler);\n\n            for (DiscoverableAnnotationHandler h : _containerInitializerAnnotationHandlers)\n                parser.registerHandler(h);\n\n            // ClassNameResolver that excludes only system classes and respects parent-first semantics\n            ClassNameResolver resolver = new ClassNameResolver()\n            {\n                @Override\n                public boolean isExcluded(String name)\n                {\n                    return name != null && (name.startsWith(\"java.\") || name.startsWith(\"javax.\") || name.startsWith(\"sun.\"));\n                }\n\n                @Override\n                public boolean shouldOverride(String name)\n                {\n                    // If parent loader priority is true, do not override parent classes\n                    return !context.isParentLoaderPriority();\n                }\n            };\n\n            parser.parse(resource, resolver);\n        }\n        catch (Exception e)\n        {\n            // Log and continue with remaining resources, consistent with Jetty scanning behavior\n            context.getServletContext().log(\"Annotation parsing failed for resource \" + resource, e);\n        }\n    }\n}",
  "explanation": "code_hardening: Added null checks for context, parser, and resources; returned early on a null resource; defensively reset parser and handler state before each resource; used final parameters where applicable.\nresolve_compilation_errors: Explicitly declared the parse(WebAppContext, AnnotationParser) method; used fully qualified java.util collections where needed; relied on existing fields (_discoverableAnnotationHandlers, _classInheritanceHandler, _containerInitializerAnnotationHandlers) and the existing collectResources method; implemented an inline org.eclipse.jetty.annotations.ClassNameResolver.\nexception_handling: Declared throws Exception on the method; wrapped per-resource parsing in try/catch to allow continued scanning; logged failures via ServletContext rather than aborting the entire scan.\nlogic_customization: Moved all scanning logic into parse; collected classpath resources from the webapp classloader; for each resource cleared parser state, re-registered handlers, reset AbstractDiscoverableAnnotationHandler state, and invoked parsing; implemented a ClassNameResolver that excludes only system classes and respects parent-loader priority; intentionally avoided any metadata mutation.\nrefactoring: Separated configuration-time concerns from parsing by limiting this method strictly to per-resource parsing semantics; clarified variable naming and control flow to emphasize scanning responsibility.\nmisc: Updated inline comments to reflect the focused responsibility of parse and kept formatting consistent with Jetty style; new custom API usage: org.eclipse.jetty.annotations.ClassNameResolver (inline implementation) and AbstractDiscoverableAnnotationHandler.reset()."
}