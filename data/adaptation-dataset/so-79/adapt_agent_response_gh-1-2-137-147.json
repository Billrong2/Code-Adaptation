{
  "code": "/**\n     * Converts a byte count into a human-readable string using SI (1000) or binary (1024) units.\n     * <p>\n     * When {@code useSIUnits} is {@code true}, prefixes are k, M, G... based on powers of 1000.\n     * When {@code false}, prefixes are Ki, Mi, Gi... based on powers of 1024.\n     * The value is formatted with one decimal place using the default {@link java.util.Locale}.\n     *\n     * @param bytes the number of bytes to convert; negative values are treated as 0\n     * @param useSIUnits {@code true} for SI units (1000), {@code false} for binary units (1024)\n     * @return a human-readable representation such as \"1.5 MB\" or \"1.5 MiB\"\n     */\n    public static String humanReadableByteCount(final long bytes, final boolean useSIUnits) {\n        if (bytes <= 0) {\n            return \"0 B\";\n        }\n\n        final int unit = useSIUnits ? 1000 : 1024;\n        if (bytes < unit) {\n            return bytes + \" B\";\n        }\n\n        final String siPrefixes = \"kMGTPE\";\n        final String binaryPrefixes = \"KMGTPE\";\n\n        int exp = (int) (Math.log(bytes) / Math.log(unit));\n        // Clamp exponent to available prefixes to avoid overflow\n        exp = Math.min(exp, siPrefixes.length());\n\n        final char prefixChar = (useSIUnits ? siPrefixes : binaryPrefixes).charAt(exp - 1);\n        final String prefix = prefixChar + (useSIUnits ? \"\" : \"i\");\n\n        final double value = bytes / Math.pow(unit, exp);\n        return String.format(java.util.Locale.getDefault(), \"%.1f %sB\", value, prefix);\n    }",
  "explanation": "code_hardening: Added handling for non-positive byte values by returning \"0 B\", clamped the computed exponent to the available prefix range to avoid overflow, and marked parameters as final for immutability.\nresolve_compilation_errors: Replaced C# types and APIs with Java equivalents (boolean, Math.log/Math.pow), used charAt instead of string indexing, and referenced java.util.Locale.getDefault() with a fully qualified name to avoid import issues.\nexception_handling: No try-catch was introduced; the method documents and safely handles invalid numeric input (negative or zero bytes) without throwing exceptions.\nlogic_customization: Renamed the method to humanReadableByteCount and the boolean parameter to useSIUnits, preserved SI vs binary logic including the \"i\" suffix for binary units, and ensured locale-aware formatting via String.format with the default Locale.\nrefactoring: Extracted prefix strings into named variables, improved variable naming for clarity, and added a comprehensive JavaDoc describing behavior, parameters, and return value.\nmisc: Reformatted to standard Java style and added JavaDoc comments; no new custom APIs beyond java.util.Locale.getDefault() were introduced."
}