{
  "code": "/**\n\t * Recursively zip the contents of a directory, preserving directory structure.\n\t * \n\t * @param basePath relative path inside the zip (must end with '/' for directories)\n\t * @param dir the directory whose contents should be added\n\t * @param zipOut the ZipOutputStream to write entries to\n\t * @throws IOException if an I/O error occurs while zipping\n\t */\n\tprivate static void zipSubDirectory(final String basePath, final File dir, final ZipOutputStream zipOut) throws IOException {\n\t\tfinal int BUFFER_SIZE = 4096;\n\t\tfinal byte[] buffer = new byte[BUFFER_SIZE];\n\n\t\tif (dir == null || zipOut == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal File[] files = dir.listFiles();\n\t\tif (files == null) {\n\t\t\t// Nothing to do (I/O error or not a directory)\n\t\t\treturn;\n\t\t}\n\n\t\tfor (File file : files) {\n\t\t\tif (file.isDirectory()) {\n\t\t\t\tfinal String path = basePath + file.getName() + \"/\";\n\t\t\t\tzipOut.putNextEntry(new ZipEntry(path));\n\t\t\t\tzipOut.closeEntry();\n\t\t\t\tzipSubDirectory(path, file, zipOut);\n\t\t\t} else {\n\t\t\t\tzipOut.putNextEntry(new ZipEntry(basePath + file.getName()));\n\t\t\t\ttry (FileInputStream fileIn = new FileInputStream(file)) {\n\t\t\t\t\tint bytesRead;\n\t\t\t\t\twhile ((bytesRead = fileIn.read(buffer)) > 0) {\n\t\t\t\t\t\tzipOut.write(buffer, 0, bytesRead);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tzipOut.closeEntry();\n\t\t\t}\n\t\t}\n\t}",
  "explanation": "code_hardening: Added null checks for dir, zipOut, and the result of dir.listFiles() to avoid NullPointerException; ensured FileInputStream is always closed via try-with-resources; marked parameters as final.\nresolve_compilation_errors: Preserved the existing method signature used by zipDirectory and relied only on already-imported java.io and java.util.zip classes; no new symbols introduced.\nexception_handling: Replaced manual close() with try-with-resources for FileInputStream while keeping the declared throws IOException unchanged.\nlogic_customization: Maintained existing traversal and entry-creation behavior; explicitly closes directory entries before recursion and safely returns when directories cannot be listed.\nrefactoring: Renamed variables for clarity (zout → zipOut, fin → fileIn, length → bytesRead) and replaced the magic buffer size with a named constant.\nmisc: Added a descriptive Javadoc comment above the method and applied minor formatting and whitespace cleanup; no new custom API calls were introduced."
}