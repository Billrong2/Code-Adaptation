{
  "code": "  @Override\n  public void onMeasure(RecyclerView.Recycler recycler, RecyclerView.State state,\n      int widthSpec, int heightSpec) {\n\n    // Code hardening: null checks and empty adapter handling\n    if (recycler == null || state == null || getItemCount() <= 0) {\n      super.onMeasure(recycler, state, widthSpec, heightSpec);\n      return;\n    }\n\n    if (measuredDimension == null || measuredDimension.length < 2) {\n      measuredDimension = new int[2];\n    }\n\n    final int widthMode = View.MeasureSpec.getMode(widthSpec);\n    final int heightMode = View.MeasureSpec.getMode(heightSpec);\n    final int widthSize = View.MeasureSpec.getSize(widthSpec);\n    final int heightSize = View.MeasureSpec.getSize(heightSpec);\n\n    int totalWidth = 0;\n    int totalHeight = 0;\n\n    final int itemCount = getItemCount();\n    final int orientation = getOrientation();\n\n    // Measure children with UNSPECIFIED specs to get natural size\n    final int unspecifiedSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);\n\n    for (int i = 0; i < itemCount; i++) {\n      if (orientation == HORIZONTAL) {\n        measureScrapChild(recycler, i, unspecifiedSpec, unspecifiedSpec, measuredDimension);\n        totalWidth += measuredDimension[0];\n        if (i == 0) {\n          totalHeight = measuredDimension[1];\n        }\n      } else {\n        measureScrapChild(recycler, i, unspecifiedSpec, unspecifiedSpec, measuredDimension);\n        totalHeight += measuredDimension[1];\n        if (i == 0) {\n          totalWidth = measuredDimension[0];\n        }\n      }\n    }\n\n    // If content exceeds available space, fall back to default measurement (preserve scrolling)\n    if ((widthMode != View.MeasureSpec.UNSPECIFIED && totalWidth > widthSize)\n        || (heightMode != View.MeasureSpec.UNSPECIFIED && totalHeight > heightSize)) {\n      super.onMeasure(recycler, state, widthSpec, heightSpec);\n      return;\n    }\n\n    // Respect EXACTLY mode, otherwise keep computed dimensions\n    int finalWidth = totalWidth;\n    int finalHeight = totalHeight;\n\n    if (widthMode == View.MeasureSpec.EXACTLY) {\n      finalWidth = widthSize;\n    }\n    if (heightMode == View.MeasureSpec.EXACTLY) {\n      finalHeight = heightSize;\n    }\n\n    setMeasuredDimension(finalWidth, finalHeight);\n  }",
  "explanation": "code_hardening: Added null checks for recycler and state, guarded against empty adapters by delegating to super, and ensured the measuredDimension array is initialized and safe to reuse.\nresolve_compilation_errors: Used the existing measuredDimension field and existing measureScrapChild method; relied on fully qualified View.MeasureSpec constants already available in context and preserved the correct LinearLayoutManager onMeasure override signature.\nexception_handling: none.\nlogic_customization: Measured each child with UNSPECIFIED width and height to obtain natural size, preserved orientation-specific accumulation logic, compared total measured content against available width/height and delegated to super.onMeasure when exceeded, and respected EXACTLY mode while leaving other modes as computed.\nrefactoring: Replaced magic values with well-named local variables (totalWidth, totalHeight, unspecifiedSpec) and reduced repeated calls by caching orientation and itemCount.\nmisc: Updated inline comments to clarify wrap-content measurement behavior and fallback logic; formatting follows standard Android/Java style. No new custom API calls were introduced."
}