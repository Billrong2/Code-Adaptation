{
  "code": "public static <T> Matcher<Iterable<? super T>> exactlyNItems(final int n, final Matcher<? super T> elementMatcher) {\n  return new IsCollectionContaining<T>(elementMatcher) {\n    @Override\n    protected boolean matchesSafely(Iterable<? super T> collection, Description mismatchDescription) {\n      int count = 0;\n      boolean isPastFirst = false;\n\n      for (Object item : collection) {\n        if (elementMatcher.matches(item)) {\n          count++;\n        }\n        if (isPastFirst) {\n          mismatchDescription.appendText(\", \");\n        }\n        elementMatcher.describeMismatch(item, mismatchDescription);\n        isPastFirst = true;\n      }\n\n      if (count != n) {\n        mismatchDescription.appendText(\". Expected exactly \" + n + \" but got \" + count);\n      }\n      return count == n;\n    }\n  };\n}",
  "explanation": "code_hardening: Added the final modifier to the elementMatcher method parameter so it can be safely captured by the anonymous inner class without reassignment; no other hardening changes were introduced.\nresolve_compilation_errors: Marking elementMatcher as final ensures compatibility with preâ€“Java 8 anonymous inner class capture rules; no other compilation issues were identified or addressed.\nexception_handling: none.\nlogic_customization: none; the matching logic and mismatch description behavior remain exactly as in the original snippet.\nrefactoring: none; no renaming, restructuring, or behavioral refactoring was performed.\nmisc: Applied only minimal formatting consistent with the existing project style; no new custom API calls were introduced."
}