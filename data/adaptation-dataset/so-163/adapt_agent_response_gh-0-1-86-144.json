{
"code":"public static Map<JavaClass, Set<Method>> computeReferences(final JavaClass javaClass, final Map<String, JavaClass> knownJavaClasses) throws ClassNotFoundException\n{\n    final Map<JavaClass, Set<Method>> references = new LinkedHashMap<JavaClass, Set<Method>>();\n    if (javaClass == null || knownJavaClasses == null || knownJavaClasses.isEmpty())\n    {\n        return references;\n    }\n\n    final ConstantPool constantPool = javaClass.getConstantPool();\n    if (constantPool == null)\n    {\n        return references;\n    }\n    final ConstantPoolGen constantPoolGen = new ConstantPoolGen(constantPool);\n\n    for (final Method method : javaClass.getMethods())\n    {\n        if (method == null)\n        {\n            continue;\n        }\n        InstructionList instructionList = null;\n        try\n        {\n            final MethodGen methodGen = new MethodGen(method, javaClass.getClassName(), constantPoolGen);\n            instructionList = methodGen.getInstructionList();\n        }\n        catch (RuntimeException e)\n        {\n            // Malformed bytecode or unsupported structure; skip this method\n            continue;\n        }\n        if (instructionList == null)\n        {\n            continue;\n        }\n\n        for (final InstructionHandle handle : instructionList.getInstructionHandles())\n        {\n            if (handle == null)\n            {\n                continue;\n            }\n            final Instruction instruction = handle.getInstruction();\n            if (!(instruction instanceof InvokeInstruction))\n            {\n                continue;\n            }\n\n            final InvokeInstruction invokeInstruction = (InvokeInstruction) instruction;\n            ReferenceType referenceType;\n            try\n            {\n                referenceType = invokeInstruction.getReferenceType(constantPoolGen);\n            }\n            catch (RuntimeException e)\n            {\n                continue;\n            }\n            if (!(referenceType instanceof ObjectType))\n            {\n                continue;\n            }\n\n            final ObjectType objectType = (ObjectType) referenceType;\n            final String referencedClassName = objectType.getClassName();\n            if (referencedClassName == null)\n            {\n                continue;\n            }\n\n            final JavaClass referencedJavaClass = knownJavaClasses.get(referencedClassName);\n            if (referencedJavaClass == null)\n            {\n                continue;\n            }\n\n            final String invokedMethodName = invokeInstruction.getMethodName(constantPoolGen);\n            final Type[] argumentTypes = invokeInstruction.getArgumentTypes(constantPoolGen);\n            if (invokedMethodName == null)\n            {\n                continue;\n            }\n\n            final Method referencedMethod = findMethod(referencedJavaClass, invokedMethodName, argumentTypes);\n            if (referencedMethod == null)\n            {\n                continue;\n            }\n\n            Set<Method> methods = references.get(referencedJavaClass);\n            if (methods == null)\n            {\n                methods = new LinkedHashSet<Method>();\n                references.put(referencedJavaClass, methods);\n            }\n            methods.add(referencedMethod);\n        }\n    }\n\n    return references;\n}",
"explanation":"code_hardening: Added null checks for the input JavaClass, knownJavaClasses map, constant pool, methods, instruction lists, instruction handles, and resolved names; skipped methods with null InstructionList; guarded against non-ObjectType invocation targets; used LinkedHashMap and LinkedHashSet for deterministic ordering; marked parameters and key locals as final.\nresolve_compilation_errors: Removed any jar-scanning or printing logic and implemented the missing computeReferences method with a public static signature matching the new API; used BCEL types already present in the codebase (MethodGen, InstructionList, InvokeInstruction, ObjectType, Type); relied on the existing findMethod(JavaClass,String,Type[]) helper.\nexception_handling: Narrowed the throws clause to ClassNotFoundException only; caught and swallowed BCEL-related RuntimeException instances during method generation and reference resolution to avoid propagating malformed bytecode issues; avoided any console output.\nlogic_customization: Iterated over a single JavaClassâ€™s methods; filtered instructions to InvokeInstruction; resolved the referenced class via ObjectType and checked presence in knownJavaClasses; resolved invoked methods by name and argument types from the constant pool; aggregated unique Method instances per referenced JavaClass.\nrefactoring: Implemented a reusable computeReferences method with no side effects; simplified control flow with early continues; localized all analysis logic within this function without altering other APIs.\nmisc: Added brief inline comments for skipped malformed bytecode paths; formatting aligned with existing style; new custom API calls used include org.apache.bcel.generic.MethodGen(Method,String,ConstantPoolGen) and InvokeInstruction#getReferenceType(ConstantPoolGen)/#getMethodName(ConstantPoolGen)/#getArgumentTypes(ConstantPoolGen)."}