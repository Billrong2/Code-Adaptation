{
  "code": "/**\n\t * Recursively copies a file or directory from {@code sourceLocation} to {@code targetLocation}.\n\t * <p>\n\t * If the source is a directory, all children are copied recursively. The target directory\n\t * is created automatically if it does not already exist.\n\t * </p>\n\t *\n\t * @param sourceLocation the source file or directory to copy\n\t * @param targetLocation the destination file or directory\n\t * @throws java.io.IOException if an I/O error occurs or a required directory cannot be created\n\t */\n\tpublic static void copy(final java.io.File sourceLocation,\n\t\t\tfinal java.io.File targetLocation) throws java.io.IOException {\n\n\t\tif (sourceLocation.isDirectory()) {\n\t\t\tif (!targetLocation.exists() && !targetLocation.mkdirs()) {\n\t\t\t\tthrow new java.io.IOException(\"Cannot create dir \"\n\t\t\t\t\t\t+ targetLocation.getAbsolutePath());\n\t\t\t}\n\n\t\t\tString[] children = sourceLocation.list();\n\t\t\tif (children == null) {\n\t\t\t\treturn; // nothing to copy or I/O error occurred\n\t\t\t}\n\t\t\tfor (int i = 0; i < children.length; i++) {\n\t\t\t\tcopy(new java.io.File(sourceLocation, children[i]),\n\t\t\t\t\t\tnew java.io.File(targetLocation, children[i]));\n\t\t\t}\n\t\t} else {\n\t\t\t// make sure the directory we plan to store the file in exists\n\t\t\tjava.io.File directory = targetLocation.getParentFile();\n\t\t\tif (directory != null && !directory.exists() && !directory.mkdirs()) {\n\t\t\t\tthrow new java.io.IOException(\"Cannot create dir \"\n\t\t\t\t\t\t+ directory.getAbsolutePath());\n\t\t\t}\n\n\t\t\tjava.io.InputStream in = null;\n\t\t\tjava.io.OutputStream out = null;\n\t\t\ttry {\n\t\t\t\tin = new java.io.FileInputStream(sourceLocation);\n\t\t\t\tout = new java.io.FileOutputStream(targetLocation);\n\t\t\t\tcopyFromInToOut(in, out);\n\t\t\t} finally {\n\t\t\t\tif (out != null) {\n\t\t\t\t\tout.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
  "explanation": "code_hardening: Added null-check for the result of sourceLocation.list() to avoid a potential NullPointerException, ensured only the OutputStream is closed in this method, and marked parameters as final for robustness.\nresolve_compilation_errors: Renamed the method to copy, made it static, updated recursive self-calls to use copy, and replaced the inline byte-copy loop with a call to the existing helper method copyFromInToOut(InputStream, OutputStream).\nexception_handling: Preserved throws IOException in the method signature and used a try/finally block to guarantee OutputStream closure without double-closing the InputStream handled by the helper.\nlogic_customization: Replaced manual buffer-copy logic with copyFromInToOut while keeping directory creation and recursive copy behavior unchanged.\nrefactoring: Renamed the method, updated the call graph accordingly, and added Javadoc documenting recursive behavior and automatic creation of target directories.\nmisc: Reformatted and adjusted comments to reflect the helper-based copy mechanism; new custom API call used: copyFromInToOut(java.io.InputStream, java.io.OutputStream)."
}