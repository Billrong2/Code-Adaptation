package domain;

import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.Image;
import java.awt.Polygon;
import java.awt.Toolkit;
import java.awt.Transparency;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.awt.image.FilteredImageSource;
import java.awt.image.ImageFilter;
import java.awt.image.ImageProducer;
import java.awt.image.RGBImageFilter;
import java.awt.image.WritableRaster;
import java.io.IOException;
import java.net.URL;

import javax.imageio.ImageIO;

import core.VergeEngine;

import persist.PCXReader;

import static core.Script.*;

public class VImage implements Transferable {

	public BufferedImage image;
	public Graphics2D g;
	
	public int width, height;
	
	public VImage(int x, int y) {
		this.width = x;
		this.height = y;
		GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
		GraphicsDevice gs = ge.getDefaultScreenDevice();
		GraphicsConfiguration gc = gs.getDefaultConfiguration();
		image = gc.createCompatibleImage(x, y, Transparency.TRANSLUCENT);
		
		g = (Graphics2D)image.getGraphics();
	}
	
	 public VImage(URL url, boolean transparent) {
		  try {
			  if(url==null) {
				  System.err.println("Unable to find image from URL " + url);
				  return;
			  }
			  if(url.getFile().toUpperCase().endsWith("PCX")) {
				  image = PCXReader.loadImage(url.openStream());
			  } else
			  {			  
				  image = ImageIO.read(url);
			  }
		  } catch (IOException e) {
			  System.err.println("Unable to read image from URL " + url);
		  }
		  this.width = image.getWidth();
		  this.height = image.getHeight();

		  
		  if(transparent) {
			  Image img = makeColorTransparent(image, new Color(255, 0, 255));
			  this.image = imageToBufferedImage(img);
		  }
		  
		  g = (Graphics2D)image.getGraphics();
	 }
	 
	 public VImage(URL url) { 
		 this(url, true);
	 }
	
	public BufferedImage getImage() {
		return this.image;
	}
    
	public int getWidth() {
		return this.width;
	}
	public int getHeight() {
		return this.height;
	}

	
   private static BufferedImage imageToBufferedImage(Image image) {
        GraphicsConfiguration gc = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice ().getDefaultConfiguration();
        BufferedImage dst = gc.createCompatibleImage(image.getWidth(null), image.getHeight(null), Transparency.TRANSLUCENT);
        Graphics2D g2d = dst.createGraphics();
        g2d.setComposite(AlphaComposite.Src);
        
        g2d.drawImage(image,0,0,null);
        g2d.dispose();
        return dst;
    }

	   
	   public static Image makeColorTransparent(BufferedImage im, final Color color) {
	        ImageFilter filter = new RGBImageFilter() {

	                
	                public int markerRGB = color.getRGB() | 0xFF000000;

	                public final int filterRGB(int x, int y, int rgb) {
	                        if ((rgb | 0xFF000000) == markerRGB) {
	                                
	                                return 0x00FFFFFF & rgb;
	                        } else {
	                                
	                                return rgb;
	                        }
	                }
	        };

	        ImageProducer ip = new FilteredImageSource(im.getSource(), filter);
	        return Toolkit.getDefaultToolkit().createImage(ip);
	    }

			   // TODO


	   
	   
	   public void copyImageToClipboard() {
	        
	        
	        Toolkit toolkit = Toolkit.getDefaultToolkit();
	        toolkit.getSystemClipboard().setContents(this, null);
	    }
	    
	   public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException {
	        if (flavor.equals(DataFlavor.imageFlavor) == false) {
	            throw new UnsupportedFlavorException(flavor);
	        }
	        return image;
	    }
	   
	    public boolean isDataFlavorSupported(DataFlavor flavor) {
	        return flavor.equals(DataFlavor.imageFlavor);
	    }
	   
	    public DataFlavor[] getTransferDataFlavors() {
	        return new DataFlavor[] {
	            DataFlavor.imageFlavor
	        };
	    }	   

		

		
	    public void render() {
			VergeEngine.TimedProcessEntities(); 
			VergeEngine.RenderMap(this);
		}
	    
		
		
		public void alphablit(int x, int y, VImage src, VImage alpha) {
			
			
			
			this.tblit(x, y, src);
		}
		
		public void blitentityframe(int x, int y, int e, int f) {
			if (current_map==null || e<0 || e >= numentities) return;
			entity.get(e).chr.render(x, y, f, this);
		}
		
		public void blitentityframe(int x, int y, CHR chr, int f) {
			if (current_map==null) return;
			chr.render(x, y, f, this);
		}

		
		public void blitlucent(int x, int y, int lucent, VImage src) {
			int oldalpha = currentLucent;
			setlucent(lucent);
			this.blit(x, y, src);
			setlucent(oldalpha);
		}
		
		public void blitTile(int x, int y, int t) {
			if (current_map != null) {
				current_map.getTileSet().UpdateAnimations();
				current_map.getTileSet().Blit(x, y, t, this);
			}
		}

		public void blit(int x, int y, VImage src) {
			this.blit(x, y, src.image);
		}
		public void blit(int x, int y, Image src) { 
			if(currentLucent < 255) {
				Graphics2D g2d = (Graphics2D) getImage().getGraphics();
				g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, (float)(currentLucent)/255));
				g2d.drawImage(src, x, y, Color.BLACK, null);
			}
			else {
				this.g.drawImage(src, x, y, Color.BLACK, null);
			}
		}

		
		
		public void tblit(int x, int y, VImage src) {
			this.tblit(x, y, src.image);
		}
		public void tblit(int x, int y, Image src) {
			if(currentLucent < 255) {
				Graphics2D g2d = (Graphics2D) getImage().getGraphics();
				g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, (float)(currentLucent)/255));
				g2d.drawImage(src, x, y, null);
			}
			else {
				this.g.drawImage(src,x,y,null);
			}
		}
		
		
		

		public VImage duplicateImage() { 
			VImage img = new VImage(this.image.getWidth(), this.image.getHeight());
			img.g.drawImage(this.getImage(), 0, 0, null);
			return img;
		}
		
		public enum FlipType{FLIP_HORIZONTALLY, FLIP_VERTICALLY, FLIP_BOTH};
		
		public void flipBlit(int x, int y, FlipType type, VImage src) {
			

			if(type == FlipType.FLIP_HORIZONTALLY) {
				this.g.drawImage(src.image, src.getWidth()+x, y, -src.getWidth(), src.getHeight(), null);
				
			}
			else {
				System.err.println("Not supported yet!");
			}
		}
		
		public static BufferedImage flipImage(int x, int y, BufferedImage src) {
			BufferedImage flippedImage = new BufferedImage(src.getWidth(), src.getHeight(), BufferedImage.TYPE_INT_ARGB);
			for(int j=0;j<src.getHeight(); j++)
				for(int i=0;i<src.getWidth(); i++)
					flippedImage.setRGB(i, j, src.getRGB(src.getWidth()-i-1, j)); 
					
			return flippedImage;
		}
		

		
		
		
		
		

		
		
		
		
		public VImage imageShell(int x, int y, int w, int h) {
			if (w+x > this.width || y+h > this.height)
				System.err.printf(
					"ImageShell() - Bad arguments. x/y+w/h greater than original image dimensions\n\nx:%d,w:%d (%d),y:%d,h:%d (%d), orig_x:%d, orig_y:%d",
					x,w,x+w,y,h,y+h,this.width,this.height
				);

			VImage dst = new VImage(w, h);
			
			

			
			
			
			
			error("Non implemented function: imageshell");
			return dst;
		}
		
		public void line(int x1, int y1, int x2, int y2, Color c) { 
			this.g.setColor(new Color(c.getRed(), c.getGreen(), c.getBlue(), currentLucent));
			this.g.drawLine(x1, y1, x2, y2);
		}
	
		
		
		public void rotscale(int x, int y, int angle, int scale, VImage src) {
			
			this.blit(x, y, src);
			
		}
		public void scaleblit(int x, int y, int dw, int dh, VImage src) {
			
			
			this.g.drawImage(src.getImage(), x, y, x+dw, y+dh, 0, 0, src.getWidth(), src.getHeight(), null);
		}
		
		
		public void scalesprite(int x, int y, int iw, int ih, int dw, int dh) {
			screen.g.drawImage(this.getImage(), x, y, x+dw, y+dh, 0, 0, iw, ih, null);
		}
		
		
		public void setClip(int x1, int y1, int x2, int y2) {
			
			
			
		}

		public void silhouette(int x, int y, Color c, VImage src) {
			int x1,x2,y1,y2;
			
			
			x1 = y1 = 0;
			x2 = src.width;
			y2 = src.height;

			for (int j=y1; j<y2; j++)
			{
				for(int i=x1;i<x2;i++) {
					if(src.getImage().getRGB(i, j)==transcolor || src.getImage().getRGB(i, j)==0) 
						this.setPixel(x+i, y+j, new Color(0,0,0,0));
					else
						this.setPixel(x+i, y+j, c);
				}
			}		
		}
		
		
		public void grabRegion(int sx1, int sy1, int sx2, int sy2, int dx, int dy, VImage src) {
			this.grabRegion(sx1, sy1, sx2, sy2, dx, dy, src.image);
		}
		
		public void grabRegion(int sx1, int sy1, int sx2, int sy2, int dx, int dy, BufferedImage src) {
			
				
				
				
				
				
			
				if (sx1>sx2) { 
					int temp = sx1;
					sx1 = sx2;
					sx2 = temp;
				}
				if (sy1>sy2) { 
					int temp = sy1;
					sy1 = sy2;
					sy2 = temp;				
				}
				
				Color color = null;
				for(int j=0; j<sy2-sy1; j++)
				for(int i=0; i<sx2-sx1; i++) {
					if(sx1+i >= src.getWidth() || sy1+j >= src.getHeight()
					   || dx+i >= this.getWidth() || dy+j >= this.getHeight())		
						break;
					color = new Color(src.getRGB(sx1+i, sy1+j));
					if(color.getRed() + color.getGreen() + color.getBlue() == 0) 
						color = new Color(0,0,0,0); 
					this.setPixel(i+dx, j+dy, color);

				}
				
		}

		public void tgrabRegion(int sx1, int sy1, int sx2, int sy2, int dx, int dy, Color transC, VImage src) {
			this.tgrabRegion(sx1, sy1, sx2, sy2, dx, dy, transC, src.image);
		}	
		
		public void tgrabRegion(int sx1, int sy1, int sx2, int sy2, int dx, int dy, Color transC, BufferedImage src) {
			
			if (sx1>sx2) { 
				int temp = sx1;
				sx1 = sx2;
				sx2 = temp;
			}
			if (sy1>sy2) { 
				int temp = sy1;
				sy1 = sy2;
				sy2 = temp;				
			}
			
			Color color = null;
			for(int j=0; j<sy2-sy1; j++)
			for(int i=0; i<sx2-sx1; i++) {
				if(sx1+i >= src.getWidth() || sy1+j >= src.getHeight()
				   || dx+i >= this.getWidth() || dy+j >= this.getHeight())		
					break;
				color = new Color(src.getRGB(sx1+i, sy1+j));
				if(color.equals(transC)) 
					color = new Color(255,0,255,0); 
				this.setPixel(i+dx, j+dy, color);

			}	
		}
	
		public void setPixel(int x, int y, Color color) {
			this.image.setRGB(x, y, color.getRGB());
		}	
		
		public int readPixel(int x, int y) {
			if(this.image != null) {
				return this.image.getRGB(x, y);
			}
			return 0;
		}
		
		public void changeColor(Color src, Color dest) {
			for(int y=0;y<height;y++) {
				for(int x=0;x<width;x++) {
					if(readPixel(x, y) == src.getRGB()) {
						setPixel(x, y, dest);
					}
				}
			}
		}
		
		
		
		public void tblitLucent(int x, int y, int lucent, VImage src) {
			int oldalpha = currentLucent;
			setlucent(lucent);
			this.tblit(x, y, src);
			setlucent(oldalpha);
		}

		public void tblitTile(int x, int y, int t) {
			if (current_map!=null) 
				current_map.getTileSet().TBlit(x, y, t, this);
		}
		

		public void rect(int x1, int y1, int x2, int y2, int c) {
			this.rect(x1, y1, x2, y2, palette.getColor(c, currentLucent));
		}
		public void rect(int x1, int y1, int x2, int y2, Color c) { 
			this.g.setColor(new Color(c.getRed(), c.getGreen(), c.getBlue(), currentLucent));
			if(x1>x2) {	int temp = x1;	x1 = x2;	x2 = temp;	} 
			if(y1>y2) {	int temp = y1;	y1 = y2;	y2 = temp;	} 
			this.g.drawRect(x1, y1, x2-x1, y2-y1);
		}

		public void rectfill(int x1, int y1, int x2, int y2, int c) {
			if(c==transcolor) {
				Graphics2D g2d = (Graphics2D) this.getImage().getGraphics();
				g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.CLEAR, 0.0f));
				g2d.setColor(new Color(0, 0, 0, 0));
				g2d.fillRect(x1, y1, x2, y2);			
				g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER));
			}
			else
				this.rectfill(x1, y1, x2, y2, palette.getColor(c, currentLucent));
		}
		
		public void rectfill(int x1, int y1, int x2, int y2, Color c) { 
			if(c.getAlpha()==255)
				c = new Color(c.getRed(), c.getGreen(), c.getBlue(), currentLucent);

			this.g.setColor(c);
			if(x1>x2) {	int temp = x1;	x1 = x2;	x2 = temp;	} 
			if(y1>y2) {	int temp = y1;	y1 = y2;	y2 = temp;	} 
			this.g.fillRect(x1, y1, x2-x1, y2-y1);
		}
		
		
		public void circle(int x1, int y1, int xr, int yr, Color c, VImage dst) { 
			dst.g.setColor(new Color(c.getRed(), c.getGreen(), c.getBlue(), currentLucent));
			dst.g.drawOval(x1-xr, y1-yr, xr*2, yr*2);
		}

		public void circlefill(int x1, int y1, int xr, int yr, int c) {
			if(c==transcolor) {
				Graphics2D g2d = (Graphics2D) this.getImage().getGraphics();
				g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.CLEAR, 0.0f));
				g2d.setColor(new Color(0, 0, 0, 0));
				g2d.fillOval(x1-xr, y1-yr, xr*2, yr*2);			
				g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER));
			}
			else {
				circlefill(x1, y1, xr, yr, palette.getColor(c, currentLucent));
			}
		}

		public void circlefill(int x1, int y1, int xr, int yr, Color c) { 
			if(c.getAlpha()==255)
				c = new Color(c.getRed(), c.getGreen(), c.getBlue(), currentLucent);
			
			this.g.setColor(c);
			this.g.fillOval(x1-xr, y1-yr, xr*2, yr*2);
		}
		
		
		public void triangle(int x1, int y1, int x2, int y2, int x3, int y3, Color c) { 
			Polygon p = new Polygon();
			p.addPoint(x1, y1);
			p.addPoint(x2, y2);
			p.addPoint(x3, y3);
			this.g.setColor(c);
			this.g.fillPolygon(p);
		}
		
		
		public void tscaleblit(int x, int y, int dw, int dh, VImage src) {
			
			this.tblit(x, y, src); 
			
		}
		public void twrapBlit(int x, int y, VImage src) {
			
			
			error("Non implemented function: twrapblit");
		}
		public void wrapBlit(int x, int y, VImage src) {
			
			
			error("Non implemented function: wrapblit");
		}

		public void printString(int x, int y, Font font, String text) {
			this.g.setFont(font);
			this.g.setColor(Color.WHITE);
			this.g.drawString(text, x, y);
		}

		
		public void fadeOut(int delay, boolean rendermap) {
			timer = 0;	
			while (timer<delay)
			{
				if(rendermap)
					this.render();
				setlucent(100 - (timer*100/delay));
				this.paintBlack();
				setlucent(0);	
				showpage();
			}
		}
		
		public void fadeIn(int delay, boolean rendermap) {
			timer = 0;
			while (timer<delay)
			{
				if(rendermap)
					this.render();
				setlucent(timer*100/delay);
				this.paintBlack();
				setlucent(0);
				showpage();
			}
		}
		
		
		public void fade(int delay, boolean black) { 
			if(black) {
				fadeOut(delay, true);
				this.paintBlack();
				fadeIn(delay, false);
			}
			else {
				fadeOut(delay, false);
				fadeIn(delay, true);
			}
			
		}

		public void paintBlack() {
			this.rectfill(0, 0, this.width, this.height, Color.BLACK);
		}
		
		
		
}
