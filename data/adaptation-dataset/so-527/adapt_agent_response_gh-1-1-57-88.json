{
  "code": "@Override\npublic boolean onTouchEvent(MotionEvent ev) {\n    if (ev == null) {\n        return false;\n    }\n\n    final int action = ev.getAction();\n\n    if (action == MotionEvent.ACTION_CANCEL) {\n        final int pointerCount = MotionEventCompat.getPointerCount(ev);\n        final int actionIndex = MotionEventCompat.getActionIndex(ev);\n\n        if (actionIndex < 0 || actionIndex >= pointerCount) {\n            // Inconsistent pointer state, consume to avoid crash\n            mActivePointerId = -1;\n            return true;\n        }\n\n        mActivePointerId = MotionEventCompat.getPointerId(ev, actionIndex);\n        final int index = MotionEventCompat.findPointerIndex(ev, mActivePointerId);\n\n        if (index > -1 && index < pointerCount) {\n            try {\n                return super.onTouchEvent(ev);\n            } catch (Exception e) {\n                Crashlytics.logException(e);\n                return true;\n            }\n        } else {\n            // Invalid pointer index during cancel, consume safely\n            mActivePointerId = -1;\n            return true;\n        }\n    } else if (action == MotionEventCompat.ACTION_POINTER_DOWN && super.onTouchEvent(ev)) {\n        final int index = MotionEventCompat.getActionIndex(ev);\n        if (index > -1 && index < MotionEventCompat.getPointerCount(ev)) {\n            mActivePointerId = MotionEventCompat.getPointerId(ev, index);\n        }\n        return false;\n    } else if (action == MotionEventCompat.ACTION_POINTER_UP && super.onTouchEvent(ev)) {\n        onSecondaryPointerUp(ev);\n        return false;\n    } else if (action == MotionEvent.ACTION_DOWN && super.onTouchEvent(ev)) {\n        if (MotionEventCompat.getPointerCount(ev) > 0) {\n            mActivePointerId = MotionEventCompat.getPointerId(ev, 0);\n        }\n        return false;\n    }\n\n    return super.onTouchEvent(ev);\n}",
  "explanation": "code_hardening: Added null checks for the MotionEvent, validated pointer indices and counts for all relevant actions, safely reset mActivePointerId on cancel, and consumed events when inconsistent pointer state is detected to avoid crashes.\nresolve_compilation_errors: Switched the override from onInterceptTouchEvent to onTouchEvent and replaced all super.onInterceptTouchEvent calls with super.onTouchEvent; reused existing MotionEvent, MotionEventCompat, and Crashlytics types from the project context.\nexception_handling: Wrapped the super.onTouchEvent(ev) call inside ACTION_CANCEL handling with a try/catch, caught generic Exception, logged it via com.crashlytics.android.Crashlytics.logException, and returned true to consume the event on failure.\nlogic_customization: Preserved existing pointer and activePointerId logic for ACTION_POINTER_DOWN, ACTION_POINTER_UP, ACTION_DOWN, and ACTION_CANCEL; maintained return behaviors (false after pointer handling, true on invalid pointer during cancel) and ensured semantics align with touch handling rather than interception.\nrefactoring: Minor local variable clarifications and early returns were applied within the function to improve readability without altering external behavior.\nmisc: Updated behavior implicitly reflects touch handling semantics and keeps the final fallback delegation to super.onTouchEvent; no additional custom APIs beyond Crashlytics were introduced."
}