{
  "code": "@Override\npublic void onMeasure(RecyclerView.Recycler recycler, RecyclerView.State state,\n                      int widthSpec, int heightSpec) {\n  // Guard clauses\n  if (recycler == null || state == null || getItemCount() == 0) {\n    super.onMeasure(recycler, state, widthSpec, heightSpec);\n    return;\n  }\n\n  final int widthMode = View.MeasureSpec.getMode(widthSpec);\n  final int heightMode = View.MeasureSpec.getMode(heightSpec);\n  final int widthSize = View.MeasureSpec.getSize(widthSpec);\n  final int heightSize = View.MeasureSpec.getSize(heightSpec);\n\n  int totalWidth = 0;\n  int totalHeight = 0;\n\n  final boolean isHorizontal = getOrientation() == HORIZONTAL;\n\n  for (int i = 0; i < getItemCount(); i++) {\n    measureScrapChild(recycler, i,\n        View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED),\n        View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED),\n        measuredDimension);\n\n    int childWidth = Math.max(0, measuredDimension[0]);\n    int childHeight = Math.max(0, measuredDimension[1]);\n\n    if (isHorizontal) {\n      totalWidth += childWidth;\n      if (i == 0) {\n        totalHeight = childHeight;\n      }\n    } else {\n      totalHeight += childHeight;\n      if (i == 0) {\n        totalWidth = childWidth;\n      }\n    }\n\n    // Early exit if content already exceeds available space\n    if ((widthSize > 0 && totalWidth > widthSize)\n        || (heightSize > 0 && totalHeight > heightSize)) {\n      super.onMeasure(recycler, state, widthSpec, heightSpec);\n      return;\n    }\n  }\n\n  int measuredWidth = totalWidth;\n  int measuredHeight = totalHeight;\n\n  // Honor EXACTLY modes\n  if (widthMode == View.MeasureSpec.EXACTLY) {\n    measuredWidth = widthSize;\n  }\n  if (heightMode == View.MeasureSpec.EXACTLY) {\n    measuredHeight = heightSize;\n  }\n\n  setMeasuredDimension(measuredWidth, measuredHeight);\n}",
  "explanation": "code_hardening: Added guards for null recycler/state and empty item count, prevented negative child dimensions with Math.max, and early-exited when aggregated content exceeds available size.\nresolve_compilation_errors: Used the existing measuredDimension field, matched the local measureScrapChild signature, and delegated via super.onMeasure which is accessible from RecyclerView.LayoutManager.\nexception_handling: none.\nlogic_customization: Aggregated content width/height by orientation, compared against measure spec sizes, applied custom wrap-content sizing only when both dimensions fit, otherwise delegated to super.onMeasure to preserve scrollability, and honored EXACTLY modes by overriding calculated dimensions.\nrefactoring: Replaced mMeasuredDimension usage with measuredDimension, reduced duplicated orientation checks with an isHorizontal flag, and clarified accumulation logic.\nmisc: none."
}