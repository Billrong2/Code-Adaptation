

package pixy.util;

import java.util.Arrays;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.lang.reflect.Array;
import java.nio.ByteOrder;
import java.util.AbstractList;
import java.nio.ByteBuffer;
import java.nio.DoubleBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import java.nio.ShortBuffer;


public class ArrayUtils 
{
	
	private static final int[] MASK = { 0x000,
					    0x1, 0x3, 0x7, 0xf,
					    0x1f, 0x3f, 0x7f, 0xff,
					    0x1ff, 0x3ff, 0x7ff, 0xfff,
				        0x1fff, 0x3fff, 0x7fff, 0xffff,
				        0x1ffff, 0x3ffff, 0x7ffff, 0xfffff,
				        0x1fffff, 0x3fffff, 0x7fffff, 0xffffff,
				        0x1ffffff, 0x3ffffff, 0x7ffffff, 0xfffffff,
				        0x1fffffff, 0x3fffffff, 0x7fffffff, 0xffffffff 
					};
	
	
	private static final byte[] BIT_REVERSE_TABLE =	{
	   (byte)0x00, (byte)0x80, (byte)0x40, (byte)0xc0, (byte)0x20, (byte)0xa0, (byte)0x60, (byte)0xe0,
	   (byte)0x10, (byte)0x90, (byte)0x50, (byte)0xd0, (byte)0x30, (byte)0xb0, (byte)0x70, (byte)0xf0,
	   (byte)0x08, (byte)0x88, (byte)0x48, (byte)0xc8, (byte)0x28, (byte)0xa8, (byte)0x68, (byte)0xe8,
	   (byte)0x18, (byte)0x98, (byte)0x58, (byte)0xd8, (byte)0x38, (byte)0xb8, (byte)0x78, (byte)0xf8,
	   (byte)0x04, (byte)0x84, (byte)0x44, (byte)0xc4, (byte)0x24, (byte)0xa4, (byte)0x64, (byte)0xe4,
	   (byte)0x14, (byte)0x94, (byte)0x54, (byte)0xd4, (byte)0x34, (byte)0xb4, (byte)0x74, (byte)0xf4,
	   (byte)0x0c, (byte)0x8c, (byte)0x4c, (byte)0xcc, (byte)0x2c, (byte)0xac, (byte)0x6c, (byte)0xec,
	   (byte)0x1c, (byte)0x9c, (byte)0x5c, (byte)0xdc, (byte)0x3c, (byte)0xbc, (byte)0x7c, (byte)0xfc,
	   (byte)0x02, (byte)0x82, (byte)0x42, (byte)0xc2, (byte)0x22, (byte)0xa2, (byte)0x62, (byte)0xe2,
	   (byte)0x12, (byte)0x92, (byte)0x52, (byte)0xd2, (byte)0x32, (byte)0xb2, (byte)0x72, (byte)0xf2,
	   (byte)0x0a, (byte)0x8a, (byte)0x4a, (byte)0xca, (byte)0x2a, (byte)0xaa, (byte)0x6a, (byte)0xea,
	   (byte)0x1a, (byte)0x9a, (byte)0x5a, (byte)0xda, (byte)0x3a, (byte)0xba, (byte)0x7a, (byte)0xfa,
	   (byte)0x06, (byte)0x86, (byte)0x46, (byte)0xc6, (byte)0x26, (byte)0xa6, (byte)0x66, (byte)0xe6,
	   (byte)0x16, (byte)0x96, (byte)0x56, (byte)0xd6, (byte)0x36, (byte)0xb6, (byte)0x76, (byte)0xf6,
	   (byte)0x0e, (byte)0x8e, (byte)0x4e, (byte)0xce, (byte)0x2e, (byte)0xae, (byte)0x6e, (byte)0xee,
	   (byte)0x1e, (byte)0x9e, (byte)0x5e, (byte)0xde, (byte)0x3e, (byte)0xbe, (byte)0x7e, (byte)0xfe,
	   (byte)0x01, (byte)0x81, (byte)0x41, (byte)0xc1, (byte)0x21, (byte)0xa1, (byte)0x61, (byte)0xe1,
	   (byte)0x11, (byte)0x91, (byte)0x51, (byte)0xd1, (byte)0x31, (byte)0xb1, (byte)0x71, (byte)0xf1,
	   (byte)0x09, (byte)0x89, (byte)0x49, (byte)0xc9, (byte)0x29, (byte)0xa9, (byte)0x69, (byte)0xe9,
	   (byte)0x19, (byte)0x99, (byte)0x59, (byte)0xd9, (byte)0x39, (byte)0xb9, (byte)0x79, (byte)0xf9,
	   (byte)0x05, (byte)0x85, (byte)0x45, (byte)0xc5, (byte)0x25, (byte)0xa5, (byte)0x65, (byte)0xe5,
	   (byte)0x15, (byte)0x95, (byte)0x55, (byte)0xd5, (byte)0x35, (byte)0xb5, (byte)0x75, (byte)0xf5,
	   (byte)0x0d, (byte)0x8d, (byte)0x4d, (byte)0xcd, (byte)0x2d, (byte)0xad, (byte)0x6d, (byte)0xed,
	   (byte)0x1d, (byte)0x9d, (byte)0x5d, (byte)0xdd, (byte)0x3d, (byte)0xbd, (byte)0x7d, (byte)0xfd,
	   (byte)0x03, (byte)0x83, (byte)0x43, (byte)0xc3, (byte)0x23, (byte)0xa3, (byte)0x63, (byte)0xe3,
	   (byte)0x13, (byte)0x93, (byte)0x53, (byte)0xd3, (byte)0x33, (byte)0xb3, (byte)0x73, (byte)0xf3,
	   (byte)0x0b, (byte)0x8b, (byte)0x4b, (byte)0xcb, (byte)0x2b, (byte)0xab, (byte)0x6b, (byte)0xeb,
	   (byte)0x1b, (byte)0x9b, (byte)0x5b, (byte)0xdb, (byte)0x3b, (byte)0xbb, (byte)0x7b, (byte)0xfb,
	   (byte)0x07, (byte)0x87, (byte)0x47, (byte)0xc7, (byte)0x27, (byte)0xa7, (byte)0x67, (byte)0xe7,
	   (byte)0x17, (byte)0x97, (byte)0x57, (byte)0xd7, (byte)0x37, (byte)0xb7, (byte)0x77, (byte)0xf7,
	   (byte)0x0f, (byte)0x8f, (byte)0x4f, (byte)0xcf, (byte)0x2f, (byte)0xaf, (byte)0x6f, (byte)0xef,
	   (byte)0x1f, (byte)0x9f, (byte)0x5f, (byte)0xdf, (byte)0x3f, (byte)0xbf, (byte)0x7f, (byte)0xff
	};
	
	
   	public static List<Integer> asList(final int[] a) 
   	{
   		if (a == null)
   			throw new NullPointerException();
   		return new AbstractList<Integer>() {
   			public Integer get(int i) {
   				return a[i]; 
   			}
   			
   			@Override public Integer set(int i, Integer val) {
   				int oldVal = a[i];
   				a[i] = val; 
   				return oldVal;
   			}
   			public int size() {
   				return a.length;
   			}
   		};
   	}
	
	public static void bubbleSort(int[] array) {
	    int n = array.length;
	    boolean doMore = true;
	    
	    while (doMore) {
	        n--;
	        doMore = false;  
	    
	        for (int i=0; i < n; i++) {
	            if (array[i] > array[i+1]) {
	                
	                int temp = array[i];
	                array[i] = array[i+1];
	                array[i+1] = temp;
	                doMore = true;  
	            }
	        }
	    }
	}
	
	public static <T extends Comparable<? super T>> void bubbleSort(T[] array) {
	    int n = array.length;
	    boolean doMore = true;
	    
	    while (doMore) {
	        n--;
	        doMore = false;  
	    
	        for (int i = 0; i < n; i++) {
	            if (array[i].compareTo(array[i+1]) > 0) {
	                
	                T temp = array[i];
	                array[i] = array[i+1];
	                array[i+1] = temp;
	                doMore = true;  
	            }
	        }
	    }
	}
	
	
    public static <T> boolean checkDuplicate(T[] input) {
        Set<T> tempSet = new HashSet<T>();
        
        for (T str : input) {
            if (!tempSet.add(str)) {
                return true;
            }
        }
        
        return false;
    }
	
	public static byte[] concat(byte[] first, byte[]... rest) {
  	 	if(first == null) {
			throw new IllegalArgumentException("Firt element is null");
		}
  	 	if(rest.length == 0) return first;
		
  	  	int totalLength = first.length;
	  
		for (byte[] array : rest) {		
			totalLength += array.length;
	 	}
		
		byte[] result = new byte[totalLength];
	  
		int offset = first.length;
		
		System.arraycopy(first, 0, result, 0, offset);
	
		for (byte[] array : rest) {
			System.arraycopy(array, 0, result, offset, array.length);
			offset += array.length;
		}
		
		return result;
	}
	
	
	public static <T> T[] concat(T[]... arrays) {
		if(arrays.length == 0)
			throw new IllegalArgumentException("Varargs length is zero");
		
		if(arrays.length == 1) return arrays[0];
		
		
		int totalLength = 0;
		
		Class<?> returnType = arrays.getClass().getComponentType().getComponentType();
		
		for (T[] array : arrays)	
			totalLength += array.length;
		
		@SuppressWarnings("unchecked")
		T[] result = (T[]) Array.newInstance(returnType, totalLength);
	 
		int offset = 0;
		for (T[] array : arrays) {
			System.arraycopy(array, 0, result, offset, array.length);
			offset += array.length;
		}
		
		return result;
	}
	
	
	public static <T> T[] concat(Class<T> type, T[]... arrays) {
		if(type == null) 
			throw new IllegalArgumentException("Input type class is null");
		
		if(arrays.length == 0) { 
			@SuppressWarnings("unchecked")
			T[] result = (T[]) Array.newInstance(type, 0);
			
			return result;
		}
		
		
		if(arrays.length == 1) return arrays[0];
		
		int totalLength = 0;	  
		for (T[] array : arrays)	
			totalLength += array.length;
		
		@SuppressWarnings("unchecked")
		T[] result = (T[]) Array.newInstance(type, totalLength);
	  
		int offset = 0;
		for (T[] array : arrays) {
			System.arraycopy(array, 0, result, offset, array.length);
			offset += array.length;
		}
		
		return result;
	}

	public static int findEqualOrLess(int[] a, int key) {
    	return findEqualOrLess(a, 0, a.length, key);
    }
	
	
    
    public static int findEqualOrLess(int[] a, int fromIndex, int toIndex, int key) {
    	int index = Arrays.binarySearch(a, fromIndex, toIndex, key);
    	
    	
    	if(index < 0) {
    		index = -index - 1 - 1;
    	}
    	
    	
    	return index;    	
    }
	
	public static <T> int findEqualOrLess(T[] a, int fromIndex, int toIndex, T key, Comparator<? super T> c) {
    	int index = Arrays.binarySearch(a, fromIndex, toIndex, key, c);
    	
    	
    	if(index < 0) {
    		index = -index - 1 - 1;
    	}
    	
    	return index;    	
    }
	
	public static <T> int findEqualOrLess(T[] a, T key, Comparator<? super T> c) {
    	return findEqualOrLess(a, 0, a.length, key, c);
    }
	
	     
   	public static byte[] flipEndian(byte[] input, int offset, int len, int bits, int scanLineStride, boolean bigEndian) {
   		long value = 0;
   		int bits_remain = 0;
   		long temp_byte = 0; 
   		int empty_bits = 8;
   		
   		byte[] output = new byte[input.length];
   		
   		int strideCounter = 0;
   		
   		int end = offset + len;
   		int bufIndex = 0;
    	 
   		int temp = bits;
    	boolean bigEndianOut = !bigEndian;
    	
   	  	loop:
   	  	while(true) {  			
   	   		
			if(!bigEndian)
				value = (temp_byte >> (8-bits_remain));
			else				
				value = (temp_byte & MASK[bits_remain]); 
				
			while (bits > bits_remain)
			{
				if(offset >= end) {
					break loop;
				}
				
				temp_byte = input[offset++]&0xff;
				
				if(bigEndian)
					value = ((value<<8)|temp_byte);
				else
					value |= (temp_byte<<bits_remain);
				
				bits_remain += 8;
			}
			
			bits_remain -= bits;
			
			if(bigEndian)
				value = (value>>bits_remain);		
	        
		  	
	    	if(bigEndianOut) {
	    		temp = bits-empty_bits;
	    		output[bufIndex] |= ((value>>temp)&MASK[empty_bits]);
	    		
	    		while(temp > 8)
				{
					output[++bufIndex] |= ((value>>(temp-8))&MASK[8]);
					temp -= 8;
				} 
	    		
	    		if(temp > 0) {
	    			output[++bufIndex] |= ((value&MASK[temp])<<(8-temp));
	    			temp -= 8;
	    		}
	       	} else { 
	       		temp = bits;
				output[bufIndex] |= ((value&MASK[empty_bits])<<(8-empty_bits));
				value >>= empty_bits;
		        temp -= empty_bits;
		        
				while(temp > 8) {
					output[++bufIndex] |= (value&0xff);
					value >>= 8;
					temp -= 8;
				}
				
		        if(temp > 0)
				{
		        	output[++bufIndex] |= (value&MASK[temp]);
	    			temp -= 8;
				}
			}
	    	
	    	empty_bits = -temp;
			
	    	if(++strideCounter%scanLineStride == 0) {
				empty_bits = 0;
				bits_remain = 0;	
			}			
   	  	}
   		
		return output;
	}
	
	
   	
   	public static int fromFloat(float fval)
   	{
   	    int fbits = Float.floatToIntBits(fval);
   	    int sign = fbits >>> 16 & 0x8000; 
   	    int val = (fbits & 0x7fffffff) + 0x1000; 

   	    if(val >= 0x47800000) 
   	    {                     
   	        if( (fbits & 0x7fffffff) >= 0x47800000)
   	        {                        
   	            if(val < 0x7f800000) 
   	                return sign | 0x7c00;  
   	            return sign | 0x7c00 |  
   	                (fbits & 0x007fffff) >>> 13; 
   	        }
   	        return sign | 0x7bff;  
   	    }
   	    if(val >= 0x38800000)  
   	        return sign | val - 0x38000000 >>> 13; 
   	    if(val < 0x33000000) 
   	        return sign;     
   	    val = (fbits & 0x7fffffff) >>> 23;  
   	    return sign | ((fbits & 0x7fffff | 0x800000) 
   	         + (0x800000 >>> val - 102) 
   	      >>> 126 - val); 
   	}
	
	
  	public static byte[] getBitReverseTable() {
  		return BIT_REVERSE_TABLE.clone();
  	}
	 
	
    public static void insertionsort(int[] array) {
	   insertionsort(array, 0, array.length - 1);
    }

	public static void insertionsort(int[] array, int start, int end) {
	   int j;

	   for (int i = start + 1; i < end + 1; i++)
	   {
		   
		   int temp = array[i];
		   for ( j = i; j > start && temp <= array[j-1]; j-- )
		       array[j] = array[j-1];
		   
		   array[j] = temp;
	   }
    }
	
	
    public static <T extends Comparable<? super T>> void insertionsort(T[] array) {
    	insertionsort(array, 0, array.length - 1);
    }
    
	
    public static <T extends Comparable<? super T>> void insertionsort(T[] array, int start, int end) {
	   int j;

	   for (int i = start + 1; i < end + 1; i++)
	   {
		   T temp = array[i];
		   for ( j = i; j > start && temp.compareTo(array[j-1]) <= 0; j-- )
		       array[j] = array[j-1];
		   
		   array[j] = temp;
	   }
    }
    
    
    public static void mergesort(int[] array) { 
	   mergesort(array, new int[array.length], 0, array.length - 1);
    }
    
    public static void mergesort(int[] array, int left, int right) {
    	if(left < 0 || right > array.length - 1) throw new IllegalArgumentException("Array index out of bounds");
        mergesort(array, new int[array.length], left, right);
    }
    
    private static void mergesort(int[] array, int[] temp, int left, int right) {
    	
        if (left < right) {
          
          int middle = left + (right - left) / 2;
          
          mergesort(array, temp, left, middle);
          
          mergesort(array, temp, middle + 1, right);
          
          merge(array, temp, left, middle, right);
        }
    }
    
    public static <T extends Comparable<? super T>> void mergesort(T[] array) {
    	mergesort(array, 0, array.length - 1);
    }
    
    public static <T extends Comparable<? super T>> void mergesort(T[] array, int left, int right) {
     	if(left < 0 || right > array.length - 1) throw new IllegalArgumentException("Array index out of bounds");
        @SuppressWarnings("unchecked")
		T[] temp = (T[]) Array.newInstance(array.getClass().getComponentType(), array.length);
    	mergesort(array, temp, left, right);
    }
    
    
    private static <T extends Comparable<? super T>> void mergesort(T[] array, T[] temp, int left, int right) {
    	
        if (left < right) {
          
          int middle = left + (right - left) / 2;
          
          mergesort(array, temp, left, middle);
          
          mergesort(array, temp, middle + 1, right);
          
          merge(array, temp, left, middle, right);
        }
    }   
    
    private static <T extends Comparable<? super T>> void merge(T[] array, T[] temp, int left, int middle, int right) {
    	
        for (int i = left; i <= right; i++) {
          temp[i] = array[i];
        }
        int i = left;
        int j = middle + 1;
        int k = left;
        while (i <= middle && j <= right) {
            if (temp[i].compareTo(temp[j]) <= 0) {
                array[k] = temp[i];
                i++;
            } else {
                array[k] = temp[j];
                j++;
            }
            k++;
        }
        while (i <= middle) {
            array[k] = temp[i];
            k++;
            i++;
        }        
    }
    
    private static void merge(int[] array, int[] temp, int left, int middle, int right) {
    	
        for (int i = left; i <= right; i++) {
          temp[i] = array[i];
        }
        int i = left;
        int j = middle + 1;
        int k = left;
        while (i <= middle && j <= right) {
            if (temp[i] <= temp[j]) {
                array[k] = temp[i];
                i++;
            } else {
                array[k] = temp[j];
                j++;
            }
            k++;
        }
        while (i <= middle) {
            array[k] = temp[i];
            k++;
            i++;
        }        
    }
    
	
	public static byte[] packByteArray(byte[] input, int start, int bits, int len) {
		
		if(bits == 8) return ArrayUtils.subArray(input, start, len);
		if(bits > 8 || bits <= 0) throw new IllegalArgumentException("Invalid value of bits: " + bits);
		
		byte[] packedBytes = new byte[(bits*len + 7)>>3];
		short mask[] = {0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff};
	    	
		int index = 0;
		int empty_bits = 8;
		int end = start + len;
		
		for(int i = start; i < end; i++) {
			
			if(empty_bits >= bits) {
				packedBytes[index] |= ((input[i]&mask[bits])<<(empty_bits-bits));
				empty_bits -= bits;				
				if(empty_bits == 0) {
					index++;
					empty_bits = 8;
				}
			} else { 
				packedBytes[index++] |= ((input[i]>>(bits-empty_bits))&mask[empty_bits]);
				packedBytes[index] |= ((input[i]&mask[bits-empty_bits])<<(8-bits+empty_bits));
				empty_bits += (8-bits);
			}
		}
		
		return packedBytes;
	}

   	
	public static byte[] packByteArray(byte[] input, int stride, int start, int bits, int len) {
		
		if(bits == 8) return ArrayUtils.subArray(input, start, len);
		if(bits > 8 || bits <= 0) throw new IllegalArgumentException("Invalid value of bits: " + bits);
		
		int bitsPerStride = bits*stride;
		int numOfStrides = len/stride;
		byte[] packedBytes = new byte[((bitsPerStride + 7)>>3)*numOfStrides];
		short mask[] = {0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff};
	    	
		int index = 0;
		int empty_bits = 8;
		int end = start + len;
		int strideCounter = 0;
		
		for(int i = start; i < end; i++) {
			
			if(empty_bits >= bits) {
				packedBytes[index] |= ((input[i]&mask[bits])<<(empty_bits-bits));
				empty_bits -= bits;
			} else { 
				
				packedBytes[index++] |= ((input[i]>>(bits-empty_bits))&mask[empty_bits]);
				packedBytes[index] |= ((input[i]&mask[bits-empty_bits])<<(8-bits+empty_bits));
				empty_bits += (8-bits);
			}
			
			if(++strideCounter%stride == 0 || empty_bits == 0) {
				index++;
				empty_bits = 8;			
			}
		}
		
		return packedBytes;
	}
    
    
    public static void quicksort(int[] array) {
	   quicksort (array, 0, array.length - 1);
    }
    
    public static void quicksort (int[] array, int start, int end) {
	   int inner = start;
	   int outer = end;
	   int mid = (start + end) / 2;
	
	   do {
		
		
		   while ((inner < mid) && (array[inner] <= array[mid]))
			  inner++;                         
	
		
		
	
		   while ((outer > mid) && (array[outer] >= array[mid]))
			  outer--;                          
		
		
		   if (inner < mid && outer > mid) {
		      swap(array, inner, outer);
			  inner++;
			  outer--;
		   } else if (inner < mid) {
			  swap(array, inner, mid - 1);
			  swap(array, mid, mid - 1);
			  mid--;
		   } else if (outer >mid) {
			  swap(array, outer, mid + 1);
			  swap(array, mid, mid + 1);
			  mid++;		
		   }	
	   } while (inner !=outer);
	
	
	   if ((mid - 1) > start) quicksort(array, start, mid - 1);
 	   if (end > (mid + 1)) quicksort(array, mid + 1, end);
    }
    
    
    public static <T extends Comparable<? super T>> void quicksort (T[] array) {
    	quicksort(array, 0, array.length - 1);
    }
    
    
    public static <T extends Comparable<? super T>> void quicksort (T[] array, int low, int high) {
    	int i = low, j = high;
		
		T pivot = array[low + (high-low)/2];

		
		while (i <= j) {
			
			
			while (array[i].compareTo(pivot) < 0) {
				i++;
			}
			
			
			while (array[j].compareTo(pivot) > 0) {
				j--;
			}

			
			
			
			
			
			if (i <= j) {
				swap(array, i, j);
				i++;
				j--;
			}
		}
		
		if (low < j)
			quicksort(array, low, j);
		if (i < high)
			quicksort(array, i, high);
	}
    
    
    
    public static int[] removeDuplicates(int[] input) {
        
        if(input.length < 2){
            return input;
        }
      
        
        Arrays.sort(input);        
        
    	int j = 0;
        int i = 1;
              
        while(i < input.length){
            if(input[i] == input[j]){
                i++;
            } else{
                input[++j] = input[i++];
            }   
        }
        
        int[] output = new int[j + 1];
        
        System.arraycopy(input, 0, output, 0, j + 1);
        
        return output;
    }
   	
   	
	public static void reverseBits(byte[] input) {
		for(int i = input.length - 1; i >= 0; i--)
			input[i] = BIT_REVERSE_TABLE[input[i]&0xff];
	}
	
	public static byte[] reverse(byte[] array) {
		if (array == null)
			throw new IllegalArgumentException("Input array is null");
		int left = 0;
		int right = array.length - 1;
		byte tmp;
		while (left < right) {
			tmp = array[right];
			array[right] = array[left];
			array[left] = tmp;
			left++;
			right--;
		}
		
		return array;
	}

	
	public static <T> void reverse(T[] data) {
	    for (int left = 0, right = data.length - 1; left < right; left++, right--) {
	        T temp = data[left];
	        data[left]  = data[right];
	        data[right] = temp;
	    }
	}
   	
    
    public static void shellsort(int[] array) {
    	shellsort(array, 0, array.length - 1);
    }
   	
    public static void shellsort(int[] array, int start, int end) {
    	if(start < 0 || end < 0 || start > end || end > array.length -1) throw new IllegalArgumentException("Array index out of bounds");
    	int gap = 1;
    	int len = end - start + 1;
 	    
    	while(gap < len) gap = 3*gap + 1;
    	while ( gap > 0 )
    	{
    		int begin = start + gap;
    		for (int i = begin; i <= end; i++)
    		{
    			int temp = array[i];
    			int j = i;
    			while ( j >= begin && temp <= array[j - gap])
    			{
    				array[j] = array[j - gap];
    				j -= gap;
    			}
    			array[j] = temp;
    		}
    		gap /= 3;
    	}
	}
    
    
    public static <T extends Comparable<? super T>> void shellsort(T[] array) {
    	shellsort(array, 0, array.length - 1);
    }
   	
    
    public static <T extends Comparable<? super T>> void shellsort(T[] array, int start, int end) {
    	if(start < 0 || end < 0 || start > end || end > array.length - 1) throw new IllegalArgumentException("Array index out of bounds");
	   	int gap = 1;
	   	int len = end - start + 1;
  	    
	   	while(gap < len) gap = 3*gap + 1;
	   	while ( gap > 0 )
	   	{
	   		int begin = start + gap;
	   		for (int i = begin; i <= end; i++)
	   		{
	   			T temp = array[i];
	   			int j = i;
	   			while ( j >= begin && temp.compareTo(array[j - gap]) <= 0)
	   			{
	   				array[j] = array[j - gap];
	   				j -= gap;
	   			}
	   			array[j] = temp;
	   		}
	   		gap /= 3;
	   	}
    } 	

    public static byte[] subArray(byte[] src, int offset, int len) {
		if(offset == 0 && len == src.length) return src;
		if((offset < 0 || offset >= src.length) || (offset + len > src.length))
			throw new IllegalArgumentException("Copy range out of array bounds");
		byte[] dest = new byte[len];
		System.arraycopy(src, offset, dest, 0, len);
		
		return dest;
	}
    
    private static final void swap(int[] array, int a, int b) {
	   int temp = array[a];
	   array[a] = array[b];
	   array[b] = temp;
    }
    
    private static final <T> void swap(T[] array, int a, int b) {
	   T temp = array[a];
	   array[a] = array[b];
	   array[b] = temp;
    }
    
   	public static float[] to16BitFloatArray(byte[] data, boolean bigEndian) {
		short[] shorts = (short[])toNBits(16, data, Integer.MAX_VALUE, bigEndian);
		float[] floats = new float[shorts.length];
	
		for(int i = 0; i < floats.length; i++) {
			floats[i] = toFloat(shorts[i]);
		}
		
		return floats;
	}

    	
	public static float[] to24BitFloatArray(byte[] data, boolean bigEndian) {
		int[] ints = (int[])toNBits(24, data, Integer.MAX_VALUE, bigEndian);
		float[] floats = new float[ints.length];
	
		for(int i = 0; i < floats.length; i++) {
			
			floats[i] = Float.intBitsToFloat(ints[i]<<8);
		}
		
		return floats;
	}

    
	public static int[] to32BitsLongArray(byte[] data, boolean bigEndian) {
		ByteBuffer byteBuffer = ByteBuffer.wrap(data);
		
		if (bigEndian) {
			byteBuffer.order(ByteOrder.BIG_ENDIAN);
		} else {
			byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
		}
		
		LongBuffer longBuf = byteBuffer.asLongBuffer();
		long[] array = new long[longBuf.remaining()];
		longBuf.get(array);
		
		int[] iArray = new int[array.length];
		
		int i = 0;
		
		for(long l : array) {
			iArray[i++] = (int)l;
		}
		
		return iArray;
	}
    
    public static byte[] toByteArray(int value) {
		return new byte[] {
	        (byte)value,
	        (byte)(value >>> 8),
	        (byte)(value >>> 16),
	        (byte)(value >>> 24)	            		            
	        };
	}
    
    public static byte[] toByteArray(int[] data, boolean bigEndian) {
		
		ByteBuffer byteBuffer = ByteBuffer.allocate(data.length * 4);
		
		if (bigEndian) {
			byteBuffer.order(ByteOrder.BIG_ENDIAN);
		} else {
			byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
		}
        
		IntBuffer intBuffer = byteBuffer.asIntBuffer();
        intBuffer.put(data);

        byte[] array = byteBuffer.array();

		return array;
	}
    
  	public static byte[] toByteArray(long[] data, boolean bigEndian) {
		
		ByteBuffer byteBuffer = ByteBuffer.allocate(data.length * 8);
		
		if (bigEndian) {
			byteBuffer.order(ByteOrder.BIG_ENDIAN);
		} else {
			byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
		}
        
		LongBuffer longBuffer = byteBuffer.asLongBuffer();
        longBuffer.put(data);

        byte[] array = byteBuffer.array();

		return array;
	}
	
	public static byte[] toByteArray(short value) {
		 return new byte[] {
				 (byte)value, (byte)(value >>> 8)};
	}

	public static byte[] toByteArray(short[] data, boolean bigEndian) {
		
		ByteBuffer byteBuffer = ByteBuffer.allocate(data.length * 2);
		
		if (bigEndian) {
			byteBuffer.order(ByteOrder.BIG_ENDIAN);
		} else {
			byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
		}
        
		ShortBuffer shortBuffer = byteBuffer.asShortBuffer();
        shortBuffer.put(data);

        byte[] array = byteBuffer.array();

		return array;
	}
    
    public static byte[] toByteArrayMM(int value) {
    	return new byte[] {
	        (byte)(value >>> 24),
	        (byte)(value >>> 16),
	        (byte)(value >>> 8),
	        (byte)value};
	}

    public static byte[] toByteArrayMM(short value) {
		 return new byte[] {
				 (byte)(value >>> 8), (byte)value};
	}
    
    public static double[] toDoubleArray(byte[] data, boolean bigEndian) {
		return toDoubleArray(data, 0, data.length, bigEndian);
	}
	
	public static double[] toDoubleArray(byte[] data, int offset, int len, boolean bigEndian) {
		
		ByteBuffer byteBuffer = ByteBuffer.wrap(data, offset, len);
		
		if (bigEndian) {
			byteBuffer.order(ByteOrder.BIG_ENDIAN);
		} else {
			byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
		}
		
		DoubleBuffer doubleBuf = byteBuffer.asDoubleBuffer();
		double[] array = new double[doubleBuf.remaining()];
		doubleBuf.get(array);
		
		return array;
	}

    	// TODO


    public static float[] toFloatArray(byte[] data, boolean bigEndian) {
		return toFloatArray(data, 0, data.length, bigEndian);
	}

    public static float[] toFloatArray(byte[] data, int offset, int len, boolean bigEndian) {
		
		ByteBuffer byteBuffer = ByteBuffer.wrap(data, offset, len);
		
		if (bigEndian) {
			byteBuffer.order(ByteOrder.BIG_ENDIAN);
		} else {
			byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
		}
		
		FloatBuffer floatBuf = byteBuffer.asFloatBuffer();
		float[] array = new float[floatBuf.remaining()];
		floatBuf.get(array);		
		
		return array;
	}

	public static int[] toIntArray(byte[] data, boolean bigEndian) {
		return toIntArray(data, 0, data.length, bigEndian);
	}

    public static int[] toIntArray(byte[] data, int offset, int len, boolean bigEndian) {
		
		ByteBuffer byteBuffer = ByteBuffer.wrap(data, offset, len);
		
		if (bigEndian) {
			byteBuffer.order(ByteOrder.BIG_ENDIAN);
		} else {
			byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
		}
		
		IntBuffer intBuf = byteBuffer.asIntBuffer();
		int[] array = new int[intBuf.remaining()];
		intBuf.get(array);
		
		return array;
	}
	 
	public static long[] toLongArray(byte[] data, boolean bigEndian) {
		return toLongArray(data, 0, data.length, bigEndian);
	}
	
	public static long[] toLongArray(byte[] data, int offset, int len, boolean bigEndian) {
		
		ByteBuffer byteBuffer = ByteBuffer.wrap(data, offset, len);
		
		if (bigEndian) {
			byteBuffer.order(ByteOrder.BIG_ENDIAN);
		} else {
			byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
		}
		
		LongBuffer longBuf = byteBuffer.asLongBuffer();
		long[] array = new long[longBuf.remaining()];
		longBuf.get(array);
		
		return array;
	}
	
	
	public static Object toNBits(int nBits, byte[] input, int stride, boolean bigEndian) {
		int value = 0;
   		int bits_remain = 0;
   		int temp_byte = 0;
   		
   		byte[] byteOutput = null;
   		short[] shortOutput = null;
   		int[] intOutput = null;
   		Object output = null;
   		
   		int outLen = (int)((input.length*8L + nBits - 1)/nBits);
   		
   		if(nBits <= 8) {
   			byteOutput = new byte[outLen];
   			output = byteOutput;
   		} else if(nBits <= 16) {
   			shortOutput = new short[outLen];
   			output = shortOutput;
   		} else if(nBits <= 32){
   			intOutput = new int[outLen];
   			output = intOutput;   			
   		} else {
   			throw new IllegalArgumentException("nBits exceeds limit - maximum 32");
   		}
   			
   		int offset = 0;
    	int index = 0;
    	
    	int strideCounter = 0;
   		
    	loop:
   	  	while(true) {  			
   	   		
			if(!bigEndian)
				value = (temp_byte >> (8-bits_remain));
			else				
				value = (temp_byte & MASK[bits_remain]); 
				
			while (nBits > bits_remain)
			{
				if(offset >= input.length) {
					break loop;
				}
				
				temp_byte = input[offset++]&0xff;
				
				if(bigEndian)
					value = ((value<<8)|temp_byte);
				else
					value |= (temp_byte<<bits_remain);
				
				bits_remain += 8;
			}
			
			bits_remain -= nBits;
			
			if(bigEndian)
				value = (value>>(bits_remain));			
	        
			value &= MASK[nBits];
			
			if(++strideCounter%stride == 0) {
				bits_remain = 0; 
			}
		
			if(nBits <= 8) byteOutput[index++] = (byte)value;
			else if(nBits <= 16) shortOutput[index++] = (short)value;
			else intOutput[index++] = value;
	  	}
   		
		return output;
	}
	
	public static double[] toPrimitive(Double[] doubles) {
		double[] dArray = new double[doubles.length];
		int i = 0;
		
		for (double d : doubles) {
			dArray[i++] = d;
		}
		
		return dArray;
	}
	
	public static float[] toPrimitive(Float[] floats) {
		float[] fArray = new float[floats.length];
		int i = 0;
		
		for (float f : floats) {
			fArray[i++] = f;
		}
		
		return fArray;
	}
	
	public static int[] toPrimitive(Integer[] integers) {
		int[] ints = new int[integers.length];
		int i = 0;
		
		for (int n : integers) {
			ints[i++] = n;
		}
		
		return ints;
	}
	
	public static long[] toPrimitive(Long[] longs) {
		long[] lArray = new long[longs.length];
		int i = 0;
		
		for (long l : longs) {
			lArray[i++] = l;
		}
		
		return lArray;
	}
	
	public static short[] toPrimitive(Short[] shorts) {
		short[] sArray = new short[shorts.length];
		int i = 0;
		
		for (short s : shorts) {
			sArray[i++] = s;
		}
		
		return sArray;
	}
	
	public static short[] toShortArray(byte[] data, boolean bigEndian) {
		return toShortArray(data, 0, data.length, bigEndian);		
	}
	
	public static short[] toShortArray(byte[] data, int offset, int len, boolean bigEndian) {
		
		ByteBuffer byteBuffer = ByteBuffer.wrap(data, offset, len);
		
		if (bigEndian) {
			byteBuffer.order(ByteOrder.BIG_ENDIAN);
		} else {
			byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
		}
		
		ShortBuffer shortBuf = byteBuffer.asShortBuffer();
		short[] array = new short[shortBuf.remaining()];
		shortBuf.get(array);
		
		return array;
	}
   	
   	private ArrayUtils(){} 
}