{
  "code": "private static void breakManually(TextView tv, Editable editable) {\n    // Null-safe early exits\n    if (tv == null || editable == null) {\n        return;\n    }\n\n    int width = tv.getWidth() - tv.getPaddingLeft() - tv.getPaddingRight();\n    // Can't break with zero or negative width\n    if (width <= 0) {\n        return;\n    }\n\n    Paint paint = tv.getPaint();\n    final String text = editable.toString();\n    final int originalLength = text.length();\n    if (originalLength == 0) {\n        return;\n    }\n\n    // Precompute widths for the original text only\n    float[] widths = new float[originalLength];\n    paint.getTextWidths(text, widths);\n\n    float curWidth = 0.0f;\n    int lastWSPos = -1; // last whitespace position in the editable\n    int strPos = 0;     // current position in the editable\n    final char newLine = '\\n';\n    final String newLineStr = \"\\n\";\n    boolean reset = false;\n    int insertCount = 0; // number of inserted newlines so far\n\n    while (strPos < editable.length()) {\n        // Map editable position to original text index to avoid width drift\n        int originalIndex = strPos - insertCount;\n        if (originalIndex >= 0 && originalIndex < widths.length) {\n            curWidth += widths[originalIndex];\n        }\n\n        char curChar = editable.charAt(strPos);\n\n        if (curChar == newLine) {\n            reset = true;\n            lastWSPos = -1;\n        } else if (Character.isWhitespace(curChar)) {\n            lastWSPos = strPos;\n        } else if (curWidth > width) {\n            // Exceeded width: prefer breaking at whitespace, otherwise force mid-word break\n            int breakPos = (lastWSPos >= 0) ? lastWSPos : strPos;\n            editable.replace(breakPos, breakPos + 1, newLineStr);\n            insertCount++;\n            strPos = breakPos; // re-evaluate from the break position\n            lastWSPos = -1;\n            reset = true;\n        }\n\n        if (reset) {\n            curWidth = 0.0f;\n            reset = false;\n        }\n\n        strPos++;\n    }\n\n    // Only update the TextView if modifications were made\n    if (insertCount > 0) {\n        tv.setText(editable);\n    }\n}",
  "explanation": "code_hardening: Added null checks for TextView and Editable, guarded against zero or negative available width, removed the invalid boolean return by using a void-safe early return, and handled empty text safely.\nresolve_compilation_errors: Ensured the method has a void return type with no boolean returns, aligned variable usage after in-place Editable replacements so indices remain valid, and relied on existing project imports (TextView, Editable, Paint, Character).\nexception_handling: none.\nlogic_customization: Adjusted width indexing by mapping the current editable index to the original text index using an insertion counter to avoid width drift after newline insertions; expanded wrapping to force a break when the width is exceeded without prior whitespace; preserved whitespace-based wrapping while correctly resetting indices and accumulated width after newlines or insertions; maintained accumulated width reset behavior and only updated the TextView when changes occurred.\nrefactoring: Clarified variable names (strPos, lastWSPos, insertCount), isolated newline constants, and simplified control flow by consolidating break logic while keeping behavior intact.\nmisc: Updated inline comments to describe forced mid-word breaks and width-indexing behavior; formatted code consistently. New custom API calls: none."
}