{
  "code": "public static <T> T runWithTimeout(Callable<T> callable, long timeout, TimeUnit timeUnit) throws Exception {\n    final ExecutorService executor = Executors.newSingleThreadExecutor();\n    final Future<T> future = executor.submit(callable);\n    executor.shutdown(); // does not cancel the already-scheduled task\n    try {\n      return future.get(timeout, timeUnit);\n    } catch (TimeoutException e) {\n      // remove this if you do not want to cancel the job in progress\n      // or set the argument to 'false' if you do not want to interrupt the thread\n      future.cancel(true);\n      throw e;\n    } catch (ExecutionException e) {\n      Throwable cause = e.getCause();\n      if (cause instanceof Error) {\n        throw (Error) cause;\n      }\n      // Do not unwrap and rethrow Exception causes; rethrow the original ExecutionException\n      throw e;\n    }\n  }",
  "explanation": "code_hardening: none\nresolve_compilation_errors: none\nexception_handling: Modified the catch (ExecutionException e) block to only unwrap and rethrow when the cause is an Error; for all other cases, the original ExecutionException is rethrown without unwrapping.\nlogic_customization: none\nrefactoring: none\nmisc: none"
}