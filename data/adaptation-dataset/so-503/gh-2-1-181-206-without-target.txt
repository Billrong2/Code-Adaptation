
package br.com.embraer.massif.commandevaluation.client.util;

import java.io.UnsupportedEncodingException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.prefs.Preferences;





public final class WinRegistry {
    private static final String HKEY_EQUALS = "hkey=";
    public static final int HKEY_CURRENT_USER = 0x80000001;
    public static final int HKEY_LOCAL_MACHINE = 0x80000002;
    public static final int REG_SUCCESS = 0;
    public static final int REG_NOTFOUND = 2;
    public static final int REG_ACCESSDENIED = 5;

    public static final int KEY_WOW64_32KEY = 0x0200;
    public static final int KEY_WOW64_64KEY = 0x0100;

    private static final int KEY_ALL_ACCESS = 0xf003f;
    private static final int KEY_READ = 0x20019;
    private static Preferences userRoot = Preferences.userRoot();
    private static Preferences systemRoot = Preferences.systemRoot();
    private static Class<? extends Preferences> userClass = userRoot.getClass();
    private static Method regOpenKey = null;
    private static Method regCloseKey = null;
    private static Method regQueryValueEx = null;
    private static Method regEnumValue = null;
    private static Method regQueryInfoKey = null;
    private static Method regEnumKeyEx = null;
    private static Method regCreateKeyEx = null;
    private static Method regSetValueEx = null;
    private static Method regDeleteKey = null;
    private static Method regDeleteValue = null;

    static {
        try {
            regOpenKey = userClass.getDeclaredMethod("WindowsRegOpenKey", new Class[] {
                int.class,
                byte[].class,
                int.class });
            regOpenKey.setAccessible(true);
            regCloseKey = userClass.getDeclaredMethod("WindowsRegCloseKey", new Class[] { int.class });
            regCloseKey.setAccessible(true);
            regQueryValueEx = userClass.getDeclaredMethod("WindowsRegQueryValueEx", new Class[] {
                int.class,
                byte[].class });
            regQueryValueEx.setAccessible(true);
            regEnumValue = userClass.getDeclaredMethod("WindowsRegEnumValue", new Class[] {
                int.class,
                int.class,
                int.class });
            regEnumValue.setAccessible(true);
            regQueryInfoKey = userClass.getDeclaredMethod("WindowsRegQueryInfoKey1", new Class[] { int.class });
            regQueryInfoKey.setAccessible(true);
            regEnumKeyEx = userClass.getDeclaredMethod("WindowsRegEnumKeyEx", new Class[] {
                int.class,
                int.class,
                int.class });
            regEnumKeyEx.setAccessible(true);
            regCreateKeyEx = userClass.getDeclaredMethod("WindowsRegCreateKeyEx",
                new Class[] { int.class, byte[].class });
            regCreateKeyEx.setAccessible(true);
            regSetValueEx = userClass.getDeclaredMethod("WindowsRegSetValueEx", new Class[] {
                int.class,
                byte[].class,
                byte[].class });
            regSetValueEx.setAccessible(true);
            regDeleteValue = userClass.getDeclaredMethod("WindowsRegDeleteValue",
                new Class[] { int.class, byte[].class });
            regDeleteValue.setAccessible(true);
            regDeleteKey = userClass.getDeclaredMethod("WindowsRegDeleteKey", new Class[] { int.class, byte[].class });
            regDeleteKey.setAccessible(true);
        } catch (SecurityException e) {
            throw new IllegalStateException("Could not initialize WinRegistry", e);
        } catch (NoSuchMethodException e) {
            throw new IllegalStateException("Could not initialize WinRegistry", e);
        }
    }

    private WinRegistry() {
    }

    
    public static String readString(int hkey, String key, String valueName, int wow64) throws IllegalArgumentException,
            IllegalAccessException, InvocationTargetException {
        if (hkey == HKEY_LOCAL_MACHINE) {
            return readString(systemRoot, hkey, key, valueName, wow64);
        } else if (hkey == HKEY_CURRENT_USER) {
            return readString(userRoot, hkey, key, valueName, wow64);
        } else {
            throw new IllegalArgumentException(HKEY_EQUALS + hkey);
        }
    }

    
    public static Map<String, String> readStringValues(int hkey, String key, int wow64)
            throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
        if (hkey == HKEY_LOCAL_MACHINE) {
            return readStringValues(systemRoot, hkey, key, wow64);
        } else if (hkey == HKEY_CURRENT_USER) {
            return readStringValues(userRoot, hkey, key, wow64);
        } else {
            throw new IllegalArgumentException(HKEY_EQUALS + hkey);
        }
    }

    
    public static List<String> readStringSubKeys(int hkey, String key, int wow64) throws IllegalArgumentException,
            IllegalAccessException, InvocationTargetException {
        if (hkey == HKEY_LOCAL_MACHINE) {
            return readStringSubKeys(systemRoot, hkey, key, wow64);
        } else if (hkey == HKEY_CURRENT_USER) {
            return readStringSubKeys(userRoot, hkey, key, wow64);
        } else {
            throw new IllegalArgumentException(HKEY_EQUALS + hkey);
        }
    }

        // TODO


    
    public static void writeStringValue(int hkey, String key, String valueName, String value, int wow64)
            throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
        if (hkey == HKEY_LOCAL_MACHINE) {
            writeStringValue(systemRoot, hkey, key, valueName, value, wow64);
        } else if (hkey == HKEY_CURRENT_USER) {
            writeStringValue(userRoot, hkey, key, valueName, value, wow64);
        } else {
            throw new IllegalArgumentException(HKEY_EQUALS + hkey);
        }
    }

    
    public static void deleteKey(int hkey, String key) throws IllegalArgumentException, IllegalAccessException,
            InvocationTargetException {
        int rc = -1;
        if (hkey == HKEY_LOCAL_MACHINE) {
            rc = deleteKey(systemRoot, hkey, key);
        } else if (hkey == HKEY_CURRENT_USER) {
            rc = deleteKey(userRoot, hkey, key);
        }
        if (rc != REG_SUCCESS) {
            throw new IllegalArgumentException("rc=" + rc + "  key=" + key);
        }
    }

    
    public static void deleteValue(int hkey, String key, String value, int wow64) throws IllegalArgumentException,
            IllegalAccessException, InvocationTargetException {
        int rc = -1;
        if (hkey == HKEY_LOCAL_MACHINE) {
            rc = deleteValue(systemRoot, hkey, key, value, wow64);
        } else if (hkey == HKEY_CURRENT_USER) {
            rc = deleteValue(userRoot, hkey, key, value, wow64);
        }
        if (rc != REG_SUCCESS) {
            throw new IllegalArgumentException("rc=" + rc + "  key=" + key + "  value=" + value);
        }
    }

    
    private static int deleteValue(Preferences root, int hkey, String key, String value, int wow64)
            throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
        int[] handles = (int[]) regOpenKey.invoke(root,
            new Object[] { Integer.valueOf(hkey), toCstr(key), Integer.valueOf(KEY_ALL_ACCESS | wow64) });
        if (handles[1] != REG_SUCCESS) {
            return handles[1]; 
        }
        int rc = ((Integer) regDeleteValue.invoke(root, new Object[] { Integer.valueOf(handles[0]), toCstr(value) }))
                .intValue();
        regCloseKey.invoke(root, new Object[] { Integer.valueOf(handles[0]) });
        return rc;
    }

    
    private static int deleteKey(Preferences root, int hkey, String key) throws IllegalArgumentException,
            IllegalAccessException, InvocationTargetException {
        int rc = ((Integer) regDeleteKey.invoke(root, new Object[] { Integer.valueOf(hkey), toCstr(key) })).intValue();
        return rc; 
    }

    
    private static String readString(Preferences root, int hkey, String key, String value, int wow64)
            throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
        int[] handles = (int[]) regOpenKey.invoke(root,
            new Object[] { Integer.valueOf(hkey), toCstr(key), Integer.valueOf(KEY_READ | wow64) });
        if (handles[1] != REG_SUCCESS) {
            return null;
        }
        byte[] valb = (byte[]) regQueryValueEx
                .invoke(root, new Object[] { Integer.valueOf(handles[0]), toCstr(value) });
        regCloseKey.invoke(root, new Object[] { Integer.valueOf(handles[0]) });
        String stringValue = convertByteToUTF8String(valb);
        return (valb != null ? stringValue.trim() : null);
    }

    
    private static Map<String, String> readStringValues(Preferences root, int hkey, String key, int wow64)
            throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
        HashMap<String, String> results = new HashMap<String, String>();
        int[] handles = (int[]) regOpenKey.invoke(root,
            new Object[] { Integer.valueOf(hkey), toCstr(key), Integer.valueOf(KEY_READ | wow64) });
        if (handles[1] != REG_SUCCESS) {
            return null;
        }
        int[] info = (int[]) regQueryInfoKey.invoke(root, new Object[] { Integer.valueOf(handles[0]) });

        int count = info[2]; 
        int maxlen = info[3]; 
        for (int index = 0; index < count; index++) {
            byte[] name = (byte[]) regEnumValue.invoke(root,
                new Object[] { Integer.valueOf(handles[0]), Integer.valueOf(index), Integer.valueOf(maxlen + 1) });
            String stringValue = convertByteToUTF8String(name);
            String value = readString(hkey, key, stringValue, wow64);
            results.put(stringValue.trim(), value);
        }
        regCloseKey.invoke(root, new Object[] { Integer.valueOf(handles[0]) });
        return results;
    }

    
    private static List<String> readStringSubKeys(Preferences root, int hkey, String key, int wow64)
            throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
        List<String> results = new ArrayList<String>();
        int[] handles = (int[]) regOpenKey.invoke(root,
            new Object[] { Integer.valueOf(hkey), toCstr(key), Integer.valueOf(KEY_READ | wow64) });
        if (handles[1] != REG_SUCCESS) {
            return null;
        }
        int[] info = (int[]) regQueryInfoKey.invoke(root, new Object[] { Integer.valueOf(handles[0]) });

        int count = info[0]; 
                             
        int maxlen = info[3]; 
        for (int index = 0; index < count; index++) {
            byte[] name = (byte[]) regEnumKeyEx.invoke(root,
                new Object[] { Integer.valueOf(handles[0]), Integer.valueOf(index), Integer.valueOf(maxlen + 1) });
            String stringValue = convertByteToUTF8String(name);
            results.add(stringValue.trim());
        }
        regCloseKey.invoke(root, new Object[] { Integer.valueOf(handles[0]) });
        return results;
    }

    
    private static int[] createKey(Preferences root, int hkey, String key) throws IllegalArgumentException,
            IllegalAccessException, InvocationTargetException {
        return (int[]) regCreateKeyEx.invoke(root, new Object[] { Integer.valueOf(hkey), toCstr(key) });
    }

    
    private static void writeStringValue(Preferences root, int hkey, String key, String valueName, String value,
        int wow64) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
        int[] handles = (int[]) regOpenKey.invoke(root,
            new Object[] { Integer.valueOf(hkey), toCstr(key), Integer.valueOf(KEY_ALL_ACCESS | wow64) });
        regSetValueEx.invoke(root, new Object[] { Integer.valueOf(handles[0]), toCstr(valueName), toCstr(value) });
        regCloseKey.invoke(root, new Object[] { Integer.valueOf(handles[0]) });
    }

    
    
    private static byte[] toCstr(String str) {
        byte[] result = new byte[str.length() + 1];

        for (int i = 0; i < str.length(); i++) {
            result[i] = (byte) str.charAt(i);
        }
        result[str.length()] = 0;
        return result;
    }

    private static String convertByteToUTF8String(byte[] name) {
        try {
            return new String(name, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            throw new IllegalStateException("UTF-8 should always be available!", e);
        }
    }
}