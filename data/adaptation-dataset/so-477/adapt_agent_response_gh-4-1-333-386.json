{
  "code": "private boolean unpackZip(String presetDir, String zipName) {\n\tFile targetDir = new File(presetDir);\n\tif (!targetDir.exists() && !targetDir.mkdirs()) {\n\t\tLog.w(\"PresetEditorActivity\", \"Could not create preset directory \" + targetDir.getAbsolutePath());\n\t\treturn false;\n\t}\n\tbyte[] buffer = new byte[8192];\n\ttry (InputStream is = new FileInputStream(new File(targetDir, zipName));\n\t\t ZipInputStream zis = new ZipInputStream(new BufferedInputStream(is))) {\n\t\tZipEntry ze;\n\t\twhile ((ze = zis.getNextEntry()) != null) {\n\t\t\tFile outFile = new File(targetDir, ze.getName());\n\t\t\t// Prevent Zip Slip\n\t\t\tString canonicalTargetDir = targetDir.getCanonicalPath();\n\t\t\tString canonicalOutFile = outFile.getCanonicalPath();\n\t\t\tif (!canonicalOutFile.startsWith(canonicalTargetDir + File.separator)) {\n\t\t\t\tLog.w(\"PresetEditorActivity\", \"Skipping suspicious zip entry \" + ze.getName());\n\t\t\t\tzis.closeEntry();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ze.isDirectory()) {\n\t\t\t\tif (!outFile.exists() && !outFile.mkdirs()) {\n\t\t\t\t\tLog.w(\"PresetEditorActivity\", \"Could not create directory \" + outFile.getAbsolutePath());\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tzis.closeEntry();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tFile parent = outFile.getParentFile();\n\t\t\tif (parent != null && !parent.exists() && !parent.mkdirs()) {\n\t\t\t\tLog.w(\"PresetEditorActivity\", \"Could not create directory \" + parent.getAbsolutePath());\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttry (FileOutputStream fout = new FileOutputStream(outFile)) {\n\t\t\t\tint count;\n\t\t\t\twhile ((count = zis.read(buffer)) != -1) {\n\t\t\t\t\tfout.write(buffer, 0, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\tzis.closeEntry();\n\t\t}\n\t\treturn true;\n\t} catch (IOException e) {\n\t\tLog.w(\"PresetEditorActivity\", \"Error unpacking zip \" + zipName, e);\n\t\treturn false;\n\t}\n}",
  "explanation": "code_hardening: Added handling for directory entries via ZipEntry.isDirectory() with mkdirs(), ensured parent directories exist, validated extracted paths against the target directory to prevent Zip Slip, reused a single buffer allocated outside the loop, and used try-with-resources to guarantee stream closure.\nresolve_compilation_errors: Preserved the existing method signature to match current callers, consistently used File for path concatenation, and relied only on classes already imported in the file.\nexception_handling: Wrapped I/O in a single try-with-resources block, caught IOException, logged warnings, and returned false on failure consistent with existing caller expectations.\nlogic_customization: Replaced ByteArrayOutputStream staging with direct streaming from ZipInputStream to FileOutputStream using the shared buffer and read count, and skipped file writing for directory entries.\nrefactoring: Renamed the conceptual parameter from path to presetDir internally for clarity, simplified loop structure, and removed redundant temporary objects.\nmisc: Added minimal Android Log warnings consistent with existing logging style; no new custom API calls beyond standard Java/Android I/O and logging."
}