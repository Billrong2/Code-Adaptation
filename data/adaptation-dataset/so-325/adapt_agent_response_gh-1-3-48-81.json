{
  "code": "@Override\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    // Custom measurement is required so a ListView can size itself correctly when nested in a scrollable parent.\n    super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n    int newHeight = 0;\n    final int heightMode = android.view.View.MeasureSpec.getMode(heightMeasureSpec);\n    final int heightSize = android.view.View.MeasureSpec.getSize(heightMeasureSpec);\n\n    if (heightMode != android.view.View.MeasureSpec.EXACTLY) {\n        final android.widget.ListAdapter listAdapter = getAdapter();\n        if (listAdapter != null && !listAdapter.isEmpty()) {\n            int listPosition = 0;\n            android.view.View convertView = null;\n            for (listPosition = 0;\n                 listPosition < listAdapter.getCount()\n                         && listPosition < MAXIMUM_LIST_ITEMS_VIEWABLE;\n                 listPosition++) {\n                final android.view.View listItem = listAdapter.getView(listPosition, convertView, this);\n                convertView = listItem;\n                if (listItem == null) {\n                    continue;\n                }\n                if (listItem instanceof android.view.ViewGroup) {\n                    listItem.setLayoutParams(new android.view.ViewGroup.LayoutParams(\n                            android.view.ViewGroup.LayoutParams.WRAP_CONTENT,\n                            android.view.ViewGroup.LayoutParams.WRAP_CONTENT));\n                }\n                listItem.measure(widthMeasureSpec, heightMeasureSpec);\n                newHeight += listItem.getMeasuredHeight();\n            }\n            newHeight += getDividerHeight() * listPosition;\n        }\n        if (heightMode == android.view.View.MeasureSpec.AT_MOST && newHeight > heightSize) {\n            newHeight = heightSize;\n        }\n    } else {\n        newHeight = getMeasuredHeight();\n    }\n\n    setMeasuredDimension(getMeasuredWidth(), newHeight);\n}",
  "explanation": "code_hardening: Added a null check for listItem before measuring and reused a local convertView reference to avoid unnecessary object creation while preserving behavior; relied on the existing final MAXIMUM_LIST_ITEMS_VIEWABLE constant.\nresolve_compilation_errors: Used fully qualified references for View.MeasureSpec and ViewGroup.LayoutParams to avoid missing-import issues and aligned with ListView APIs already present in the class.\nexception_handling: none.\nlogic_customization: Preserved the original measurement logic and constraints, explicitly handling non-EXACTLY modes without altering calculated results.\nrefactoring: Limited refactoring to clearer local variable usage within the function only; no signature or behavioral changes were introduced.\nmisc: Updated formatting and added a brief method-level comment explaining why a custom onMeasure implementation is necessary; no new custom API calls were introduced."
}