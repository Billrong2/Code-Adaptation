{
  "code": "    /**\n     * Converts geographic coordinates (latitude/longitude in degrees) to UTM coordinates.\n     * This is a pure function with no side effects; it computes the UTM zone, latitudinal band,\n     * easting, and northing (meters), including the southern-hemisphere offset and rounds\n     * easting/northing to two decimal places.\n     *\n     * @param loc input location containing latitude and longitude in degrees\n     * @return a UTMTuple representing the corresponding UTM coordinate\n     * @throws IllegalArgumentException if loc is null or latitude/longitude are out of range\n     */\n    public static UTMTuple deg2UTM(LocTuple loc) {\n        if (loc == null) {\n            throw new IllegalArgumentException(\"LocTuple must not be null\");\n        }\n        double lat = loc.getLatitude();\n        double lon = loc.getLongitude();\n        if (lat < -90.0 || lat > 90.0) {\n            throw new IllegalArgumentException(\"Latitude out of range: \" + lat);\n        }\n        if (lon < -180.0 || lon > 180.0) {\n            throw new IllegalArgumentException(\"Longitude out of range: \" + lon);\n        }\n\n        // Ellipsoid / projection constants (WGS84-derived, as used in original snippet)\n        final double k0 = 0.9996;\n        final double a = 6399593.625;\n        final double e2p = 0.006739496742;\n        final double e = 0.0820944379;\n\n        int zone = (int) Math.floor(lon / 6.0 + 31.0);\n\n        char letter;\n        if (lat < -72) letter = 'C';\n        else if (lat < -64) letter = 'D';\n        else if (lat < -56) letter = 'E';\n        else if (lat < -48) letter = 'F';\n        else if (lat < -40) letter = 'G';\n        else if (lat < -32) letter = 'H';\n        else if (lat < -24) letter = 'J';\n        else if (lat < -16) letter = 'K';\n        else if (lat < -8)  letter = 'L';\n        else if (lat < 0)   letter = 'M';\n        else if (lat < 8)   letter = 'N';\n        else if (lat < 16)  letter = 'P';\n        else if (lat < 24)  letter = 'Q';\n        else if (lat < 32)  letter = 'R';\n        else if (lat < 40)  letter = 'S';\n        else if (lat < 48)  letter = 'T';\n        else if (lat < 56)  letter = 'U';\n        else if (lat < 64)  letter = 'V';\n        else if (lat < 72)  letter = 'W';\n        else                letter = 'X';\n\n        double latRad = Math.toRadians(lat);\n        double lonRad = Math.toRadians(lon);\n        double lonOriginRad = Math.toRadians(6 * zone - 183);\n\n        double cosLat = Math.cos(latRad);\n        double sinLonDiff = Math.sin(lonRad - lonOriginRad);\n\n        double t = 0.5 * Math.log((1 + cosLat * sinLonDiff) / (1 - cosLat * sinLonDiff));\n        double v = a * k0 / Math.sqrt(1 + Math.pow(e, 2) * Math.pow(cosLat, 2));\n\n        double easting = v * t * (1 + Math.pow(e, 2) / 2 * Math.pow(t, 2) * Math.pow(cosLat, 2) / 3) + 500000.0;\n        easting = Math.round(easting * 100.0) / 100.0;\n\n        double northing = (Math.atan(Math.tan(latRad) / Math.cos(lonRad - lonOriginRad)) - latRad) * v *\n                (1 + e2p / 2 * Math.pow(t, 2) * Math.pow(cosLat, 2))\n                + k0 * a * (latRad\n                - 0.005054622556 * (latRad + Math.sin(2 * latRad) / 2)\n                + 4.258201531e-05 * (3 * (latRad + Math.sin(2 * latRad) / 2)\n                + Math.sin(2 * latRad) * Math.pow(cosLat, 2)) / 4\n                - 1.674057895e-07 * (5 * (3 * (latRad + Math.sin(2 * latRad) / 2)\n                + Math.sin(2 * latRad) * Math.pow(cosLat, 2)) / 4\n                + Math.sin(2 * latRad) * Math.pow(cosLat, 4)) / 3);\n\n        if (letter < 'M') {\n            northing += 10000000.0;\n        }\n        northing = Math.round(northing * 100.0) / 100.0;\n\n        return new UTMTuple(zone, letter, easting, northing);\n    }",
  "explanation": "code_hardening: Added null-check for LocTuple and explicit latitude/longitude range validation. Used final local constants for projection parameters to avoid magic numbers and accidental mutation.\nresolve_compilation_errors: Converted implicit fields (Zone, Letter, Easting, Northing) into local variables and returned them via a UTMTuple. Replaced the invalid constructor-style method with a valid public static method returning UTMTuple.\nexception_handling: Chose to throw IllegalArgumentException for null or out-of-range inputs and documented this behavior in the Javadoc; no try/catch was added since no checked exceptions are required.\nlogic_customization: Extracted latitude and longitude from LocTuple, preserved the original UTM zone/band logic, easting/northing formulas, southern hemisphere offset, and two-decimal rounding, while ensuring the function is pure and stateless.\nrefactoring: Renamed the method to deg2UTM, changed access to public static, improved readability with intermediate variables (radians, constants), and replaced field mutation with construction and return of a UTMTuple.\nmisc: Added a descriptive Javadoc comment explaining inputs, outputs, and coordinate system; formatting was cleaned for readability. No new custom API calls were introduced beyond existing LocTuple and UTMTuple usage."
}