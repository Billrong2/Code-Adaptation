{
  "code": "public boolean onTouch(View v, MotionEvent event) {\n    if (v == null || event == null) {\n        return false;\n    }\n\n    switch (event.getAction()) {\n        case MotionEvent.ACTION_DOWN: {\n            Log.d(logTag, \"ACTION_DOWN\");\n            timeDown = System.currentTimeMillis();\n            downX = event.getX();\n            downY = event.getY();\n            return true;\n        }\n\n        case MotionEvent.ACTION_UP: {\n            Log.d(logTag, \"ACTION_UP\");\n            long timeUp = System.currentTimeMillis();\n            float upX = event.getX();\n            float upY = event.getY();\n\n            float deltaX = downX - upX;\n            float absDeltaX = Math.abs(deltaX);\n            float deltaY = downY - upY;\n            float absDeltaY = Math.abs(deltaY);\n\n            long time = timeUp - timeDown;\n\n            if (absDeltaY > MAX_OFF_PATH) {\n                Log.i(logTag, String.format(\n                        \"absDeltaY=%.2f, MAX_OFF_PATH=%.2f\", absDeltaY, MAX_OFF_PATH));\n                return v.performClick();\n            }\n\n            final long M_SEC = 1000L;\n            if (absDeltaX > MIN_DISTANCE && absDeltaX > time * VELOCITY / M_SEC) {\n                if (deltaX < 0) {\n                    onLeftToRightSwipe(v);\n                    return true;\n                }\n                if (deltaX > 0) {\n                    onRightToLeftSwipe(v);\n                    return true;\n                }\n            } else {\n                Log.i(logTag,\n                        String.format(\n                                \"absDeltaX=%.2f, MIN_DISTANCE=%.2f, absDeltaX > MIN_DISTANCE=%b\",\n                                absDeltaX, MIN_DISTANCE, (absDeltaX > MIN_DISTANCE)));\n                Log.i(logTag,\n                        String.format(\n                                \"absDeltaX=%.2f, time=%d, VELOCITY=%d, time*VELOCITY/M_SEC=%d, absDeltaX > time * VELOCITY / M_SEC=%b\",\n                                absDeltaX, time, VELOCITY, time * VELOCITY / M_SEC,\n                                (absDeltaX > time * VELOCITY / M_SEC)));\n            }\n            return false;\n        }\n\n        default:\n            return false;\n    }\n  }",
  "explanation": "code_hardening: Added null checks for View and MotionEvent to avoid unexpected NullPointerExceptions; otherwise no additional hardening was required per plan.\nresolve_compilation_errors: Removed all references to requestDisallowInterceptTouchEvent and ACTION_MOVE-related variables/logic so no unused symbols remain; ensured use of existing class fields (downX, downY, timeDown, constants) to compile cleanly.\nexception_handling: none.\nlogic_customization: Eliminated ACTION_MOVE handling entirely and simplified gesture processing to ACTION_DOWN and ACTION_UP only; retained swipe detection based on DOWN/UP deltas and time; preserved MAX_OFF_PATH vertical deviation check but downgraded the log from error to info and still fall back to v.performClick(); removed all parent touch-interception control calls.\nrefactoring: Simplified the switch statement to two cases (DOWN/UP), removed MOVE-specific calculations, and kept naming consistent with existing fields to improve readability.\nmisc: Preserved existing diagnostic logging for distance and velocity thresholds; adjusted logging to reflect the simplified flow with no MOVE-related logs. New custom API calls: none."
}